\documentclass{beamer}

%\input{odl_preamble.tex}
% The amssymb package provides various useful mathematical symbols
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx} % for includegraphics
\usepackage{xspace} % needed for \eg, \ie, \etc
\usepackage{bm} % for bold math
\usepackage{threeparttable} % for tables with footnotes
%\usepackage{subfigure}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}

% hyperref must be last
% Commented out 20151129 - AA
%\usepackage{hyperref}
%\hypersetup{
%  colorlinks=true,
%  linkcolor=red,
%  citecolor=green,
%  urlcolor=blue
%}
  
% We often use mathcal for functions
\newcommand{\fnc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\vecfnc}[1]{\ensuremath{\boldsymbol{\mathcal{#1}}}} % vector function

% matrices are often math sans serif type
\newcommand{\mat}[1]{\ensuremath{\mathsf{#1}}}

% SBP operator matrices

% command latin phrases and other short-forms
\newcommand{\etal}[0]{{\em et~al.\@}\xspace}
\newcommand{\eg}[0]{{e.g.\@}\xspace}
\newcommand{\ie}[0]{{i.e.\@}\xspace}
\newcommand{\viz}[0]{{viz.\@}\xspace}
\newcommand{\resp}[0]{{resp.\@}\xspace}

% Misc. commands
\newcommand{\ignore}[1]{} % comment out large sections of code

%\usepackage{cite}
%\usepackage{graphicx}
\usepackage{subcaption}

\usepackage[scale=2]{ccicons}
%\usepackage{bm}
\usepackage{tikz}
%\graphicspath{{./results/nozzle/}}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amsthm}
%\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsbsy}
\usepackage{amsopn}
\usepackage{array}
%\usepackage[labelformat=empty]{subfig}
%\usepackage{subfigure}
%\usepackage{subfig}
\usepackage{verbatim}
\usepackage{minted}
%\usepackage{subfigmat} 
%\usepackage{bm}
%\usepackage{threeparttable}
%%\usepackage{dcolumn}
\newcolumntype{d}{D{.}{.}{-1}}
%\usepackage{hhline}
%\usepackage{xspace}
%\usepackage[ruled,linesnumbered]{algorithm2e}

\newcommand{\ttt}{\texttt}
\newcommand{\die}{\partial}
%\newcommand{\ds}{\mathrm{d}s}




%  \bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usetheme{Berlin}
\usecolortheme{beaver}

\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{bibliography item}{\insertbiblabel}

\captionsetup[figure]{labelformat=empty}
%\setbeamertemplate{footline}[frame number]
%\addtobeamertemplate{footline}[frame number]
\expandafter\def\expandafter\insertshorttitle\expandafter{%
  \insertshorttitle\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}
  
\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\title{Julia Petsc Interface}
%\subtitle{Volume Integration, Edge Stabilization, Administration}
\author[]{Jared Crean, Katharine Hyatt, Steven G. Johnson, Alan Edelman}
%\author[Jared Crean, Kinshuk Panda,Anthony Ashley,Jason Hicken]{Jared Crean, Kinshuk Panda, Anthony Ashley, Jason Hicken}
%\institute{Rensselaer Polytechnic Institute}
%\titlegraphic{\includegraphics[width=\textwidth]{logo_both4.png}}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{What is Petsc?}
Portable, Extensible Toolkit for Scientific Computation, provides all the 
capabilities needed to assembled and solve systems of linear and non-linear 
equations
arising from discretizing partial differential equations on supercomputers.
\begin{itemize}
  \item Vec: distributed memory vectors 
  \item Mat: distributed memory sparse matrices
  \item Mappings: Index Sets, Application Orderings, Local to Global Mappings
  \item KSP: Krylov solvers for linear systems
  \item SNES: Non-linear equation solvers (globalized Newton)
  \item TS: time stepping for ODEs and DAEs
\end{itemize}
Parallelization through MPI
\end{frame}


\begin{frame}{Wrapping Petsc}

\begin{itemize}
  \item Clang.jl reads the Petsc header files, generates equivalent Julia code (if given the right preprocessor flags)
  \item Write high level interface on top of generated wrappers
    \begin{itemize}
      \item \texttt{AbstractArray}
      \item Backslash
    \end{itemize}
\end{itemize}
\hfill

Requires linking to multiple versions of Petsc

\end{frame}

\begin{comment}
\begin{frame}[fragile]{The Rewriter}
For each Petsc object, introduce a Julia immutable type
\begin{itemize}
  \item Parameterize on datatype \texttt{T} to enable dispatch
\end{itemize}
\begin{minted}{julia}
  typealias Mat Ptr{_p_Mat} -> immutable Mat{T}
\end{minted}
\hfill

Also map C equivalent types to more general types:
%\begin{itemize}
\begin{minted}{julia} 
  Ptr{Float64} -> Union{DenseArray{Float64},
                        Ptr{Float64}, Ref{Float64}}
\end{minted}
%\end{itemize}
\hfill

Implemented with a recursive descent search and replace on the \texttt{Expr}s 
generated by Clang.jl

\end{frame}
\end{comment}

\begin{frame}[fragile]{High Level Petsc Arrays}
Petsc \texttt{Vec}s and \texttt{Mat}s as similar to \texttt{AbstractArrays} as possible
\begin{itemize}
  \item indexing, dimensions, subset of BLAS
\end{itemize}
\hfill


Extended to distributed memory
\begin{itemize}
  \item local dimensions, access to local data
  \item need to call \texttt{assemble} for indexing changes to take effect
\end{itemize}

\end{frame}

\begin{frame}{Krylov Solvers}
\hfill

A wide variety of Krylov methods and preconditioners are available
\begin{itemize}
  \item GMRES, fGMRES, lGMRES, ...
  \item iLU(k), Jacobi, block Jacobian, SOR, ...
  \item Can use different matrices for solve, preconditioner
  \item Also supports matrix-free methods
\end{itemize}
\hfill

Backslash on a PETSc matrix uses default settings, users can create KSP object for more granular control
\end{frame}

\begin{frame}[fragile]{Iterative Solve Example}
\begin{minted}{julia}
n = 5
A = Mat(Float64, n,n)
b = Vec(Float64, n)
A[1,1] = 1; b[1] = 0
A[n,n] = 1; b[n] = 0

for i=2:n-1
  A[i, (i-1):(i+1)] = [1.0, -2.0, 1.0]
  b[i] = i
end
assemble(A); assemble(b)
x = A\b
\end{minted}
\end{frame}

\begin{frame}[fragile]{Options Paradigm}
Petsc uses an global database to set all the options for its components
\begin{itemize}
  \item \textbf{All} the options
  \item Allows maximum control with minimal API
\end{itemize}
\hfill

Ex.
\begin{minted}{julia}
  OPTIONS[Float64]["ksp_type"] = "fgmres"
  OPTIONS[Float64]["ksp_gmres_modifiedgramschmidt"] = ""
  OPTIONS[Float64]["pc_type"] = "ilu"
  OPTIONS[Float64]["pc_factor_levels"] = "3"
\end{minted}

\end{frame}

\begin{frame}{Composability}
Petsc is highly composable
\begin{itemize}
  \item \texttt{Mat} + Krylov options + preconditioner $\rightarrow$ Linear solver (\texttt{KSP})
  \item Linear solver + Jacobian function $\rightarrow$ Nonlinear solver (\texttt{SNES})
  \item Nonlinear solver + function evaluation $\rightarrow$ Timestepper (\texttt{TS})
\end{itemize}
\hfill

The user forms the system, PETSc contains the algorithms to solve it
\end{frame}



\begin{frame}{Future Work}
  \begin{itemize}
    \item SNES
    \item More Vec abstractions
    \item More Mat constructors
    \item Pre-build binaries for Windows and OSX
  \end{itemize}
\end{frame}

\begin{frame}
\begin{center} \usebeamerfont*{frametitle} \usebeamercolor[fg]{frametitle}
  Check it out: \hyperref[https://github.com/JuliaParallel/PETSc.jl]{https://github.com/JuliaParallel/PETSc.jl}
\end{center}

\end{frame}


\end{document}





























