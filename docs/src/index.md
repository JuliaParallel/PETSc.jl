# PETSc.jl

[PETSc.jl](https://github.com/JuliaParallel/PETSc.jl) is a Julia wrapper for the Portable, Extensible Toolkit for Scientific Computation [PETSc](https://petsc.org/) package, which allows solving ordinary and partial differential equations in parallel on laptops or massively parallel high-performance systems.

The use of Julia greatly simplifies the code that developers have to write, while allowing them to employ Julia features such as automatic differentiation. The Julia wrapper also comes with a pre-built library, which greatly simplifies the process of getting your first code working in parallel on different operating systems. In many cases, the Julia code is significantly shorter than its C counterpart.

This wrapper mimics the PETSc functionality as closely as possible, but remains work in progress. We have (semi-automatically) translated most of the functionality of PETSc, along with help docstrings. Yet, the higher-level interface is only available for part of the library. Likewise, the tests currently only cover part of the library, so we can only guarantee that this part works.

See the official [user guide](https://petsc.org/release/overview/) if you want to learn more about PETSc in general. For Julia-specific examples, have a look at our [examples](https://github.com/JuliaParallel/PETSc.jl/tree/main/examples) or [tests](https://github.com/JuliaParallel/PETSc.jl/tree/main/test).

## The High-Level Interface

The high-level interface is designed to be familiar and convenient for Julia users, but exposes only a small portion of the functionality of the underlying PETSc library.

For example, with this interface, PETSc's [KSP](https://petsc.org/release/docs/manual/ksp) linear solvers (including Krylov methods) can be used in a way similar to solvers from other Julia packages. See the example in [Getting started](@ref) and the API in [KSP](@ref).

For nonlinear problems, [NonlinearSolve.jl](https://github.com/SciML/NonlinearSolve.jl) provides a high-level interface to PETSc's [SNES](https://petsc.org/release/docs/manual/snes) nonlinear solvers. This integration offers automatic sparsity detection, efficient sparse Jacobian computation, and a unified API that works across multiple solver backends.

## The Low-Level Interface

The low-level interface covers most of the PETSc API, but may be awkward to work with and likely requires previous experience with PETSc to use effectively. It is (mostly) automatically generated by borrowing the Python code that creates Fortran wrappers for PETSc.

The high-level interface described in [KSP](@ref) creates a [KSP](https://petsc.org/release/docs/manual/ksp) linear solver object via the low-level interface to [`KSPSolve()`](https://petsc.org/release/docs/manualpages/KSP/KSPCreate.html), with the use of constructs which require knowledge of PETSc's nature as a [C library](https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/). Expert users are of course free to directly use the low-level interface, as in this simple example which directly calls [`PetscGetVersionNumber()`](https://petsc.org/release/docs/manualpages/PetscGetVersionNumber.html).

```julia
using MPI
MPI.Initialized() || MPI.Init()
using PETSc

# Select the appropriate library
petsclib = PETSc.petsclibs[1]

# Initialize PETSc (with logging turned off; the default)
PETSc.initialize(petsclib, log_view=false)

# Call the low-level interface (which always starts with petsclib)
version = LibPETSc.PetscGetVersionNumber(petsclib)

# Print result
println("PETSc $(version[1]).$(version[2]).$(version[3])")

# Finalize
PETSc.finalize(petsclib)
```
