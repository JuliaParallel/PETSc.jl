<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Julia Petsc interface documentation">
  <meta name="author" content="JaredCrean2">
  
  <title>PETSc.jl</title>
  

  <link rel="shortcut icon" href="./img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="./css/theme.css" type="text/css" />
  <link rel="stylesheet" href="./css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="./css/highlight.css">
  <link href="./assets/Documenter.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "None";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = "/";
  </script>
  
  <script src="./js/jquery-2.1.1.min.js"></script>
  <script src="./js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="./js/highlight.pack.js"></script>
  <script src="./js/theme.js"></script> 
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML - assets/mathjaxhelper.js"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> PETSc.jl</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href=".">Home</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#_1">=</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">PETSc.jl</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/JuliaParallel/PETSc.jl" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='PETSc.LocalArrays' href='#PETSc.LocalArrays'>#</a>
<strong><code>PETSc.LocalArrays</code></strong> &mdash; <em>Constant</em>.</p>
<p>Typealias for both kinds of LocalArrays</p>
<p><a id='PETSc.NullVec' href='#PETSc.NullVec'>#</a>
<strong><code>PETSc.NullVec</code></strong> &mdash; <em>Constant</em>.</p>
<p>Null vectors, used in place of void pointers in the C   API</p>
<p><a id='PETSc.mat2vec' href='#PETSc.mat2vec'>#</a>
<strong><code>PETSc.mat2vec</code></strong> &mdash; <em>Constant</em>.</p>
<p>Maps Matrix formats to the corresponding vector format</p>
<p><a id='PETSc.KSP' href='#PETSc.KSP'>#</a>
<strong><code>PETSc.KSP</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>KSP(A::Mat, PA=A; kws...)
KSP(pc::PC; kws...)
</code></pre>

<p>Create a KSP solver object that can be used to solve equations <code>Ax=b</code> with the matrix <code>A</code>, where <code>PA</code> (defaults to <code>A</code>) is used to construct the default preconditioner.  Alternatively, you can supply a preconditioner object (<code>PC</code>).</p>
<p>The keyword options are zero or more of the following:</p>
<p>These control the solver and preconditioner characteristics: * <code>ksp_type="a"</code>: use KSP algorithm <code>a</code> * <code>ksp_pc_side=n</code>: set preconditioner side to <code>PETSc.C.PC_LEFT</code>, <code>PETSc.C.PC_RIGHT</code>, or <code>PETSc.C.PC_SYMMETRIC</code> * <code>ksp_reuse_preconditioner=true</code>: use initial preconditioner and don't ever compute a new one * <code>ksp_diagonal_scale=true</code>: symmetrically diagonally scale <code>A</code> before solving (note that this <em>changes</em> <code>A</code> and the right-hand side in a solve, unless you also set <code>ksp_diagonal_scale_fix=true</code>) * <code>ksp_diagonal_scale_fix=true</code>: undo diagonal scaling after solve * <code>ksp_knoll=true</code>: use preconditioner applied to <code>b</code> for initial guess * <code>ksp_constant_null_space=true</code>: add constant null space to Krylov solver matrix * <code>ksp_initial_guess_nonzero=true</code>: use the contents of initial <code>x</code> instead of zero for initial guess * <code>ksp_fischer_guess="model,size"</code>: use Fischer initial guess generator (<code>model=1</code> or <code>2</code>) for repeated linear solves with subspace of dimension <code>size</code></p>
<p>The following keyword options control the stopping criteria for iterative solvers: * <code>ksp_rtol=x</code>: <code>x</code> is relative decrease in residual norm * <code>ksp_atol=x</code>: <code>x</code> is absolute decrease in residual norm * <code>ksp_divtol=x</code>: <code>x</code> is amount residual can increase before method is considered to be diverging * <code>ksp_max_it=n</code>: <code>n</code> is the max number of iterations * <code>ksp_converged_use_initial_residual_norm=true</code>: use initial residual norm for computing relative convergence * <code>ksp_converged_use_min_initial_residual_norm=true</code>: use min of initial residual norm and <code>b</code> for computing relative convergence * <code>ksp_error_if_not_converged=true</code>: generate error if solver does not converge * <code>ksp_convergence_test=:default</code> or <code>:skip</code>: use the default convergence test (tolerances and <code>max_it</code>) or skip convergence tests and run until <code>max_it</code> is reached * <code>ksp_norm_type=n</code>: in residual tests, use norm type <code>n</code>, one of default (<code>PETSc.C.KSP_NORM_DEFAULT</code>), none (<code>PETSc.C.KSP_NORM_NONE</code>), of the preconditioned residual (<code>PETSc.C.KSP_NORM_PRECONDITIONED</code>), the true residual (<code>PETSc.C.KSP_NORM_UNPRECONDITIONED</code>), or the "natural" norm (<code>PETSc.C.KSP_NORM_NATURAL</code>) * <code>ksp_check_norm_iteration=n</code>: compute residual norm starting on iteration <code>n</code> * <code>ksp_lag_norm=true</code>: lag the calculation of the residual norm by one iteration (trades off reduced communication for an additional iteration)</p>
<p>The following options control output that monitors the progress of the solver (default none). * <code>ksp_monitor=filename</code>: print the residual norm at each iteration to <code>filename</code> (<code>""</code> for <code>STDOUT</code>) * <code>ksp_monitor_short=filename</code>: print preconditioned residual norm with fewer digits * <code>ksp_monitor_range=filename</code>: prints the percentage of residual elements that are more then 10% of the maximum value * <code>ksp_monitor_true_residual=filename</code>: print true residual norm * <code>ksp_monitor_singular_value=filename</code>: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved) * <code>ksp_monitor_solution=true</code>: plot solution graphically * <code>ksp_monitor_lg_residualnorm=true</code>: plot preconditioned residual norm graphically * <code>ksp_monitor_lg_true_residualnorm=true</code>: plot preconditioned and true residual norm graphically * <code>ksp_monitor_lg_range=true</code>: plot preconditioned residual norm and range of residual values * <code>ksp_monitor_cancel=true</code>: remove any hardwired monitor routines * <code>ksp_compute_singularvalues=true</code>: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved)</p>
<p>In addition, if default preconditioner is being used, then any of the preconditioner options (see <code>PC</code>) can be specified to control this preconditioner (e.g. <code>pc_type</code>).</p>
<p><a id='PETSc.LocalArray' href='#PETSc.LocalArray'>#</a>
<strong><code>PETSc.LocalArray</code></strong> &mdash; <em>Type</em>.</p>
<p>Object representing the local part of the array, accessing the memory directly.   Supports all the same indexing as a regular Array</p>
<p><a id='PETSc.LocalArrayRead' href='#PETSc.LocalArrayRead'>#</a>
<strong><code>PETSc.LocalArrayRead</code></strong> &mdash; <em>Type</em>.</p>
<p>Get read-only access to the memory underlying a Petsc vector</p>
<p><a id='PETSc.Mat' href='#PETSc.Mat'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Type</em>.</p>
<p>Create a high level matrix from an already created matrix pointer</p>
<p>Create a matrix of a particular size, optionally specifying the pre-allocation.   If pre-allocation is not specified, no preallocation is done</p>
<p>Create an empty, unsized matrix</p>
<p><a id='PETSc.PC' href='#PETSc.PC'>#</a>
<strong><code>PETSc.PC</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>PC(A::Mat, PA=A, kws...)
</code></pre>

<p>Create a preconditioner (PC) context, given the matrix <code>A</code> of the linear system to be solved, and optionally a different matrix <code>PA</code> from which the preconditioner is constructed.</p>
<p>The remaining keywords specify zero or more additional options: * <code>pc_type="a"</code>: use preconditioning algorithm <code>a</code> * <code>pc_use_amat=true</code>: use Amat (instead of Pmat) to define preconditioner in nested inner solves * ... additional options that depend on the preconditioner type ...</p>
<p><a id='PETSc.SubMat' href='#PETSc.SubMat'>#</a>
<strong><code>PETSc.SubMat</code></strong> &mdash; <em>Type</em>.</p>
<p>Gets the a submatrix that references the entries in the original matrix.   isrow and iscol contain the <em>local</em> indicies of the rows and columns to get.   The matrix must have a LocalToGlobalMapping for this to work, therefore a    default one is created if the matrix does not already have one registered.   The default mapping assumes the matrix is divided up into contiguous block   of rows.  This is true of AIJ matrices but may not be for other matrix types.</p>
<p><a id='PETSc.TS' href='#PETSc.TS'>#</a>
<strong><code>PETSc.TS</code></strong> &mdash; <em>Type</em>.</p>
<p>More explicit constructor: set problem type, method directly</p>
<p><code>tsptype</code> sets the problem type and can be one of the following: * <code>TS_LINEAR</code> - a linear set of ODEs  * <code>TS_NONLINEAR</code> - a nonlinear set of ODEs or DEAs</p>
<p><code>tstype</code> sets the method used to solve the problem. More information about the possible methods is available at the official PETSc <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSType.html">docs</a>.</p>
<p>Preferred constructor: set problem type explicitly, get method from   options database</p>
<p>Most preferred constructor: taake ProblemType, method from options   database</p>
<p><a id='PETSc.Vec' href='#PETSc.Vec'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Type</em>.</p>
<p>Construct a high level Vec object from a low level C.Vec.   The data field is used to protect things from GC.   A finalizer is attached to deallocate the memory of the underlying C.Vec, unless    first_instance is set to true.   If assembling is false, then every call to setindex! also calls AssembleBegin and    AssembleEnd.</p>
<p><a id='Base.SparseMatrix.nnz' href='#Base.SparseMatrix.nnz'>#</a>
<strong><code>Base.SparseMatrix.nnz</code></strong> &mdash; <em>Function</em>.</p>
<p>Number of non-zero entries that have been assigned to</p>
<p><a id='Base.fill!' href='#Base.fill!'>#</a>
<strong><code>Base.fill!</code></strong> &mdash; <em>Function</em>.</p>
<p>Fill the matrix with the specified values.</p>
<p>Currently, this function either destroys the sparsity pattern or    gives an error, unless v = 0, in which case it zeros out the non-zero    entries without changing the sparsity pattern</p>
<p><a id='Base.full' href='#Base.full'>#</a>
<strong><code>Base.full</code></strong> &mdash; <em>Function</em>.</p>
<p>Create a dense Julia matrix for a Petsc sparse matrix.  This only works   for SEQ matrices</p>
<p><a id='Base.length' href='#Base.length'>#</a>
<strong><code>Base.length</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the global length of the vector</p>
<p><a id='Base.map!' href='#Base.map!'>#</a>
<strong><code>Base.map!</code></strong> &mdash; <em>Function</em>.</p>
<p>Multiple source vector map.  All vectors must have the local and global    lengths.  If some a ghost vectors and some are not, the map is applied   only to the local part</p>
<p>Applys f element-wise to src to populate dest.  If src is a ghost vector, then f is applied to the ghost elements as well as the local elements.</p>
<p><a id='Base.size' href='#Base.size'>#</a>
<strong><code>Base.size</code></strong> &mdash; <em>Function</em>.</p>
<p>Returns the global dimensions of the matrix</p>
<p>Get the global size of the vector</p>
<p><a id='PETSc.AssemblyBegin' href='#PETSc.AssemblyBegin'>#</a>
<strong><code>PETSc.AssemblyBegin</code></strong> &mdash; <em>Function</em>.</p>
<p>Start assembling the matrix (the implmentations probably post    non-blocking sends and received)</p>
<p>Start communication to assemble stashed values into the vector</p>
<p><a id='PETSc.AssemblyEnd' href='#PETSc.AssemblyEnd'>#</a>
<strong><code>PETSc.AssemblyEnd</code></strong> &mdash; <em>Function</em>.</p>
<p>Finish assembling the matrix</p>
<p>Finish communication for assembling the vector</p>
<p><a id='PETSc.LocalArrayRestore' href='#PETSc.LocalArrayRestore'>#</a>
<strong><code>PETSc.LocalArrayRestore</code></strong> &mdash; <em>Function</em>.</p>
<p>Tell Petsc the LocalArray is no longer being used</p>
<p><a id='PETSc.MatShell' href='#PETSc.MatShell'>#</a>
<strong><code>PETSc.MatShell</code></strong> &mdash; <em>Function</em>.</p>
<p>Create a shell matrix with specified size.  The ctx tuple contains can be   accessed by any callback function.</p>
<p><a id='PETSc.PetscDestroy' href='#PETSc.PetscDestroy'>#</a>
<strong><code>PETSc.PetscDestroy</code></strong> &mdash; <em>Function</em>.</p>
<p>Destroy a Mat object and the underlying data structure, if the object   has not already been finalized</p>
<p>The Petsc function to deallocate Vec objects</p>
<p><a id='PETSc.VecGhost' href='#PETSc.VecGhost'>#</a>
<strong><code>PETSc.VecGhost</code></strong> &mdash; <em>Function</em>.</p>
<p>Make a PETSc vector with space for ghost values.  ghost_idx are the    global indices that will be copied into the ghost space.</p>
<p><a id='PETSc.VecLocal' href='#PETSc.VecLocal'>#</a>
<strong><code>PETSc.VecLocal</code></strong> &mdash; <em>Function</em>.</p>
<p>Create a VECSEQ that contains both the local and the ghost values of the    original vector.  The underlying memory for the orignal and output vectors   alias.</p>
<p><a id='PETSc.assemble' href='#PETSc.assemble'>#</a>
<strong><code>PETSc.assemble</code></strong> &mdash; <em>Function</em>.</p>
<p>Low level assemble function</p>
<p>Assemble the Petsc object</p>
<p>This function provides a mechanism for efficiently inserting values into   and then assembling Petsc matrices and vectors.  The function f must be a    zero argument function.</p>
<p>This function can be used with the do block syntax.</p>
<p><a id='PETSc.comm' href='#PETSc.comm'>#</a>
<strong><code>PETSc.comm</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the communicator for the object</p>
<p>Gets the MPI communicator of a vector.</p>
<p><a id='PETSc.getcontext' href='#PETSc.getcontext'>#</a>
<strong><code>PETSc.getcontext</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the tuple of user provided data passed in when the shell matrix was    created.</p>
<p><a id='PETSc.getinfo' href='#PETSc.getinfo'>#</a>
<strong><code>PETSc.getinfo</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the MatInfo struct for the matrix</p>
<p><a id='PETSc.gettype' href='#PETSc.gettype'>#</a>
<strong><code>PETSc.gettype</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the format of the matrix.</p>
<p>Get the symbol that is the format of the vector</p>
<p><a id='PETSc.ghost_begin!' href='#PETSc.ghost_begin!'>#</a>
<strong><code>PETSc.ghost_begin!</code></strong> &mdash; <em>Function</em>.</p>
<p>Start communication to update the ghost values (on other processes) from the local   values</p>
<p><a id='PETSc.ghost_end!' href='#PETSc.ghost_end!'>#</a>
<strong><code>PETSc.ghost_end!</code></strong> &mdash; <em>Function</em>.</p>
<p>Finish communication for updating ghost values</p>
<p><a id='PETSc.ghost_update!' href='#PETSc.ghost_update!'>#</a>
<strong><code>PETSc.ghost_update!</code></strong> &mdash; <em>Function</em>.</p>
<p>Convenience method for calling ghost_begin! and ghost_end! for multiple vectors</p>
<p><a id='PETSc.has_local_to_global_mapping' href='#PETSc.has_local_to_global_mapping'>#</a>
<strong><code>PETSc.has_local_to_global_mapping</code></strong> &mdash; <em>Function</em>.</p>
<p>Check if the local to global mappings have been registered</p>
<p><a id='PETSc.iassemble' href='#PETSc.iassemble'>#</a>
<strong><code>PETSc.iassemble</code></strong> &mdash; <em>Function</em>.</p>
<p>Perform a flush assembly (take stashed values and put them into the matrix,   but don't squeeze out any preallocated space that has not been used yet</p>
<p><a id='PETSc.isassembled' href='#PETSc.isassembled'>#</a>
<strong><code>PETSc.isassembled</code></strong> &mdash; <em>Function</em>.</p>
<p>Check if the matrix is assembled</p>
<p>Check if the matrix is assembled or not</p>
<p>Check if a vector is assembled (ie. does not have stashed values)</p>
<p><a id='PETSc.isfinalized' href='#PETSc.isfinalized'>#</a>
<strong><code>PETSc.isfinalized</code></strong> &mdash; <em>Function</em>.</p>
<p>Check if PetscDestroy has been called on this object already</p>
<p>Determine whether a vector has already been finalized</p>
<p><a id='PETSc.lengthlocal' href='#PETSc.lengthlocal'>#</a>
<strong><code>PETSc.lengthlocal</code></strong> &mdash; <em>Function</em>.</p>
<p>prod(sizelocal))</p>
<p>Get the length of the local portion of the vector</p>
<p><a id='PETSc.localIS' href='#PETSc.localIS'>#</a>
<strong><code>PETSc.localIS</code></strong> &mdash; <em>Function</em>.</p>
<p>Constructs 2 index sets that map from the local row and columns to the   global rows and columns</p>
<p><a id='PETSc.local_to_global_mapping' href='#PETSc.local_to_global_mapping'>#</a>
<strong><code>PETSc.local_to_global_mapping</code></strong> &mdash; <em>Function</em>.</p>
<p>Construct ISLocalToGlobalMappings for the the rows and columns of the matrix</p>
<p><a id='PETSc.localpart' href='#PETSc.localpart'>#</a>
<strong><code>PETSc.localpart</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the range of global indices that define the local part of the vector.   Internally, this calls the Petsc function VecGetOwnershipRange, and has   the same limitations as that function, namely that some vector formats do    not have a well defined contiguous range.</p>
<p><a id='PETSc.localranges' href='#PETSc.localranges'>#</a>
<strong><code>PETSc.localranges</code></strong> &mdash; <em>Function</em>.</p>
<p>This function returns two Range object corresponding the global indices   of the rows and columns of the matrix A.</p>
<p>The function has the same limiations as Petsc's MatGetOwnershipRange,    in that it assumes the rows of the matrix are divided up contigously.</p>
<p><a id='PETSc.normalize!' href='#PETSc.normalize!'>#</a>
<strong><code>PETSc.normalize!</code></strong> &mdash; <em>Function</em>.</p>
<p>computes v = norm(x,2), divides x by v, and returns v</p>
<p><a id='PETSc.petscview' href='#PETSc.petscview'>#</a>
<strong><code>PETSc.petscview</code></strong> &mdash; <em>Function</em>.</p>
<p>Print a Petsc matrix to STDOUT</p>
<p>Use the PETSc routine for printing a vector to stdout</p>
<p><a id='PETSc.petscwrite' href='#PETSc.petscwrite'>#</a>
<strong><code>PETSc.petscwrite</code></strong> &mdash; <em>Function</em>.</p>
<p>Print a Petsc matrix to a named file, in text format</p>
<p><a id='PETSc.restore' href='#PETSc.restore'>#</a>
<strong><code>PETSc.restore</code></strong> &mdash; <em>Function</em>.</p>
<p>Tell Petsc the VecLocal is no longer needed</p>
<p><a id='PETSc.rhs_wrapper' href='#PETSc.rhs_wrapper'>#</a>
<strong><code>PETSc.rhs_wrapper</code></strong> &mdash; <em>Function</em>.</p>
<p>Wrapper for the right hand side function.  This function is always passed   to PETSc as the right hand side function, and calls the user supplied   function internally.  The user supplied function must be the first   component of the ctx tuple</p>
<p><a id='PETSc.scatter!' href='#PETSc.scatter!'>#</a>
<strong><code>PETSc.scatter!</code></strong> &mdash; <em>Function</em>.</p>
<p>Convenience method for calling both ghost_begin! and ghost_end!</p>
<p><a id='PETSc.set_local_to_global_mapping' href='#PETSc.set_local_to_global_mapping'>#</a>
<strong><code>PETSc.set_local_to_global_mapping</code></strong> &mdash; <em>Function</em>.</p>
<p>Registers the ISLocalToGlobalMappings with the matrix</p>
<p><a id='PETSc.set_rhs_function' href='#PETSc.set_rhs_function'>#</a>
<strong><code>PETSc.set_rhs_function</code></strong> &mdash; <em>Function</em>.</p>
<p>Sets the function that evalutes u_t = g(u, t) for an ODE.   The function must have the signature:</p>
<p>f(TS, t, U, F, ctx)</p>
<p>where TS is a TS object,   t is the current time   u is the current state vector   F is the vector to be populated with u_t   ctx is the user supplied context tuple (empty tuple if not provided)</p>
<p><a id='PETSc.set_times' href='#PETSc.set_times'>#</a>
<strong><code>PETSc.set_times</code></strong> &mdash; <em>Function</em>.</p>
<p>Set the times related quantities:     t0 : initial time value     dt0: initial time step     nsteps: maximum number of steps     tmax: maximum time value</p>
<p><a id='PETSc.setindex0!' href='#PETSc.setindex0!'>#</a>
<strong><code>PETSc.setindex0!</code></strong> &mdash; <em>Function</em>.</p>
<p>Like setindex, but requires the indices be 0-base</p>
<p><a id='PETSc.setop!' href='#PETSc.setop!'>#</a>
<strong><code>PETSc.setop!</code></strong> &mdash; <em>Function</em>.</p>
<p>Provide a callback function for a particular matrix operation.  op is a    Petsc enum value inidcating the operation, and func is a void pointer    (obtained from cfunction() ) that performs the operation.</p>
<p>The function should take the low level Petsc objects (defined in the C module)   rather than the high level ones defined in this file.  There are constructors   to create a high level object from a low level one</p>
<p><a id='PETSc.setoption!' href='#PETSc.setoption!'>#</a>
<strong><code>PETSc.setoption!</code></strong> &mdash; <em>Function</em>.</p>
<p>Pass values to the Petsc function MatSetOption.  Note that the handful of    options that can be passed here should not be confused with those for the   global options database</p>
<p><a id='PETSc.setpreallocation!' href='#PETSc.setpreallocation!'>#</a>
<strong><code>PETSc.setpreallocation!</code></strong> &mdash; <em>Function</em>.</p>
<p>Preallocates the sparsity pattern for (B)AIJ matrices.</p>
<p><a id='PETSc.sizelocal' href='#PETSc.sizelocal'>#</a>
<strong><code>PETSc.sizelocal</code></strong> &mdash; <em>Function</em>.</p>
<p>Get local size of the vector</p>
<p>Returns the local dimensions of the matrix</p>
<p>Get the local size of the vector</p>
<p><a id='PETSc.solve!' href='#PETSc.solve!'>#</a>
<strong><code>PETSc.solve!</code></strong> &mdash; <em>Function</em>.</p>
<p>Solve the system using the initial condition provided in vec</p>
<p>Solve the system using the intitial condition proived by set_ic</p>
<h1 id="_1">=</h1>
<p>=# #order = [:type, :function]</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/JuliaParallel/PETSc.jl" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>

</body>
</html>

<!--
MkDocs version : 0.15.3
Build Date UTC : 2016-07-01 03:07:46.314315
-->
