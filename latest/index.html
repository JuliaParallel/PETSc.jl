<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Julia Petsc interface documentation">
  <meta name="author" content="JaredCrean2">
  
  <title>PETSc.jl</title>
  

  <link rel="shortcut icon" href="./img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="./css/theme.css" type="text/css" />
  <link rel="stylesheet" href="./css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="./css/highlight.css">
  <link href="./assets/Documenter.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "None";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = "/";
  </script>
  
  <script src="./js/jquery-2.1.1.min.js"></script>
  <script src="./js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="./js/highlight.pack.js"></script>
  <script src="./js/theme.js"></script> 
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML - assets/mathjaxhelper.js"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> PETSc.jl</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href=".">Home</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#_1">=</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">PETSc.jl</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/JuliaParallel/PETSc.jl" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='PETSc.NullVec' href='#PETSc.NullVec'>#</a>
<strong><code>PETSc.NullVec</code></strong> &mdash; <em>Constant</em>.</p>
<p>Null vectors, used in place of void pointers in the C   API</p>
<p><a id='PETSc.mat2vec' href='#PETSc.mat2vec'>#</a>
<strong><code>PETSc.mat2vec</code></strong> &mdash; <em>Constant</em>.</p>
<p>Maps Matrix formats to the corresponding vector format</p>
<p><a id='PETSc.KSP-Tuple{PETSc.PC{T}}' href='#PETSc.KSP-Tuple{PETSc.PC{T}}'>#</a>
<strong><code>PETSc.KSP</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>KSP(A::Mat, PA=A; kws...)
KSP(pc::PC; kws...)
</code></pre>

<p>Create a KSP solver object that can be used to solve equations <code>Ax=b</code> with the matrix <code>A</code>, where <code>PA</code> (defaults to <code>A</code>) is used to construct the default preconditioner.  Alternatively, you can supply a preconditioner object (<code>PC</code>).</p>
<p>The keyword options are zero or more of the following:</p>
<p>These control the solver and preconditioner characteristics: * <code>ksp_type="a"</code>: use KSP algorithm <code>a</code> * <code>ksp_pc_side=n</code>: set preconditioner side to <code>PETSc.C.PC_LEFT</code>, <code>PETSc.C.PC_RIGHT</code>, or <code>PETSc.C.PC_SYMMETRIC</code> * <code>ksp_reuse_preconditioner=true</code>: use initial preconditioner and don't ever compute a new one * <code>ksp_diagonal_scale=true</code>: symmetrically diagonally scale <code>A</code> before solving (note that this <em>changes</em> <code>A</code> and the right-hand side in a solve, unless you also set <code>ksp_diagonal_scale_fix=true</code>) * <code>ksp_diagonal_scale_fix=true</code>: undo diagonal scaling after solve * <code>ksp_knoll=true</code>: use preconditioner applied to <code>b</code> for initial guess * <code>ksp_constant_null_space=true</code>: add constant null space to Krylov solver matrix * <code>ksp_initial_guess_nonzero=true</code>: use the contents of initial <code>x</code> instead of zero for initial guess * <code>ksp_fischer_guess="model,size"</code>: use Fischer initial guess generator (<code>model=1</code> or <code>2</code>) for repeated linear solves with subspace of dimension <code>size</code></p>
<p>The following keyword options control the stopping criteria for iterative solvers: * <code>ksp_rtol=x</code>: <code>x</code> is relative decrease in residual norm * <code>ksp_atol=x</code>: <code>x</code> is absolute decrease in residual norm * <code>ksp_divtol=x</code>: <code>x</code> is amount residual can increase before method is considered to be diverging * <code>ksp_max_it=n</code>: <code>n</code> is the max number of iterations * <code>ksp_converged_use_initial_residual_norm=true</code>: use initial residual norm for computing relative convergence * <code>ksp_converged_use_min_initial_residual_norm=true</code>: use min of initial residual norm and <code>b</code> for computing relative convergence * <code>ksp_error_if_not_converged=true</code>: generate error if solver does not converge * <code>ksp_convergence_test=:default</code> or <code>:skip</code>: use the default convergence test (tolerances and <code>max_it</code>) or skip convergence tests and run until <code>max_it</code> is reached * <code>ksp_norm_type=n</code>: in residual tests, use norm type <code>n</code>, one of default (<code>PETSc.C.KSP_NORM_DEFAULT</code>), none (<code>PETSc.C.KSP_NORM_NONE</code>), of the preconditioned residual (<code>PETSc.C.KSP_NORM_PRECONDITIONED</code>), the true residual (<code>PETSc.C.KSP_NORM_UNPRECONDITIONED</code>), or the "natural" norm (<code>PETSc.C.KSP_NORM_NATURAL</code>) * <code>ksp_check_norm_iteration=n</code>: compute residual norm starting on iteration <code>n</code> * <code>ksp_lag_norm=true</code>: lag the calculation of the residual norm by one iteration (trades off reduced communication for an additional iteration)</p>
<p>The following options control output that monitors the progress of the solver (default none). * <code>ksp_monitor=filename</code>: print the residual norm at each iteration to <code>filename</code> (<code>""</code> for <code>STDOUT</code>) * <code>ksp_monitor_short=filename</code>: print preconditioned residual norm with fewer digits * <code>ksp_monitor_range=filename</code>: prints the percentage of residual elements that are more then 10% of the maximum value * <code>ksp_monitor_true_residual=filename</code>: print true residual norm * <code>ksp_monitor_singular_value=filename</code>: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved) * <code>ksp_monitor_solution=true</code>: plot solution graphically * <code>ksp_monitor_lg_residualnorm=true</code>: plot preconditioned residual norm graphically * <code>ksp_monitor_lg_true_residualnorm=true</code>: plot preconditioned and true residual norm graphically * <code>ksp_monitor_lg_range=true</code>: plot preconditioned residual norm and range of residual values * <code>ksp_monitor_cancel=true</code>: remove any hardwired monitor routines * <code>ksp_compute_singularvalues=true</code>: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved)</p>
<p>In addition, if default preconditioner is being used, then any of the preconditioner options (see <code>PC</code>) can be specified to control this preconditioner (e.g. <code>pc_type</code>).</p>
<p><a id='PETSc.LocalVector' href='#PETSc.LocalVector'>#</a>
<strong><code>PETSc.LocalVector</code></strong> &mdash; <em>Type</em>.</p>
<p>Object representing the local part of the array, accessing the memory directly.   Supports all the same indexing as a regular Array</p>
<p><a id='PETSc.LocalVector-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.LocalVector-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.LocalVector</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the LocalVector of a vector.  Users must call restore when   finished updating the vector</p>
<p><a id='PETSc.Mat' href='#PETSc.Mat'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Type</em>.</p>
<p>Create an empty, unsized matrix</p>
<p><a id='PETSc.Mat' href='#PETSc.Mat'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Type</em>.</p>
<p>Create a matrix of a particular size, optionally specifying the pre-allocation.   If pre-allocation is not specified, no preallocation is done</p>
<p><a id='PETSc.Mat-Tuple{AbstractArray{T,N}}' href='#PETSc.Mat-Tuple{AbstractArray{T,N}}'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Method</em>.</p>
<p>Construct at MATSEQAIJ from an AbstractArray.  The argument droptol is   used to determine what size entry is considered non-zero</p>
<p><a id='PETSc.Mat-Tuple{PETSc.C.Mat{T}}' href='#PETSc.Mat-Tuple{PETSc.C.Mat{T}}'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Method</em>.</p>
<p>Create a high level matrix from an already created matrix pointer</p>
<p><a id='PETSc.Mat-Tuple{SparseMatrixCSC{T,Ti<:Integer}}' href='#PETSc.Mat-Tuple{SparseMatrixCSC{T,Ti<:Integer}}'>#</a>
<strong><code>PETSc.Mat</code></strong> &mdash; <em>Method</em>.</p>
<p>Make a MATSEQ Petsc matrix for a SparseMatrixCSC.  This preserve the    sparsity pattern of the matrix</p>
<p><a id='PETSc.MatRow' href='#PETSc.MatRow'>#</a>
<strong><code>PETSc.MatRow</code></strong> &mdash; <em>Type</em>.</p>
<p>Object that enables access to a single row of a sparse matrix.</p>
<p>Users <em>must</em> call restore when done with a MatRow, before attempting to    create another one.</p>
<p><a id='PETSc.MatRow-Tuple{PETSc.Mat{T,mtype},Integer}' href='#PETSc.MatRow-Tuple{PETSc.Mat{T,mtype},Integer}'>#</a>
<strong><code>PETSc.MatRow</code></strong> &mdash; <em>Method</em>.</p>
<p>Preferred constructor for a MatRow</p>
<p><a id='PETSc.PC-Tuple{Type{T}}' href='#PETSc.PC-Tuple{Type{T}}'>#</a>
<strong><code>PETSc.PC</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>PC(A::Mat, PA=A, kws...)
</code></pre>

<p>Create a preconditioner (PC) context, given the matrix <code>A</code> of the linear system to be solved, and optionally a different matrix <code>PA</code> from which the preconditioner is constructed.</p>
<p>The remaining keywords specify zero or more additional options: * <code>pc_type="a"</code>: use preconditioning algorithm <code>a</code> * <code>pc_use_amat=true</code>: use Amat (instead of Pmat) to define preconditioner in nested inner solves * ... additional options that depend on the preconditioner type ...</p>
<p><a id='PETSc.PetscMat' href='#PETSc.PetscMat'>#</a>
<strong><code>PETSc.PetscMat</code></strong> &mdash; <em>Type</em>.</p>
<p>A Petsc matrix.</p>
<p>Unlike Vecs, the Petsc implementation keeps track of the local assembly    state, so the Julia type does not have to.   <code>verify_assembled</code>: if true, verify all processes are assembled, if false,                       only local process   <code>insertmode</code>: C.InsertMode used by <code>setindex!</code></p>
<p><a id='PETSc.SubMat-Tuple{PETSc.Mat{T,MType},PETSc.IS{T},PETSc.IS{T}}' href='#PETSc.SubMat-Tuple{PETSc.Mat{T,MType},PETSc.IS{T},PETSc.IS{T}}'>#</a>
<strong><code>PETSc.SubMat</code></strong> &mdash; <em>Method</em>.</p>
<p>Gets the a submatrix that references the entries in the original matrix.   isrow and iscol contain the <em>local</em> indicies of the rows and columns to get.   The matrix must have a LocalToGlobalMapping for this to work, therefore a    default one is created if the matrix does not already have one registered.   The default mapping assumes the matrix is divided up into contiguous block   of rows.  This is true of AIJ matrices but may not be for other matrix types.</p>
<p><a id='PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},UInt32,Symbol}' href='#PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},UInt32,Symbol}'>#</a>
<strong><code>PETSc.TS</code></strong> &mdash; <em>Method</em>.</p>
<p>More explicit constructor: set problem type, method directly</p>
<p><code>tsptype</code> sets the problem type and can be one of the following: * <code>TS_LINEAR</code> - a linear set of ODEs  * <code>TS_NONLINEAR</code> - a nonlinear set of ODEs or DEAs</p>
<p><code>tstype</code> sets the method used to solve the problem. More information about the possible methods is available at the official PETSc <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSType.html">docs</a>.</p>
<p><a id='PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},UInt32}' href='#PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},UInt32}'>#</a>
<strong><code>PETSc.TS</code></strong> &mdash; <em>Method</em>.</p>
<p>Preferred constructor: set problem type explicitly, get method from   options database</p>
<p><a id='PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}}}' href='#PETSc.TS-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}}}'>#</a>
<strong><code>PETSc.TS</code></strong> &mdash; <em>Method</em>.</p>
<p>Most preferred constructor: take ProblemType, method from options   database</p>
<p><a id='PETSc.Vec' href='#PETSc.Vec'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Type</em>.</p>
<p>Create an empty, unsized vector.</p>
<p><a id='PETSc.Vec' href='#PETSc.Vec'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Type</em>.</p>
<p>Construct a high level Vec object from a low level C.Vec.   The data field is used to protect things from GC.   A finalizer is attached to deallocate the memory of the underlying C.Vec, unless    <code>first_instance</code> is set to true.   <code>assembled</code> indicates when values are set via <code>setindex!</code> and is reset by    <code>AssemblyEnd</code>    <code>verify_assembled</code> when true, calls to <code>isassembled</code> verify all processes    have <code>assembled</code> = true, when false, only the local assembly state is     checked.  This essentially makes the user responsible for assembling    the vector before passing it into functions that will use it (like KSP   solves, etc.).</p>
<p><a id='PETSc.Vec' href='#PETSc.Vec'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Type</em>.</p>
<p>Create a vector, specifying the (global) length len or the local length   mlocal.  Even if the blocksize is &gt; 1, teh lengths are always number of    elements in the vector, not number of block elements.  Thus   len % blocksize must = 0.</p>
<p><a id='PETSc.Vec' href='#PETSc.Vec'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Type</em>.</p>
<p>Construct a vector suitable for multiplying by the given matrix</p>
<p><a id='PETSc.Vec-Tuple{Array{T<:Union{Complex{Float64},Float32,Float64},1}}' href='#PETSc.Vec-Tuple{Array{T<:Union{Complex{Float64},Float32,Float64},1}}'>#</a>
<strong><code>PETSc.Vec</code></strong> &mdash; <em>Method</em>.</p>
<p>Make a PETSc vector out of an array.  If used in parallel, the array becomes   the local part of the PETSc vector</p>
<p><a id='Base.==-Tuple{PETSc.PetscMat{T,:seqaij},AbstractArray{T,N}}' href='#Base.==-Tuple{PETSc.PetscMat{T,:seqaij},AbstractArray{T,N}}'>#</a>
<strong><code>Base.==</code></strong> &mdash; <em>Method</em>.</p>
<p>Equality test for AbstractArray and PetscMat, SEQ only</p>
<p><a id='Base.SparseMatrix.nnz-Tuple{PETSc.Mat{T,MType}}' href='#Base.SparseMatrix.nnz-Tuple{PETSc.Mat{T,MType}}'>#</a>
<strong><code>Base.SparseMatrix.nnz</code></strong> &mdash; <em>Method</em>.</p>
<p>Number of non-zero entries that have been assigned to</p>
<p><a id='Base.fill!-Tuple{PETSc.PetscMat{T,MType},Number}' href='#Base.fill!-Tuple{PETSc.PetscMat{T,MType},Number}'>#</a>
<strong><code>Base.fill!</code></strong> &mdash; <em>Method</em>.</p>
<p>Fill the matrix with the specified values.</p>
<p>Currently, this function either destroys the sparsity pattern or    gives an error, unless v = 0, in which case it zeros out the non-zero    entries without changing the sparsity pattern</p>
<p><a id='Base.full-Tuple{PETSc.PetscMat{T,MType}}' href='#Base.full-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>Base.full</code></strong> &mdash; <em>Method</em>.</p>
<p>Create a dense Julia matrix for a Petsc sparse matrix.  This only works   for SEQ matrices</p>
<p><a id='Base.length-Tuple{PETSc.Vec{T,VType}}' href='#Base.length-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>Base.length</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the global length of the vector</p>
<p><a id='Base.map!-Tuple{Any,PETSc.Vec{T,VType},PETSc.Vec{T,VType},PETSc.Vec{T2,VType},Vararg{PETSc.Vec{T2,VType}}}' href='#Base.map!-Tuple{Any,PETSc.Vec{T,VType},PETSc.Vec{T,VType},PETSc.Vec{T2,VType},Vararg{PETSc.Vec{T2,VType}}}'>#</a>
<strong><code>Base.map!</code></strong> &mdash; <em>Method</em>.</p>
<p>Multiple source vector map.  All vectors must have the local and global    lengths.  If some a ghost vectors and some are not, the map is applied   only to the local part</p>
<p><a id='Base.map!-Tuple{Any,PETSc.Vec{T,VType},PETSc.Vec{T,VType}}' href='#Base.map!-Tuple{Any,PETSc.Vec{T,VType},PETSc.Vec{T,VType}}'>#</a>
<strong><code>Base.map!</code></strong> &mdash; <em>Method</em>.</p>
<p>Applys f element-wise to src to populate dest.  If src is a ghost vector, then f is applied to the ghost elements as well as the local elements.</p>
<p><a id='Base.size-Tuple{PETSc.PetscMat{T,MType}}' href='#Base.size-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>Base.size</code></strong> &mdash; <em>Method</em>.</p>
<p>Returns the global dimensions of the matrix</p>
<p><a id='Base.size-Tuple{PETSc.Vec{T,VType}}' href='#Base.size-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>Base.size</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the global size of the vector</p>
<p><a id='PETSc.AssemblyBegin' href='#PETSc.AssemblyBegin'>#</a>
<strong><code>PETSc.AssemblyBegin</code></strong> &mdash; <em>Function</em>.</p>
<p>Start communication to assemble stashed values into the vector</p>
<p>The MatAssemblyType is not needed for vectors, but is provided for    compatability with the Mat case.</p>
<p>Unless vec.verify_assembled == false, users must <em>never</em> call the    C functions VecAssemblyBegin, VecAssemblyEnd and VecSetValues, they must   call AssemblyBegin, AssemblyEnd, and setindex!.</p>
<p><a id='PETSc.AssemblyBegin' href='#PETSc.AssemblyBegin'>#</a>
<strong><code>PETSc.AssemblyBegin</code></strong> &mdash; <em>Function</em>.</p>
<p>Generic fallback for AbstractArray, no-op</p>
<p><a id='PETSc.AssemblyBegin' href='#PETSc.AssemblyBegin'>#</a>
<strong><code>PETSc.AssemblyBegin</code></strong> &mdash; <em>Function</em>.</p>
<p>Start assembling the matrix (the implmentations probably post    non-blocking sends and received)</p>
<p><a id='PETSc.AssemblyEnd' href='#PETSc.AssemblyEnd'>#</a>
<strong><code>PETSc.AssemblyEnd</code></strong> &mdash; <em>Function</em>.</p>
<p>Finish communication for assembling the vector</p>
<p><a id='PETSc.AssemblyEnd' href='#PETSc.AssemblyEnd'>#</a>
<strong><code>PETSc.AssemblyEnd</code></strong> &mdash; <em>Function</em>.</p>
<p>Generic fallback for AbstractArray, no-op</p>
<p><a id='PETSc.AssemblyEnd' href='#PETSc.AssemblyEnd'>#</a>
<strong><code>PETSc.AssemblyEnd</code></strong> &mdash; <em>Function</em>.</p>
<p>Finish assembling the matrix</p>
<p><a id='PETSc.LocalVector_readonly-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.LocalVector_readonly-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.LocalVector_readonly</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the LocalVector_readonly of a vector.  Users must call restore when    finished with the object.</p>
<p><a id='PETSc.MatShell' href='#PETSc.MatShell'>#</a>
<strong><code>PETSc.MatShell</code></strong> &mdash; <em>Function</em>.</p>
<p>Create a shell matrix with specified size.  The ctx tuple contains can be   accessed by any callback function.</p>
<p><a id='PETSc.PetscDestroy-Tuple{PETSc.Mat{T,MType}}' href='#PETSc.PetscDestroy-Tuple{PETSc.Mat{T,MType}}'>#</a>
<strong><code>PETSc.PetscDestroy</code></strong> &mdash; <em>Method</em>.</p>
<p>Destroy a Mat object and the underlying data structure, if the object   has not already been finalized</p>
<p><a id='PETSc.PetscDestroy-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.PetscDestroy-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.PetscDestroy</code></strong> &mdash; <em>Method</em>.</p>
<p>The Petsc function to deallocate Vec objects</p>
<p><a id='PETSc.VecGhost-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},Integer,Array{I<:Integer,1}}' href='#PETSc.VecGhost-Tuple{Type{T<:Union{Complex{Float64},Float32,Float64}},Integer,Array{I<:Integer,1}}'>#</a>
<strong><code>PETSc.VecGhost</code></strong> &mdash; <em>Method</em>.</p>
<p>Make a PETSc vector with space for ghost values.  ghost_idx are the    global indices that will be copied into the ghost space.</p>
<p><a id='PETSc.VecLocal-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}' href='#PETSc.VecLocal-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}'>#</a>
<strong><code>PETSc.VecLocal</code></strong> &mdash; <em>Method</em>.</p>
<p>Create a VECSEQ that contains both the local and the ghost values of the    original vector.  The underlying memory for the orignal and output vectors   alias.</p>
<p><a id='PETSc.assemble' href='#PETSc.assemble'>#</a>
<strong><code>PETSc.assemble</code></strong> &mdash; <em>Function</em>.</p>
<p>Assemble the Petsc object</p>
<p><a id='PETSc.assemble' href='#PETSc.assemble'>#</a>
<strong><code>PETSc.assemble</code></strong> &mdash; <em>Function</em>.</p>
<p>This function provides a mechanism for efficiently inserting values into   and then assembling Petsc matrices and vectors.  The function f must be a    zero argument function.</p>
<p>This function can be used with the do block syntax.</p>
<p><a id='PETSc.assemble' href='#PETSc.assemble'>#</a>
<strong><code>PETSc.assemble</code></strong> &mdash; <em>Function</em>.</p>
<p>Low level assemble function</p>
<p><a id='PETSc.comm-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.comm-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.comm</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the communicator for the object</p>
<p><a id='PETSc.comm-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.comm-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.comm</code></strong> &mdash; <em>Method</em>.</p>
<p>Gets the MPI communicator of a vector.</p>
<p><a id='PETSc.count_row_nz-Tuple{PETSc.Mat{T,MType},Integer}' href='#PETSc.count_row_nz-Tuple{PETSc.Mat{T,MType},Integer}'>#</a>
<strong><code>PETSc.count_row_nz</code></strong> &mdash; <em>Method</em>.</p>
<p>Count the number of non-zeros in a row of the matrix.  This temporarily   creates a MatRow object, so it cannot be used if one already exists</p>
<p><a id='PETSc.getcontext-Tuple{PETSc.Mat{T,:shell}}' href='#PETSc.getcontext-Tuple{PETSc.Mat{T,:shell}}'>#</a>
<strong><code>PETSc.getcontext</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the tuple of user provided data passed in when the shell matrix was    created.</p>
<p><a id='PETSc.getinfo' href='#PETSc.getinfo'>#</a>
<strong><code>PETSc.getinfo</code></strong> &mdash; <em>Function</em>.</p>
<p>Get the MatInfo struct for the matrix</p>
<p><a id='PETSc.gettype-Tuple{PETSc.PetscMat{T,MT}}' href='#PETSc.gettype-Tuple{PETSc.PetscMat{T,MT}}'>#</a>
<strong><code>PETSc.gettype</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the format of the matrix.</p>
<p><a id='PETSc.gettype-Tuple{PETSc.Vec{T,VT}}' href='#PETSc.gettype-Tuple{PETSc.Vec{T,VT}}'>#</a>
<strong><code>PETSc.gettype</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the symbol that is the format of the vector</p>
<p><a id='PETSc.ghost_begin!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}' href='#PETSc.ghost_begin!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}'>#</a>
<strong><code>PETSc.ghost_begin!</code></strong> &mdash; <em>Method</em>.</p>
<p>Start communication to update the ghost values (on other processes) from the local   values</p>
<p><a id='PETSc.ghost_end!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}' href='#PETSc.ghost_end!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}'>#</a>
<strong><code>PETSc.ghost_end!</code></strong> &mdash; <em>Method</em>.</p>
<p>Finish communication for updating ghost values</p>
<p><a id='PETSc.ghost_update!-Tuple' href='#PETSc.ghost_update!-Tuple'>#</a>
<strong><code>PETSc.ghost_update!</code></strong> &mdash; <em>Method</em>.</p>
<p>Convenience method for calling ghost_begin! and ghost_end! for multiple vectors</p>
<p><a id='PETSc.has_local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.has_local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.has_local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Check if the local to global mappings have been registered</p>
<p><a id='PETSc.has_local_to_global_mapping-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.has_local_to_global_mapping-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.has_local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Check if the local to global mapping has been registered</p>
<p><a id='PETSc.iassemble-Tuple{Union{PETSc.PetscMat{T,MType},PETSc.Vec{T,VType}}}' href='#PETSc.iassemble-Tuple{Union{PETSc.PetscMat{T,MType},PETSc.Vec{T,VType}}}'>#</a>
<strong><code>PETSc.iassemble</code></strong> &mdash; <em>Method</em>.</p>
<p>Perform a flush assembly (take stashed values and put them into the matrix,   but don't squeeze out any preallocated space that has not been used yet</p>
<p><a id='PETSc.isassembled' href='#PETSc.isassembled'>#</a>
<strong><code>PETSc.isassembled</code></strong> &mdash; <em>Function</em>.</p>
<p>Check if a vector is assembled (ie. does not have stashed values).  If    <code>x.verify_assembled</code>, the assembly state of all processes is checked,    otherwise only the local process is checked. <code>local_only</code> forces only    the local process to be checked, regardless of <code>x.verify_assembled</code>.</p>
<p><a id='PETSc.isassembled-Tuple{PETSc.C.Mat{T}}' href='#PETSc.isassembled-Tuple{PETSc.C.Mat{T}}'>#</a>
<strong><code>PETSc.isassembled</code></strong> &mdash; <em>Method</em>.</p>
<p>Check if the matrix is assembled or not</p>
<p><a id='PETSc.isassembled-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.isassembled-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.isassembled</code></strong> &mdash; <em>Method</em>.</p>
<p>Check if the matrix is assembled.  Whether all processes assembly state    is checked or only the local process is determined by <code>x.verify_assembled</code>.</p>
<p><code>local_only</code> forces only the local process to be checked, regardless of    <code>x.verify_assembled</code>.</p>
<p><a id='PETSc.isfinalized-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.isfinalized-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.isfinalized</code></strong> &mdash; <em>Method</em>.</p>
<p>Check if PetscDestroy has been called on this object already</p>
<p><a id='PETSc.isfinalized-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.isfinalized-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.isfinalized</code></strong> &mdash; <em>Method</em>.</p>
<p>Determine whether a vector has already been finalized</p>
<p><a id='PETSc.lengthlocal-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.lengthlocal-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.lengthlocal</code></strong> &mdash; <em>Method</em>.</p>
<p>prod(sizelocal))</p>
<p><a id='PETSc.lengthlocal-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.lengthlocal-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.lengthlocal</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the length of the local portion of the vector</p>
<p><a id='PETSc.localIS-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.localIS-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.localIS</code></strong> &mdash; <em>Method</em>.</p>
<p>Constructs 2 index sets that map from the local row and columns to the   global rows and columns</p>
<p><a id='PETSc.localIS-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.localIS-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.localIS</code></strong> &mdash; <em>Method</em>.</p>
<p>Constructs index set mapping from local indexing to global indexing, based    on localpart()</p>
<p><a id='PETSc.localIS_block-Tuple{PETSc.Mat{T,MType}}' href='#PETSc.localIS_block-Tuple{PETSc.Mat{T,MType}}'>#</a>
<strong><code>PETSc.localIS_block</code></strong> &mdash; <em>Method</em>.</p>
<p>Like localIS, but returns a block index IS</p>
<p><a id='PETSc.localIS_block-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.localIS_block-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.localIS_block</code></strong> &mdash; <em>Method</em>.</p>
<p>Like localIS, but returns a block index IS</p>
<p><a id='PETSc.local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Construct ISLocalToGlobalMappings for the the rows and columns of the matrix</p>
<p><a id='PETSc.local_to_global_mapping-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.local_to_global_mapping-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Construct ISLocalToGlobalMappings for the vector.  If a block vector,    create a block index set</p>
<p><a id='PETSc.localpart-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.localpart-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.localpart</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the range of global indices that define the local part of the vector.   Internally, this calls the Petsc function VecGetOwnershipRange, and has   the same limitations as that function, namely that some vector formats do    not have a well defined contiguous range.</p>
<p><a id='PETSc.localpart_block-Tuple{PETSc.Mat{T,MType}}' href='#PETSc.localpart_block-Tuple{PETSc.Mat{T,MType}}'>#</a>
<strong><code>PETSc.localpart_block</code></strong> &mdash; <em>Method</em>.</p>
<p>Similar to localpart, but returns the range of block indices</p>
<p><a id='PETSc.localpart_block-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.localpart_block-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.localpart_block</code></strong> &mdash; <em>Method</em>.</p>
<p>Similar to localpart, but returns the range of block indices</p>
<p><a id='PETSc.localranges-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.localranges-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.localranges</code></strong> &mdash; <em>Method</em>.</p>
<p>This function returns two Range object corresponding the global indices   of the rows and columns of the matrix A.</p>
<p>The function has the same limiations as Petsc's MatGetOwnershipRange,    in that it assumes the rows of the matrix are divided up contigously.</p>
<p><a id='PETSc.normalize!-Tuple{Union{PETSc.Vec{Complex{T<:Real},VType},PETSc.Vec{T<:Real,VType}}}' href='#PETSc.normalize!-Tuple{Union{PETSc.Vec{Complex{T<:Real},VType},PETSc.Vec{T<:Real,VType}}}'>#</a>
<strong><code>PETSc.normalize!</code></strong> &mdash; <em>Method</em>.</p>
<p>computes v = norm(x,2), divides x by v, and returns v</p>
<p><a id='PETSc.petscview-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.petscview-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.petscview</code></strong> &mdash; <em>Method</em>.</p>
<p>Print a Petsc matrix to STDOUT</p>
<p><a id='PETSc.petscview-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.petscview-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.petscview</code></strong> &mdash; <em>Method</em>.</p>
<p>Use the PETSc routine for printing a vector to stdout</p>
<p><a id='PETSc.petscwrite-Tuple{PETSc.PetscMat{T,MType},Any}' href='#PETSc.petscwrite-Tuple{PETSc.PetscMat{T,MType},Any}'>#</a>
<strong><code>PETSc.petscwrite</code></strong> &mdash; <em>Method</em>.</p>
<p>Print a Petsc matrix to a named file, in text format</p>
<p><a id='PETSc.restore-Tuple{PETSc.LocalVector{T,false}}' href='#PETSc.restore-Tuple{PETSc.LocalVector{T,false}}'>#</a>
<strong><code>PETSc.restore</code></strong> &mdash; <em>Method</em>.</p>
<p>Tell Petsc the LocalVector is no longer being used</p>
<p><a id='PETSc.restore-Tuple{PETSc.Vec{T,:seq}}' href='#PETSc.restore-Tuple{PETSc.Vec{T,:seq}}'>#</a>
<strong><code>PETSc.restore</code></strong> &mdash; <em>Method</em>.</p>
<p>Tell Petsc the VecLocal is no longer needed</p>
<p><a id='PETSc.rhs_wrapper-Tuple{PETSc.C.TS{T},Any,PETSc.C.Vec{T},PETSc.C.Vec{T},Ptr{Void}}' href='#PETSc.rhs_wrapper-Tuple{PETSc.C.TS{T},Any,PETSc.C.Vec{T},PETSc.C.Vec{T},Ptr{Void}}'>#</a>
<strong><code>PETSc.rhs_wrapper</code></strong> &mdash; <em>Method</em>.</p>
<p>Wrapper for the right hand side function.  This function is always passed   to PETSc as the right hand side function, and calls the user supplied   function internally.  The user supplied function must be the first   component of the ctx tuple</p>
<p><a id='PETSc.scatter!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}' href='#PETSc.scatter!-Tuple{PETSc.Vec{T<:Union{Complex{Float64},Float32,Float64},:mpi}}'>#</a>
<strong><code>PETSc.scatter!</code></strong> &mdash; <em>Method</em>.</p>
<p>Convenience method for calling both ghost_begin! and ghost_end!</p>
<p><a id='PETSc.set_local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType},PETSc.ISLocalToGlobalMapping{T},PETSc.ISLocalToGlobalMapping{T}}' href='#PETSc.set_local_to_global_mapping-Tuple{PETSc.PetscMat{T,MType},PETSc.ISLocalToGlobalMapping{T},PETSc.ISLocalToGlobalMapping{T}}'>#</a>
<strong><code>PETSc.set_local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Registers the ISLocalToGlobalMappings with the matrix</p>
<p><a id='PETSc.set_local_to_global_mapping-Tuple{PETSc.Vec{T,VType},PETSc.ISLocalToGlobalMapping{T}}' href='#PETSc.set_local_to_global_mapping-Tuple{PETSc.Vec{T,VType},PETSc.ISLocalToGlobalMapping{T}}'>#</a>
<strong><code>PETSc.set_local_to_global_mapping</code></strong> &mdash; <em>Method</em>.</p>
<p>Registers the ISLocalToGlobalMapping with the Vec</p>
<p><a id='PETSc.set_rhs_function' href='#PETSc.set_rhs_function'>#</a>
<strong><code>PETSc.set_rhs_function</code></strong> &mdash; <em>Function</em>.</p>
<p>Sets the function that evalutes u_t = g(u, t) for an ODE.   The function must have the signature:</p>
<p>f(TS, t, U, F, ctx)</p>
<p>where TS is a TS object,   t is the current time   u is the current state vector   F is the vector to be populated with u_t   ctx is the user supplied context tuple (empty tuple if not provided)</p>
<p><a id='PETSc.set_times-Tuple{PETSc.TS{T<:Union{Complex{Float64},Float32,Float64}},Any,Any,Integer,Any}' href='#PETSc.set_times-Tuple{PETSc.TS{T<:Union{Complex{Float64},Float32,Float64}},Any,Any,Integer,Any}'>#</a>
<strong><code>PETSc.set_times</code></strong> &mdash; <em>Method</em>.</p>
<p>Set the times related quantities:     t0 : initial time value     dt0: initial time step     nsteps: maximum number of steps     tmax: maximum time value</p>
<p><a id='PETSc.setindex0!-Tuple{PETSc.Vec{T,VType},Array{T,N},Array{Int64,N}}' href='#PETSc.setindex0!-Tuple{PETSc.Vec{T,VType},Array{T,N},Array{Int64,N}}'>#</a>
<strong><code>PETSc.setindex0!</code></strong> &mdash; <em>Method</em>.</p>
<p>Like setindex, but requires the indices be 0-base</p>
<p><a id='PETSc.setop!-Tuple{PETSc.Mat{T,:shell},UInt32,Ptr{Void}}' href='#PETSc.setop!-Tuple{PETSc.Mat{T,:shell},UInt32,Ptr{Void}}'>#</a>
<strong><code>PETSc.setop!</code></strong> &mdash; <em>Method</em>.</p>
<p>Provide a callback function for a particular matrix operation.  op is a    Petsc enum value inidcating the operation, and func is a void pointer    (obtained from cfunction() ) that performs the operation.</p>
<p>The function should take the low level Petsc objects (defined in the C module)   rather than the high level ones defined in this file.  There are constructors   to create a high level object from a low level one</p>
<p><a id='PETSc.setoption!-Tuple{PETSc.Mat{T,MType},Int32,Bool}' href='#PETSc.setoption!-Tuple{PETSc.Mat{T,MType},Int32,Bool}'>#</a>
<strong><code>PETSc.setoption!</code></strong> &mdash; <em>Method</em>.</p>
<p>Pass values to the Petsc function MatSetOption.  Note that the handful of    options that can be passed here should not be confused with those for the   global options database</p>
<p><a id='PETSc.setpreallocation!-Tuple{PETSc.Mat{T,MType}}' href='#PETSc.setpreallocation!-Tuple{PETSc.Mat{T,MType}}'>#</a>
<strong><code>PETSc.setpreallocation!</code></strong> &mdash; <em>Method</em>.</p>
<p>Preallocates the sparsity pattern for (B)AIJ matrices.</p>
<p><a id='PETSc.sizelocal-Tuple{AbstractArray{T,n},Any}' href='#PETSc.sizelocal-Tuple{AbstractArray{T,n},Any}'>#</a>
<strong><code>PETSc.sizelocal</code></strong> &mdash; <em>Method</em>.</p>
<p>Get local size of the vector</p>
<p><a id='PETSc.sizelocal-Tuple{PETSc.PetscMat{T,MType}}' href='#PETSc.sizelocal-Tuple{PETSc.PetscMat{T,MType}}'>#</a>
<strong><code>PETSc.sizelocal</code></strong> &mdash; <em>Method</em>.</p>
<p>Returns the local dimensions of the matrix</p>
<p><a id='PETSc.sizelocal-Tuple{PETSc.Vec{T,VType}}' href='#PETSc.sizelocal-Tuple{PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.sizelocal</code></strong> &mdash; <em>Method</em>.</p>
<p>Get the local size of the vector</p>
<p><a id='PETSc.solve!-Tuple{PETSc.TS{T},PETSc.Vec{T,VType}}' href='#PETSc.solve!-Tuple{PETSc.TS{T},PETSc.Vec{T,VType}}'>#</a>
<strong><code>PETSc.solve!</code></strong> &mdash; <em>Method</em>.</p>
<p>Solve the system using the initial condition provided in vec</p>
<p><a id='PETSc.solve!-Tuple{PETSc.TS{T}}' href='#PETSc.solve!-Tuple{PETSc.TS{T}}'>#</a>
<strong><code>PETSc.solve!</code></strong> &mdash; <em>Method</em>.</p>
<p>Solve the system using the intitial condition proived by set_ic</p>
<h1 id="_1">=</h1>
<p>=# #order = [:type, :function]</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/JuliaParallel/PETSc.jl" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>

</body>
</html>

<!--
MkDocs version : 0.15.3
Build Date UTC : 2016-07-09 18:51:25.942461
-->
