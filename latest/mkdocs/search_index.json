{
    "docs": [
        {
            "location": "/", 
            "text": "#\n\n\nPETSc.NullVec\n \n \nConstant\n.\n\n\nNull vectors, used in place of void pointers in the C   API\n\n\n#\n\n\nPETSc.mat2vec\n \n \nConstant\n.\n\n\nMaps Matrix formats to the corresponding vector format\n\n\n#\n\n\nPETSc.KSP\n \n \nType\n.\n\n\nKSP(A::Mat, PA=A; kws...)\nKSP(pc::PC; kws...)\n\n\n\n\nCreate a KSP solver object that can be used to solve equations \nAx=b\n with the matrix \nA\n, where \nPA\n (defaults to \nA\n) is used to construct the default preconditioner.  Alternatively, you can supply a preconditioner object (\nPC\n).\n\n\nThe keyword options are zero or more of the following:\n\n\nThese control the solver and preconditioner characteristics: * \nksp_type=\"a\"\n: use KSP algorithm \na\n * \nksp_pc_side=n\n: set preconditioner side to \nPETSc.C.PC_LEFT\n, \nPETSc.C.PC_RIGHT\n, or \nPETSc.C.PC_SYMMETRIC\n * \nksp_reuse_preconditioner=true\n: use initial preconditioner and don't ever compute a new one * \nksp_diagonal_scale=true\n: symmetrically diagonally scale \nA\n before solving (note that this \nchanges\n \nA\n and the right-hand side in a solve, unless you also set \nksp_diagonal_scale_fix=true\n) * \nksp_diagonal_scale_fix=true\n: undo diagonal scaling after solve * \nksp_knoll=true\n: use preconditioner applied to \nb\n for initial guess * \nksp_constant_null_space=true\n: add constant null space to Krylov solver matrix * \nksp_initial_guess_nonzero=true\n: use the contents of initial \nx\n instead of zero for initial guess * \nksp_fischer_guess=\"model,size\"\n: use Fischer initial guess generator (\nmodel=1\n or \n2\n) for repeated linear solves with subspace of dimension \nsize\n\n\nThe following keyword options control the stopping criteria for iterative solvers: * \nksp_rtol=x\n: \nx\n is relative decrease in residual norm * \nksp_atol=x\n: \nx\n is absolute decrease in residual norm * \nksp_divtol=x\n: \nx\n is amount residual can increase before method is considered to be diverging * \nksp_max_it=n\n: \nn\n is the max number of iterations * \nksp_converged_use_initial_residual_norm=true\n: use initial residual norm for computing relative convergence * \nksp_converged_use_min_initial_residual_norm=true\n: use min of initial residual norm and \nb\n for computing relative convergence * \nksp_error_if_not_converged=true\n: generate error if solver does not converge * \nksp_convergence_test=:default\n or \n:skip\n: use the default convergence test (tolerances and \nmax_it\n) or skip convergence tests and run until \nmax_it\n is reached * \nksp_norm_type=n\n: in residual tests, use norm type \nn\n, one of default (\nPETSc.C.KSP_NORM_DEFAULT\n), none (\nPETSc.C.KSP_NORM_NONE\n), of the preconditioned residual (\nPETSc.C.KSP_NORM_PRECONDITIONED\n), the true residual (\nPETSc.C.KSP_NORM_UNPRECONDITIONED\n), or the \"natural\" norm (\nPETSc.C.KSP_NORM_NATURAL\n) * \nksp_check_norm_iteration=n\n: compute residual norm starting on iteration \nn\n * \nksp_lag_norm=true\n: lag the calculation of the residual norm by one iteration (trades off reduced communication for an additional iteration)\n\n\nThe following options control output that monitors the progress of the solver (default none). * \nksp_monitor=filename\n: print the residual norm at each iteration to \nfilename\n (\n\"\"\n for \nSTDOUT\n) * \nksp_monitor_short=filename\n: print preconditioned residual norm with fewer digits * \nksp_monitor_range=filename\n: prints the percentage of residual elements that are more then 10% of the maximum value * \nksp_monitor_true_residual=filename\n: print true residual norm * \nksp_monitor_singular_value=filename\n: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved) * \nksp_monitor_solution=true\n: plot solution graphically * \nksp_monitor_lg_residualnorm=true\n: plot preconditioned residual norm graphically * \nksp_monitor_lg_true_residualnorm=true\n: plot preconditioned and true residual norm graphically * \nksp_monitor_lg_range=true\n: plot preconditioned residual norm and range of residual values * \nksp_monitor_cancel=true\n: remove any hardwired monitor routines * \nksp_compute_singularvalues=true\n: print extreme singular values (via Lanczos or Arnoldi process as the linear system is solved)\n\n\nIn addition, if default preconditioner is being used, then any of the preconditioner options (see \nPC\n) can be specified to control this preconditioner (e.g. \npc_type\n).\n\n\n#\n\n\nPETSc.LocalVector\n \n \nType\n.\n\n\nObject representing the local part of the array, accessing the memory directly.   Supports all the same indexing as a regular Array\n\n\n#\n\n\nPETSc.Mat\n \n \nType\n.\n\n\nCreate a high level matrix from an already created matrix pointer\n\n\nCreate a matrix of a particular size, optionally specifying the pre-allocation.   If pre-allocation is not specified, no preallocation is done\n\n\nCreate an empty, unsized matrix\n\n\n#\n\n\nPETSc.PC\n \n \nType\n.\n\n\nPC(A::Mat, PA=A, kws...)\n\n\n\n\nCreate a preconditioner (PC) context, given the matrix \nA\n of the linear system to be solved, and optionally a different matrix \nPA\n from which the preconditioner is constructed.\n\n\nThe remaining keywords specify zero or more additional options: * \npc_type=\"a\"\n: use preconditioning algorithm \na\n * \npc_use_amat=true\n: use Amat (instead of Pmat) to define preconditioner in nested inner solves * ... additional options that depend on the preconditioner type ...\n\n\n#\n\n\nPETSc.PetscMat\n \n \nType\n.\n\n\nA Petsc matrix.\n\n\nUnlike Vecs, the Petsc implementation keeps track of the local assembly    state, so the Julia type does not have to.   \nverify_assembled\n: if true, verify all processes are assembled, if false,                       only local process   \ninsertmode\n: C.InsertMode used by \nsetindex!\n\n\n#\n\n\nPETSc.SubMat\n \n \nType\n.\n\n\nGets the a submatrix that references the entries in the original matrix.   isrow and iscol contain the \nlocal\n indicies of the rows and columns to get.   The matrix must have a LocalToGlobalMapping for this to work, therefore a    default one is created if the matrix does not already have one registered.   The default mapping assumes the matrix is divided up into contiguous block   of rows.  This is true of AIJ matrices but may not be for other matrix types.\n\n\n#\n\n\nPETSc.TS\n \n \nType\n.\n\n\nMore explicit constructor: set problem type, method directly\n\n\ntsptype\n sets the problem type and can be one of the following: * \nTS_LINEAR\n - a linear set of ODEs  * \nTS_NONLINEAR\n - a nonlinear set of ODEs or DEAs\n\n\ntstype\n sets the method used to solve the problem. More information about the possible methods is available at the official PETSc \ndocs\n.\n\n\nPreferred constructor: set problem type explicitly, get method from   options database\n\n\nMost preferred constructor: take ProblemType, method from options   database\n\n\n#\n\n\nPETSc.Vec\n \n \nType\n.\n\n\nConstruct a high level Vec object from a low level C.Vec.   The data field is used to protect things from GC.   A finalizer is attached to deallocate the memory of the underlying C.Vec, unless    \nfirst_instance\n is set to true.   \nassembled\n indicates when values are set via \nsetindex!\n and is reset by    \nAssemblyEnd\n    \nverify_assembled\n when true, calls to \nisassembled\n verify all processes    have \nassembled\n = true, when false, only the local assembly state is     checked.  This essentially makes the user responsible for assembling    the vector before passing it into functions that will use it (like KSP   solves, etc.).\n\n\n#\n\n\nBase.SparseMatrix.nnz\n \n \nFunction\n.\n\n\nNumber of non-zero entries that have been assigned to\n\n\n#\n\n\nBase.fill!\n \n \nFunction\n.\n\n\nFill the matrix with the specified values.\n\n\nCurrently, this function either destroys the sparsity pattern or    gives an error, unless v = 0, in which case it zeros out the non-zero    entries without changing the sparsity pattern\n\n\n#\n\n\nBase.full\n \n \nFunction\n.\n\n\nCreate a dense Julia matrix for a Petsc sparse matrix.  This only works   for SEQ matrices\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\nGet the global length of the vector\n\n\n#\n\n\nBase.map!\n \n \nFunction\n.\n\n\nMultiple source vector map.  All vectors must have the local and global    lengths.  If some a ghost vectors and some are not, the map is applied   only to the local part\n\n\nApplys f element-wise to src to populate dest.  If src is a ghost vector, then f is applied to the ghost elements as well as the local elements.\n\n\n#\n\n\nBase.size\n \n \nFunction\n.\n\n\nReturns the global dimensions of the matrix\n\n\nGet the global size of the vector\n\n\n#\n\n\nPETSc.AssemblyBegin\n \n \nFunction\n.\n\n\nGeneric fallback for AbstractArray, no-op\n\n\nStart assembling the matrix (the implmentations probably post    non-blocking sends and received)\n\n\nStart communication to assemble stashed values into the vector\n\n\nThe MatAssemblyType is not needed for vectors, but is provided for    compatability with the Mat case.\n\n\nUnless vec.verify_assembled == false, users must \nnever\n call the    C functions VecAssemblyBegin, VecAssemblyEnd and VecSetValues, they must   call AssemblyBegin, AssemblyEnd, and setindex!.\n\n\n#\n\n\nPETSc.AssemblyEnd\n \n \nFunction\n.\n\n\nGeneric fallback for AbstractArray, no-op\n\n\nFinish assembling the matrix\n\n\nFinish communication for assembling the vector\n\n\n#\n\n\nPETSc.LocalVector_readonly\n \n \nFunction\n.\n\n\nGet the LocalVector_readonly of a vector.  Users must call restore when    finished with the object.\n\n\n#\n\n\nPETSc.MatShell\n \n \nFunction\n.\n\n\nCreate a shell matrix with specified size.  The ctx tuple contains can be   accessed by any callback function.\n\n\n#\n\n\nPETSc.PetscDestroy\n \n \nFunction\n.\n\n\nDestroy a Mat object and the underlying data structure, if the object   has not already been finalized\n\n\nThe Petsc function to deallocate Vec objects\n\n\n#\n\n\nPETSc.VecGhost\n \n \nFunction\n.\n\n\nMake a PETSc vector with space for ghost values.  ghost_idx are the    global indices that will be copied into the ghost space.\n\n\n#\n\n\nPETSc.VecLocal\n \n \nFunction\n.\n\n\nCreate a VECSEQ that contains both the local and the ghost values of the    original vector.  The underlying memory for the orignal and output vectors   alias.\n\n\n#\n\n\nPETSc.assemble\n \n \nFunction\n.\n\n\nLow level assemble function\n\n\nAssemble the Petsc object\n\n\nThis function provides a mechanism for efficiently inserting values into   and then assembling Petsc matrices and vectors.  The function f must be a    zero argument function.\n\n\nThis function can be used with the do block syntax.\n\n\n#\n\n\nPETSc.comm\n \n \nFunction\n.\n\n\nGet the communicator for the object\n\n\nGets the MPI communicator of a vector.\n\n\n#\n\n\nPETSc.getcontext\n \n \nFunction\n.\n\n\nGet the tuple of user provided data passed in when the shell matrix was    created.\n\n\n#\n\n\nPETSc.getinfo\n \n \nFunction\n.\n\n\nGet the MatInfo struct for the matrix\n\n\n#\n\n\nPETSc.gettype\n \n \nFunction\n.\n\n\nGet the format of the matrix.\n\n\nGet the symbol that is the format of the vector\n\n\n#\n\n\nPETSc.ghost_begin!\n \n \nFunction\n.\n\n\nStart communication to update the ghost values (on other processes) from the local   values\n\n\n#\n\n\nPETSc.ghost_end!\n \n \nFunction\n.\n\n\nFinish communication for updating ghost values\n\n\n#\n\n\nPETSc.ghost_update!\n \n \nFunction\n.\n\n\nConvenience method for calling ghost_begin! and ghost_end! for multiple vectors\n\n\n#\n\n\nPETSc.has_local_to_global_mapping\n \n \nFunction\n.\n\n\nCheck if the local to global mappings have been registered\n\n\nCheck if the local to global mapping has been registered\n\n\n#\n\n\nPETSc.iassemble\n \n \nFunction\n.\n\n\nPerform a flush assembly (take stashed values and put them into the matrix,   but don't squeeze out any preallocated space that has not been used yet\n\n\n#\n\n\nPETSc.isassembled\n \n \nFunction\n.\n\n\nCheck if the matrix is assembled.  Whether all processes assembly state    is checked or only the local process is determined by \nx.verify_assembled\n.\n\n\nlocal_only\n forces only the local process to be checked, regardless of    \nx.verify_assembled\n.\n\n\nCheck if the matrix is assembled or not\n\n\nCheck if a vector is assembled (ie. does not have stashed values).  If    \nx.verify_assembled\n, the assembly state of all processes is checked,    otherwise only the local process is checked. \nlocal_only\n forces only    the local process to be checked, regardless of \nx.verify_assembled\n.\n\n\n#\n\n\nPETSc.isfinalized\n \n \nFunction\n.\n\n\nCheck if PetscDestroy has been called on this object already\n\n\nDetermine whether a vector has already been finalized\n\n\n#\n\n\nPETSc.lengthlocal\n \n \nFunction\n.\n\n\nprod(sizelocal))\n\n\nGet the length of the local portion of the vector\n\n\n#\n\n\nPETSc.localIS\n \n \nFunction\n.\n\n\nConstructs 2 index sets that map from the local row and columns to the   global rows and columns\n\n\nConstructs index set mapping from local indexing to global indexing, based    on localpart()\n\n\n#\n\n\nPETSc.localIS_block\n \n \nFunction\n.\n\n\nLike localIS, but returns a block index IS\n\n\nLike localIS, but returns a block index IS\n\n\n#\n\n\nPETSc.local_to_global_mapping\n \n \nFunction\n.\n\n\nConstruct ISLocalToGlobalMappings for the the rows and columns of the matrix\n\n\nConstruct ISLocalToGlobalMappings for the vector.  If a block vector,    create a block index set\n\n\n#\n\n\nPETSc.localpart\n \n \nFunction\n.\n\n\nGet the range of global indices that define the local part of the vector.   Internally, this calls the Petsc function VecGetOwnershipRange, and has   the same limitations as that function, namely that some vector formats do    not have a well defined contiguous range.\n\n\n#\n\n\nPETSc.localpart_block\n \n \nFunction\n.\n\n\nSimilar to localpart, but returns the range of block indices\n\n\nSimilar to localpart, but returns the range of block indices\n\n\n#\n\n\nPETSc.localranges\n \n \nFunction\n.\n\n\nThis function returns two Range object corresponding the global indices   of the rows and columns of the matrix A.\n\n\nThe function has the same limiations as Petsc's MatGetOwnershipRange,    in that it assumes the rows of the matrix are divided up contigously.\n\n\n#\n\n\nPETSc.normalize!\n \n \nFunction\n.\n\n\ncomputes v = norm(x,2), divides x by v, and returns v\n\n\n#\n\n\nPETSc.petscview\n \n \nFunction\n.\n\n\nPrint a Petsc matrix to STDOUT\n\n\nUse the PETSc routine for printing a vector to stdout\n\n\n#\n\n\nPETSc.petscwrite\n \n \nFunction\n.\n\n\nPrint a Petsc matrix to a named file, in text format\n\n\n#\n\n\nPETSc.restore\n \n \nFunction\n.\n\n\nTell Petsc the LocalVector is no longer being used\n\n\nTell Petsc the VecLocal is no longer needed\n\n\n#\n\n\nPETSc.rhs_wrapper\n \n \nFunction\n.\n\n\nWrapper for the right hand side function.  This function is always passed   to PETSc as the right hand side function, and calls the user supplied   function internally.  The user supplied function must be the first   component of the ctx tuple\n\n\n#\n\n\nPETSc.scatter!\n \n \nFunction\n.\n\n\nConvenience method for calling both ghost_begin! and ghost_end!\n\n\n#\n\n\nPETSc.set_local_to_global_mapping\n \n \nFunction\n.\n\n\nRegisters the ISLocalToGlobalMappings with the matrix\n\n\nRegisters the ISLocalToGlobalMapping with the Vec\n\n\n#\n\n\nPETSc.set_rhs_function\n \n \nFunction\n.\n\n\nSets the function that evalutes u_t = g(u, t) for an ODE.   The function must have the signature:\n\n\nf(TS, t, U, F, ctx)\n\n\nwhere TS is a TS object,   t is the current time   u is the current state vector   F is the vector to be populated with u_t   ctx is the user supplied context tuple (empty tuple if not provided)\n\n\n#\n\n\nPETSc.set_times\n \n \nFunction\n.\n\n\nSet the times related quantities:     t0 : initial time value     dt0: initial time step     nsteps: maximum number of steps     tmax: maximum time value\n\n\n#\n\n\nPETSc.setindex0!\n \n \nFunction\n.\n\n\nLike setindex, but requires the indices be 0-base\n\n\n#\n\n\nPETSc.setop!\n \n \nFunction\n.\n\n\nProvide a callback function for a particular matrix operation.  op is a    Petsc enum value inidcating the operation, and func is a void pointer    (obtained from cfunction() ) that performs the operation.\n\n\nThe function should take the low level Petsc objects (defined in the C module)   rather than the high level ones defined in this file.  There are constructors   to create a high level object from a low level one\n\n\n#\n\n\nPETSc.setoption!\n \n \nFunction\n.\n\n\nPass values to the Petsc function MatSetOption.  Note that the handful of    options that can be passed here should not be confused with those for the   global options database\n\n\n#\n\n\nPETSc.setpreallocation!\n \n \nFunction\n.\n\n\nPreallocates the sparsity pattern for (B)AIJ matrices.\n\n\n#\n\n\nPETSc.sizelocal\n \n \nFunction\n.\n\n\nGet local size of the vector\n\n\nReturns the local dimensions of the matrix\n\n\nGet the local size of the vector\n\n\n#\n\n\nPETSc.solve!\n \n \nFunction\n.\n\n\nSolve the system using the initial condition provided in vec\n\n\nSolve the system using the intitial condition proived by set_ic\n\n\n=\n\n\n=# #order = [:type, :function]", 
            "title": "Home"
        }, 
        {
            "location": "/#_1", 
            "text": "=# #order = [:type, :function]", 
            "title": "="
        }
    ]
}