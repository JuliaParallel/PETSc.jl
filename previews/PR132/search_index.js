var documenterSearchIndex = {"docs":
[{"location":"man/vec/#Vec","page":"Vec","title":"Vec","text":"","category":"section"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"The following Vec routines are available:","category":"page"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"Modules = [PETSc]\nPages   = [\"vec.jl\"]","category":"page"},{"location":"man/mat/#Mat","page":"Mat","title":"Mat","text":"","category":"section"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"The following Mat routines are available:","category":"page"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"Modules = [PETSc]\nPages   = [\"mat.jl\"]","category":"page"},{"location":"man/snes/#SNES","page":"SNES","title":"SNES","text":"","category":"section"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"The following SNES routines are available:","category":"page"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"Modules = [PETSc]\nPages   = [\"snes.jl\"]","category":"page"},{"location":"man/ksp/#KSP","page":"KSP","title":"KSP","text":"","category":"section"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"The following KSP routines are available:","category":"page"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"Modules = [PETSc]\nPages   = [\"ksp.jl\"]","category":"page"},{"location":"man/ksp/#PETSc.KSP-Union{Tuple{PETSc.AbstractMat{T}}, Tuple{T}, Tuple{PETSc.AbstractMat{T}, PETSc.AbstractMat{T}}} where T","page":"KSP","title":"PETSc.KSP","text":"KSP(A, P; options...)\n\nConstruct a PETSc Krylov subspace solver.\n\nAny PETSc options prefixed with ksp_ and pc_ can be passed as keywords.\n\n\n\n\n\n","category":"method"},{"location":"man/ksp/#PETSc.iters","page":"KSP","title":"PETSc.iters","text":"iters(ksp::KSP)\n\nGets the current iteration number; if the solve! is complete, returns the number of iterations used.\n\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPGetIterationNumber.html\n\n\n\n\n\n","category":"function"},{"location":"man/ksp/#PETSc.resnorm","page":"KSP","title":"PETSc.resnorm","text":"resnorm(ksp::KSP)\n\nGets the last (approximate preconditioned) residual norm that has been computed.\n\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPGetResidualNorm.html\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Getting started\n1a. Installation using pre-build libraries\n1b. Installation using pre-build libraries\n2. Solving a linear system of equations\n3. Nonlinear example","category":"page"},{"location":"man/getting_started/#a.-Installation-using-pre-build-libraries","page":"Getting Started","title":"1a. Installation using pre-build libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The easiest way to install the package is: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add https://github.com/JuliaParallel/PETSc.jl","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install a pre-build PETSc library (PETSc_jll) as well as MPI.jl on your system. This will work both in serial and in parallel on your machine.","category":"page"},{"location":"man/getting_started/#b.-Installation-using-pre-build-libraries","page":"Getting Started","title":"1b. Installation using pre-build libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"On many high-performance clusters, you will have to use the provided MPI installation for that cluster and the default download above will not be sufficient. Alternatively, you may be interested in a PETSc installation that comes with additional external packages. Ensure that this PETSc installation is compiled as a dynamic (and not a static) library, after which you need to set the environmental variable JULIA_PETSC_LIBRARY to link to your PETSc installation: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"$export JULIA_PETSC_LIBRARY = /path/to/your/petsc/installation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now rebuild the package:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> build PETSc","category":"page"},{"location":"man/getting_started/#.-Solving-a-linear-system-of-equations","page":"Getting Started","title":"2. Solving a linear system of equations","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Lets consider the following elliptic equation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\npartial^2 T over partial x^2  = 0 T(0) = 1 T(1) = 11\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc\njulia> n   =  11\njulia> Δx  =  1. / (n - 1)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's first define the matrix with coefficients:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> nnz =  ones(Int32,n); nnz[2:n-1] .= 3;\njulia> A   =  PETSc.MatSeqAIJ{Float64}(n,n,nnz);\njulia> for i=2:n-1\n            A[i,i-1] =  1/Δx^2\n            A[i,i  ] = -2/Δx^2\n            A[i,i+1] =  1/Δx^2\n       end\n       A[1,1]=1; A[n,n]=1;\njulia> PETSc.assemble(A)\njulia> A\nMat Object: 1 MPI processes\n  type: seqaij\nrow 0: (0, 1.) \nrow 1: (0, 100.)  (1, -200.)  (2, 100.) \nrow 2: (1, 100.)  (2, -200.)  (3, 100.) \nrow 3: (2, 100.)  (3, -200.)  (4, 100.) \nrow 4: (3, 100.)  (4, -200.)  (5, 100.) \nrow 5: (4, 100.)  (5, -200.)  (6, 100.) \nrow 6: (5, 100.)  (6, -200.)  (7, 100.) \nrow 7: (6, 100.)  (7, -200.)  (8, 100.) \nrow 8: (7, 100.)  (8, -200.)  (9, 100.) \nrow 9: (8, 100.)  (9, -200.)  (10, 100.) \nrow 10: (10, 1.) ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, lets define the right-hand-size vector rhs as a julia vector:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> rhs = zeros(n); rhs[1]=1; rhs[11]=11;","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, we define the linear solver for the matrix A, which is done by setting a KSP solver: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ksp = PETSc.KSP(A; ksp_rtol=1e-8, pc_type=\"jacobi\", ksp_monitor=true)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that you can specify all PETSc command-line options as keywords here.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Solving the system of equations is simple:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> sol = ksp\\rhs\n  0 KSP Residual norm 1.104536101719e+01 \n  1 KSP Residual norm 4.939635614091e+00 \n  2 KSP Residual norm 2.410295378065e+00 \n  3 KSP Residual norm 1.462993806273e+00 \n  4 KSP Residual norm 1.004123728835e+00 \n  5 KSP Residual norm 7.700861485629e-01 \n  6 KSP Residual norm 6.165623662013e-01 \n  7 KSP Residual norm 4.972507567923e-01 \n  8 KSP Residual norm 4.074986825669e-01 \n  9 KSP Residual norm 3.398492183940e-01 \n 10 KSP Residual norm 3.283015493450e-15 \n11-element Vector{Float64}:\n  1.0\n  2.000000000000001\n  3.0000000000000013\n  4.000000000000001\n  5.000000000000002\n  6.0\n  7.0000000000000036\n  8.000000000000002\n  9.000000000000004\n 10.000000000000002\n 11.0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"And since we are using julia, plotting the solution can be done with","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Plots\njulia> plot(0:Δx:1,sol, ylabel=\"solution\",xlabel=\"x\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: linear_solution)","category":"page"},{"location":"man/getting_started/#.-Nonlinear-example","page":"Getting Started","title":"3. Nonlinear example","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's solve the coupled system of nonlinear equations: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\nx^2 + x y  = 3 \nx y + y^2  = 6\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"for x and y, which can be written in terms of a residual vector f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"f = binom x^2 + x y  - 3 x y + y^2  - 6","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this, we need to provide a residual function that computes f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function F!(fx, x)\n         fx[1] = x[1]^2 + x[1]*x[2] - 3\n         fx[2] = x[1]*x[2] + x[2]^2 - 6\n       end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In addition, we need to provide the Jacobian:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"J = \nbeginpmatrix\nfracpartial f_1 partial x  fracpartial f_1 partial y  \nfracpartial f_2 partial x  fracpartial f_2 partial y  \nendpmatrix\n= \nbeginpmatrix\n2x + y  x  \ny  x + 2y  \nendpmatrix","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In Julia, this is:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function updateJ!(x, args...)\n            J[1,1] = 2x[1] + x[2]\n            J[1,2] = x[1]\n            J[2,1] = x[2]\n            J[2,2] = x[1] + 2x[2]\n        end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this using the PETSc nonlinear equation solvers, you first define the SNES solver together with the jacobian and residual functions as ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc, MPI\njulia> S = PETSc.SNES{Float64}(MPI.COMM_SELF; ksp_rtol=1e-4, pc_type=\"none\")\njulia> PETSc.setfunction!(S, F!, PETSc.VecSeq(zeros(2)))\njulia> J = zeros(2,2)\njulia> PJ = PETSc.MatSeqDense(J)\njulia> PETSc.setjacobian!(S, updateJ!, PJ, PJ)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can solve this as:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PETSc.solve!([2.0,3.0], S)\n2-element Vector{Float64}:\n 1.000000003259629\n 1.999999998137355","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which indeed recovers the analytical solution (x=1 y=2).","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here a summary of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"CurrentModule = PETSc","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]","category":"page"},{"location":"man/listfunctions/#PETSc.AbstractOptions","page":"List of functions","title":"PETSc.AbstractOptions","text":"AbstractOptions{PetscLib <: PetscLibType}\n\nAbstract type of PETSc solver options.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.AbstractViewer","page":"List of functions","title":"PETSc.AbstractViewer","text":"AbstractViewer{PetscLib <: PetscLibType}\n\nAbstract type of PETSc viewer.\n\nManual: PetscViewer\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.GlobalOptions","page":"List of functions","title":"PETSc.GlobalOptions","text":"GlobalOptions{PetscLib <: PetscLibType}\n\nThe PETSc global options database.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqAIJ","page":"List of functions","title":"PETSc.MatSeqAIJ","text":"MatSeqAIJ{T}\n\nPETSc sparse array using AIJ format (also known as a compressed sparse row or CSR format).\n\nMemory allocation is handled by PETSc.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqDense","page":"List of functions","title":"PETSc.MatSeqDense","text":"MatSeqDense{T}\n\nPETSc dense array. This wraps a Julia Matrix{T} object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatShell","page":"List of functions","title":"PETSc.MatShell","text":"MatShell{T}(obj, m, n)\n\nCreate a m×n PETSc shell matrix object wrapping obj.\n\nIf obj is a Function, then the multiply action obj(y,x); otherwise it calls mul!(y, obj, x). This can be changed by defining PETSc._mul!.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.Options","page":"List of functions","title":"PETSc.Options","text":"Options{PetscLib <: PetscLibType}(kw -> arg, ...)\nOptions(petsclib, kw -> arg, ...)\n\nCreate a PETSc options data structure for the petsclib.\n\nFor construction a set of keyword argment pairs should be given. If the option has no value it should be set to nothing or true. Setting an option to false will cause the option not to be set on the PETSc options table.\n\nExamples\n\njulia> using PETSc\n\njulia> petsclib = PETSc.petsclibs[1];\n\njulia> PETSc.initialize(petsclib)\n\njulia> opt = PETSc.Options(\n                         petsclib,\n                         ksp_monitor = nothing,\n                         ksp_view = true,\n                         pc_type = \"mg\",\n                         pc_mg_levels = 1,\n                         false_opt = false,\n                     )\n#PETSc Option Table entries:\n-ksp_monitor\n-ksp_view\n-pc_mg_levels 1\n-pc_type mg\n#End of PETSc Option Table entries\n\n\njulia> opt[\"ksp_monitor\"]\n\"\"\n\njulia> opt[\"pc_type\"]\n\"mg\"\n\njulia> opt[\"pc_type\"] = \"ilu\"\n\"ilu\"\n\njulia> opt[\"pc_type\"]\n\"ilu\"\n\njulia> opt[\"false_opt\"]\nERROR: KeyError: key \"bad_key\" not found\n\njulia> opt[\"bad_key\"]\nERROR: KeyError: key \"bad_key\" not found\n\nManual: PetscOptionsCreate\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.PetscLibType","page":"List of functions","title":"PETSc.PetscLibType","text":"PetscLibType{PetscScalar, PetscInt}(petsc_library)\n\nA container for specific PETSc libraries.\n\nAll other containers for PETSc objects should be typed on this to ensure that dispatch is correct.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecSeq","page":"List of functions","title":"PETSc.VecSeq","text":"VecSeq(v::Vector)\n\nA standard, sequentially-stored serial PETSc vector, wrapping the Julia vector v.\n\nThis reuses the array v as storage, and so v should not be resize!-ed or otherwise have its length modified while the PETSc object exists.\n\nThis should only be need to be called for more advanced uses, for most simple usecases, users should be able to pass Vectors directly and have the wrapping performed automatically\n\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecCreateSeqWithArray.html\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.ViewerStdout","page":"List of functions","title":"PETSc.ViewerStdout","text":"ViewerStdout(petsclib, comm = MPI.COMM_SELF)\n\nCreate an ASCII PetscViewer for the comm\n\nManual: PETSC_VIEWER_STDOUT_\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.Initialize","page":"List of functions","title":"PETSc.Initialize","text":"initialize([petsclib])\n\nInitialized the petsclib, if no petsclib is given then all PETSc.petsclibs will be initialized.\n\nAdditionally:\n\nThis will initialize MPI if it has not already been initialized.\nIt will disable the PETSc signal handler (via PetscPopSignalHandler)\nAdd an atexit hook to call PETSc.finalize.\n\nManual: PetscInitializeNoArguments\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.Initialized","page":"List of functions","title":"PETSc.Initialized","text":"initialized(petsclib)\n\nCheck if petsclib is initialized\n\nManual: PetscInitialized\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.decref-Tuple{Any}","page":"List of functions","title":"PETSc.decref","text":"decref(obj)\n\nDecrement the reference counter for obj.\n\nIn general we don't need to use this, as we can call destroy instead.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.finalize","page":"List of functions","title":"PETSc.finalize","text":"finalize(petsclib)\n\nFinalize the petsclib, if no petsclib is given then all PETSc.petsclibs will be finalized.\n\nManual: PetscFinalize\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.finalized","page":"List of functions","title":"PETSc.finalized","text":"finalized(petsclib)\n\nCheck if petsclib is finalized\n\nManual: PetscFinalized\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.incref-Tuple{Any}","page":"List of functions","title":"PETSc.incref","text":"incref(obj)\n\nIncrement the reference counter fo obj. This usually only needs to be called when accessing objects owned by other objects, e.g. via KSPGetPC.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.inttype-Union{Tuple{PETSc.PetscLibType{ST, IT, LibType} where LibType}, Tuple{IT}, Tuple{ST}} where {ST, IT}","page":"List of functions","title":"PETSc.inttype","text":"inttype(petsclib::PetscLibType)\n\nreturn the int type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.nrefs-Tuple{Any}","page":"List of functions","title":"PETSc.nrefs","text":"nrefs(obj)\n\nThe current reference count for obj.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ownershiprange","page":"List of functions","title":"PETSc.ownershiprange","text":"ownership_range(vec::AbstractVec)\n\nThe range of indices owned by this processor, assuming that the vectors are laid out with the first n1 elements on the first processor, next n2 elements on the second, etc. For certain parallel layouts this range may not be well defined.\n\nNote: unlike the C function, the range returned is inclusive (idx_first:idx_last)\n\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecGetOwnershipRange.html\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.parse_options-Tuple{Vector{String}}","page":"List of functions","title":"PETSc.parse_options","text":"parse_options(args::Vector{String})\n\nParse the args vector into a NamedTuple that can be used as the options for the PETSc solvers.\n\njulia --project file.jl -ksp_monitor -pc_type mg -ksp_view\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.realtype-Union{Tuple{PETSc.PetscLibType{ST, PetscInt, LibType} where {PetscInt, LibType}}, Tuple{ST}} where ST","page":"List of functions","title":"PETSc.realtype","text":"realtype(petsclib::PetscLibType)\n\nreturn the real type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.scalartype-Union{Tuple{PETSc.PetscLibType{ST, PetscInt, LibType} where {PetscInt, LibType}}, Tuple{ST}} where ST","page":"List of functions","title":"PETSc.scalartype","text":"scalartype(petsclib::PetscLibType)\n\nreturn the scalar type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.unsafe_localarray","page":"List of functions","title":"PETSc.unsafe_localarray","text":"unsafe_localarray(PetscScalar, ptr:CVec; read=true, write=true)\n\nReturn an Array{PetscScalar} containing local portion of the PETSc data.\n\nfinalize should be called on the Array before the data can be used.\n\nUse read=false if the array is write-only; write=false if read-only.\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.with-Union{Tuple{T}, Tuple{Any, PETSc.Options{T}}} where T","page":"List of functions","title":"PETSc.with","text":"with(f, opts::Options)\n\nCall f() with the Options opts set temporarily (in addition to any global options).\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Pages = [\"vec.md\", \"mat.md\"]","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]\nOrder   = [:function]","category":"page"},{"location":"#PETSc.jl","page":"Home","title":"PETSc.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PETSc.jl is a Julia wrapper for the Portable, Extensible Toolkit for Scientific Computation PETSc package, which allows solving ordinary and partial differential equations in parallel on laptops or massively parallel high-performance systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The use of Julia greatly simplifies the code that developers have to write, while allowing to employ Julia features such as automatic differentiation. The Julia wrapper also comes with a pre-build library, which greatly simplifies the process of getting your first code working in parallel, on different operating systems. In many cases, the Julia code is significantly shorter than its C counterpart.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This wrapper mimics the PETSc-functionality as closely as possible, but remains work in progress (meaning that not everything has been translated yet). See the official user guide if you want to learn more about PETSc in general. For Julia-specific examples, have a look at our examples or tests. ","category":"page"},{"location":"man/design/#Design-notes","page":"Design notes","title":"Design notes","text":"","category":"section"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"PETSc can only be built for a single PetscScalar type. A workaround is to build multiple PETSc libraries for all supported scalar types (Float32, Float64, Complex{Float64})\nAppears that Complex{Float32} not supported (https://github.com/JuliaParallel/PETSc.jl/blob/old/deps/build_petscs.jl#L128).\nTODO: check if still the case\nshould be supported.\nNeed JLL support for this (https://github.com/JuliaPackaging/Yggdrasil/issues/1527)\nDefine macro to @eval all functions which use ccall for different scalar types.\nAll PETSc types and methods which involve ccall need a PetscScalar parameter.\nTODO: GPU support: need separate ones for CUDA as well?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"We lazily initialize each library if an object of that parameter is constructed.\nAlso initialize MPI if not already initialized\nWhat MPI thread level is required?\nnone.\nAdd atexit hook to finalize PETSc (this should be okay with MPI atexit, due to LIFO)\nDisable the PETSc signal handler","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"A Julia object matching each PETSc object (Vec, Mat, KSP, etc.).\nThese will typically have a ptr as the first field, which lets us use the cconvert/unsafe_convert trick to pass pointer by value/reference.\nMost (all?) objects will have a comm field, for the MPI communicator\nObjects which wrap Julia objects will also need a reference to those objects to prevent GC.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For convenience, attach finalizers to call destroy for single-process (\"sequential\") objects (VecSeq, MatSeqXXX, or any others where comm = MPI.COMM_SELF).\nWe can't attach finalizers for distributed objects (i.e. VecMPI), as destroy needs to be called collectively on all MPI ranks.\nSafe for users to call destroy manually if finalizer already defined\nTODO: check this with PETSc devs\nyes.\nUnclear how to handle objects that are contained within others, e.g. PC from KSPGetPC, KSP from SNESGetKSP, etc.\nThere appears to be some sort of reference counting, unclear if this is valid. PetscObjectReference / PetscObjectDereference\njust need to manually increment reference counter for these.\nFor PETSc objects which are equivalent to Julia objects (e.g. VecSeq : Vector{PetscScalar}, MatSeqDense : Matrix{PetscScalar}), use XXXCreateSeqWithArray methods so that they can share same memory.\nTODO: check PETSc guarantees on accessing the Julia objects directly.\nFor other objects (MatSeqAIJ), for now we let PETSc manage memory (may want to re-evaluate this later)\nDefine conversion routines to wrap with Seq objects where possible.\nDefine convenience versions of functions which take/return Julia Vectors, e.g. y = KSP(M) \\ x where y and x are Vectors.\nCan annotate PETSc objects with Julia ones via PetscContainerCreate & PetscObjectCompose\nFor specifying object options, there are 2 possible approaches:   (a) use PetscOptions objects (key-value pairs) to capture keyword args, which can be pushed and popped to the global options, then use XXXSetFromOption methods, e.g. KSP(mat, ksp_atol=1e-8)   (b) use C setter functions (e.g. KSPSetTolerances)\nfor now, we go with (a).\nit's easier\nnot all options are available via C setters, e.g. mg_coarse_XXX/mg_levels_XXX options\nideally we would create a more \"object-oriented\" interface: e.g. each preconditioner would be a different Julia type, but this doesn't yet seem possible.\ncan use PetscFunctionListGet to get runtime list of PC etc.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For cases where PETSc needs to call Julia functions (MatShell, SNES), PETSc provides a mechanism to pass through a context pointer. We can use this to pass through a pointer to the object itself via pointer_from_objref.\nCan we pass NULL to vec/matrix args? What does that do?\nWhat should the callback interface look like?\nHow to handle errors from within callbacks?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"TODO: Error handling:\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscPushErrorHandler.html","category":"page"}]
}
