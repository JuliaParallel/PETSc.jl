var documenterSearchIndex = {"docs":
[{"location":"man/dmstag/#DMStag","page":"DMStag","title":"DMStag","text":"","category":"section"},{"location":"man/dmstag/","page":"DMStag","title":"DMStag","text":"The following DMStag routines are available:","category":"page"},{"location":"man/dmstag/","page":"DMStag","title":"DMStag","text":"Modules = [PETSc]\nPages   = [\"dmstag.jl\"]","category":"page"},{"location":"man/dmstag/#Base.empty-Union{Tuple{PETSc.DMStag{PetscLib}}, Tuple{PetscLib}} where PetscLib","page":"DMStag","title":"Base.empty","text":"empty(dm::DMStag)\n\nreturn an uninitialized DMStag struct.\n\n\n\n\n\n","category":"method"},{"location":"man/dmstag/#PETSc.DMLocalToGlobal","page":"DMStag","title":"PETSc.DMLocalToGlobal","text":"DMLocalToGlobal(\n    dm::DMStag,\n    l::AbstractVec, \n    mode::InsertMode,\n    g::AbstractVec\n    )\n\nUpdates global vectors from local vectors. \n\ndm \t - the DM object\nl \t - the local vector\nmode - if INSERT_VALUES then no parallel communication is used, if ADD_VALUES then all ghost points from the same base point accumulate into that base point.\ng \t - the global vector\n\nExternal Links\n\nPETSc Manual: DM/DMLocalToGlobal\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagCreate1d","page":"DMStag","title":"PETSc.DMStagCreate1d","text":"dm = DMStagCreate1d(::PetscLib,\n    comm::MPI.Comm, \n    bndx::DMBoundaryType, \n    M, \n    dofVertex, \n    dofCenter, \n    stencilType::DMStagStencilType=DMSTAG_STENCIL_BOX, \n    stencilWidth=2, \n    lx=C_NULL; \n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n    )\n\nCreates a 1D DMStag object.         ::PetscLib      -   PETSc library,         comm            -   MPI communicator         bndx            -   boundary type: DMBOUNDARYNONE, DMBOUNDARYPERIODIC, or DMBOUNDARYGHOSTED.          M               -   global number of grid points         dofVertex       -   [=1] number of degrees of freedom per vertex/point/node/0-cell         dofCenter       -   [=1] number of degrees of freedom per element/edge/1-cell         stencilType     -   ghost/halo region type: DMSTAGSTENCILBOX or DMSTAGSTENCILNONE         stencilWidth    -   width, in elements, of halo/ghost region         lx              -   [Optional] Vector of local sizes, of length equal to the comm size, summing to M         options...      -   [Optional] keyword arguments (see PETSc webpage), specifiable as staggridx=100, etc. \n\nCreates a 1-D distributed staggered array with the options specified using keyword arguments.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagCreate1d\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagCreate2d","page":"DMStag","title":"PETSc.DMStagCreate2d","text":"dm = DMStagCreate2d(\n    ::PetscLib,\n    comm::MPI.Comm, \n    bndx::DMBoundaryType, \n    bndy::DMBoundaryType, \n    M, N, \n    m=C_NULL, n=C_NULL, \n    dofVertex=1, \n    dofEdge=1, \n    dofElement=1, \n    stencilType::DMStagStencilType=DMSTAG_STENCIL_BOX, \n    stencilWidth=2, \n    lx=C_NULL, ly=C_NULL; \n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n    )\n\nCreates a 2D DMStag object.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagCreate2d\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagCreate3d","page":"DMStag","title":"PETSc.DMStagCreate3d","text":"dm = DMStagCreate3d(\n    ::PetscLib,\n    comm::MPI.Comm, \n    bndx::DMBoundaryType, bndy::DMBoundaryType, bndz::DMBoundaryType, \n    M, N, P, \n    m, n, p, \n    dofVertex, \n    dofEdge, \n    dofFace, \n    dofElement, \n    stencilType::DMStagStencilType=DMSTAG_STENCIL_BOX, \n    stencilWidth, \n    lx, ly, lz; \n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n    )\n\nCreates a 3D DMStag object.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagCreate3d\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagCreateCompatibleDMStag","page":"DMStag","title":"PETSc.DMStagCreateCompatibleDMStag","text":"dm = DMStagCreateCompatibleDMStag(\n    dm::DMStag, \n    dofVertex, \n    dofEdge, \n    dofFace, \n    dofElement; \n    kwargs...)\n\nCreates a compatible DMStag with different dof/stratum \n\n    dm              -   the DMStag object \n    dofVertex       -   [=0] number of degrees of freedom per vertex/point/node/0-cell\n    dofEdge         -   [=0] number of degrees of freedom per edge/1-cell \n    dofFace         -   [=0] number of degrees of freedom per face/2-cell \n    dofElement      -   [=0] number of degrees of freedom per element/3-cell \n    kwargs...       -   [Optional] keyword arguments (see PETSc webpage), specifiable as stag_grid_x=100, etc.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagCreateCompatibleDMStag\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetBoundaryTypes","page":"DMStag","title":"PETSc.DMStagGetBoundaryTypes","text":"Bx = DMStagGetBoundaryTypes(dm::DMStag) in 1D\nBx,By,Bz = DMStagGetBoundaryTypes(dm::DMStag) in 3D\n\nGet boundary types.\n\n    dm \t     - the DMStag object \n    Bx,By,Bz - boundary types\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetBoundaryTypes\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetDOF","page":"DMStag","title":"PETSc.DMStagGetDOF","text":"dof0,dof1,dof2,dof3 = DMStagGetDOF(dm::DMStag)\n\nGet number of DOF associated with each stratum of the grid. \n\ndm      - the DMStag object \ndof0 \t- the number of points per 0-cell (vertex/node)\ndof1 \t- the number of points per 1-cell (element in 1D, edge in 2D and 3D)\ndof2 \t- the number of points per 2-cell (element in 2D, face in 3D)\ndof3 \t- the number of points per 3-cell (element in 3D)\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetDOF\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetEntriesPerElement","page":"DMStag","title":"PETSc.DMStagGetEntriesPerElement","text":"entriesPerElement = DMStagGetEntriesPerElement(dm::DMStag)\n\nGet number of entries per element in the local representation. \n\ndm                - the DMStag objects\nentriesPerElement - number of entries associated with each element in the local representation\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetEntriesPerElement\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetGhostArrayLocationSlot","page":"DMStag","title":"PETSc.DMStagGetGhostArrayLocationSlot","text":"Array = DMStagGetGhostArrayLocationSlot(\n    dm::DMStag, \n    v::AbstractVec, \n    loc::DMStagStencilLocation, \n    dof::Int\n    )\n\nJulia routine that extracts an array related to a certain DOF. Modifying values in the array will change them in the local PetscVec. Use LocalToGlobal to update global vector values.\n\nUsage:\n\nInput:\n    dm           -   the DMStag object \n    v,ArrayFull  -   the local vector as obtained with DMCreateLocalVector, can also be a local array\n    loc          -   a DMStagStencilLocation\n    dof          -   the degree of freedom on loc, which you want to extracts\n    \nOutput:\n    Array       -   local array that includes the ghost points, that is linked to the vector `v`. \n                        Modifying values in Array will update `v`\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetGlobalSizes","page":"DMStag","title":"PETSc.DMStagGetGlobalSizes","text":"M,N,P = DMStagGetGlobalSizes(dm::DMStag)\n\nGets the global size of the DMStag object\n\ndm      - the DMStag object \nM,N,P   - size in x,y,z\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetGlobalSizes\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetIndices","page":"DMStag","title":"PETSc.DMStagGetIndices","text":"Indices = DMStagGetIndices(dm::DMStag)\n\nReturn indices of start and end of the central/vertex nodes of a local array built from the input dm.  This takes ghost points into account and helps    \n\ndm \t        - the DMStag object\nIndices \t- indices of lower and upper range of center and vertex nodes\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetIsFirstRank","page":"DMStag","title":"PETSc.DMStagGetIsFirstRank","text":"fr_X,fr_Y,fr_Z = DMStagGetIsFirstRank(dm::DMStag)\n\nReturns boolean value to indicate whether this rank is first in each direction in the rank grid. Arguments corresponding to higher dimensions are ignored for 1D and 2D grids. These arguments may be set to NULL in this case.\n\ndm             - the DMStag object\nfr_X,fr_Y,fr_Z - whether this rank is first in each direction\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetIsFirstRank\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetIsLastRank","page":"DMStag","title":"PETSc.DMStagGetIsLastRank","text":"fr_X,fr_Y,fr_Z = DMStagGetIsLastRank(dm::DMStag)\n\nReturns boolean value to indicate whether this rank is last in each direction in the rank grid.\n\ndm             - the DMStag object\nfr_X,fr_Y,fr_Z - whether this rank is last in each direction\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetIsLastRank\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetLocalSizes","page":"DMStag","title":"PETSc.DMStagGetLocalSizes","text":"M,N,P = DMStagGetLocalSizes(dm::DMStag)\n\nGets the local size of the DMStag object\n\ndm      - the DMStag object \nM,N,P   - size in x,y,z\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetLocalSizes\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetLocationSlot","page":"DMStag","title":"PETSc.DMStagGetLocationSlot","text":"slot = DMStagGetLocationSlot(\n    dm::DMStag,\n    loc::DMStagStencilLocation, \n    c\n    )\n\nGet index to use in accessing raw local arrays.\n\ndm      - the DMStag object\nloc     - location relative to an element\nc       - component ( the degree of freedom)\nslot    - index to use\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetLocationSlot\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetNumRanks","page":"DMStag","title":"PETSc.DMStagGetNumRanks","text":"nRanks0 = DMStagGetNumRanks(dm::DMStag) in 1D\nnRanks0,nRanks1,nRanks2 = DMStagGetNumRanks(dm::DMStag) in 3D\n\nGet number of ranks in each direction in the global grid decomposition.\n\n    dm \t                     - the DMStag object \n    nRanks0,nRanks1,nRanks2  - number of ranks in each direction in the grid decomposition\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetNumRanks\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetProductCoordinateLocationSlot","page":"DMStag","title":"PETSc.DMStagGetProductCoordinateLocationSlot","text":"slot = DMStagGetProductCoordinateLocationSlot(\n    dm::DMStag,\n    loc::DMStagStencilLocation\n    )\n\nGet slot for use with local product coordinate arrays.\n\ndm      - the DMStag object\nloc     - the grid location \nslot    - the index to use in local arrays\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetProductCoordinateLocationSlot\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetStencilType","page":"DMStag","title":"PETSc.DMStagGetStencilType","text":"stencilType = DMStagGetStencilType(dm::DMStag)\n\nGet elementwise ghost/halo stencil type.\n\ndm          - the DMStag object\nstencilType - the elementwise ghost stencil type: DMSTAG_STENCIL_BOX, DMSTAG_STENCIL_STAR, or DMSTAG_STENCIL_NONE\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetStencilType\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagGetStencilWidth","page":"DMStag","title":"PETSc.DMStagGetStencilWidth","text":"stencilWidth = DMStagGetStencilWidth(dm::DMStag)\n\nGet elementwise stencil width. \n\ndm           - the DMStag objects\nstencilWidth - stencil/halo/ghost width in elements\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetStencilWidth\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagMatGetValuesStencil","page":"DMStag","title":"PETSc.DMStagMatGetValuesStencil","text":"val =  DMStagMatGetValuesStencil(\n    dm::DMStag, \n    mat::AbstractMat{PetscScalar}, \n    nRow,  \n    posRow::Vector{DMStagStencil}, \n    nCol, \n    posCol::Vector{DMStagStencil}\n    )\n\nThis reads a single value from a matrix DMStagStencil.\n\ndm      - the DMStag object\nmat     - the Mat\nposRow  - the location of the row of the set value, given by a DMStagStencil struct (as a vector)\nposCol  - the location of the row of the set value, given by a DMStagStencil struct (as a vector)\nval     - the value\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagMatGetValuesStencil\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagMatSetValuesStencil","page":"DMStag","title":"PETSc.DMStagMatSetValuesStencil","text":"DMStagMatSetValuesStencil(\n    dm::DMStag, \n    mat::AbstractMat, \n    nRow,  \n    posRow::Vector{DMStagStencil}, \n    nCol, \n    posCol::Vector{DMStagStencil}, \n    values::Vector{PetscScalar}, \n    insertMode::InsertMode\n    )\n\nThis puts values inside a matrix using DMStagStencil position\n\ndm\t        - the DMStag object\nmat\t        - the Mat\nposRow\t    - the location of the row of the set value, given by a DMStagStencil struct (as a vector)\nposCol\t    - the location of the row of the set value, given by a DMStagStencil struct (as a vector)\nval\t        - the value to be set\ninsertMode\t- INSERT_VALUES or ADD_VALUES\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagMatSetValuesStencil\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagSetUniformCoordinatesExplicit","page":"DMStag","title":"PETSc.DMStagSetUniformCoordinatesExplicit","text":"DMStagSetUniformCoordinatesExplicit(\n    dm::DMStag, \n    xmin, xmax, \n    ymin=0, ymax=0, \n    zmin=0, zmax=0\n    )\n\nSet DMStag coordinates to be a uniform grid, storing all values.\n\ndm                            - the DMStag object\nxmin,xmax,ymin,ymax,zmin,zmax - maximum and minimum global coordinate values\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagSetUniformCoordinatesExplicit\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagVecGetArray","page":"DMStag","title":"PETSc.DMStagVecGetArray","text":"X1 = DMStagVecGetArray(dm::DMStag, v::Vector)\n\nReturns a julia array from a vector v, in the same shape as the DMSTAG, which can be used to set values.\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagVecGetArrayRead","page":"DMStag","title":"PETSc.DMStagVecGetArrayRead","text":"Array =  DMStagVecGetArrayRead(dm::DMStag, v::AbstractVec)\n\nGet read-only access to a local array (including ghost points) of the DMStag\n\ndm    - the DMStag object\nvec   - the Vec object \nArray - the read-only array\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagVecGetValuesStencil","page":"DMStag","title":"PETSc.DMStagVecGetValuesStencil","text":"val = DMStagVecGetValuesStencil(\n    dm::DMStag, \n    vec::AbstractVec, \n    n, \n    pos::Vector{DMStagStencil}\n    )\n\nGet vector values using grid indexing.\n\ndm  - the DMStag object\nvec - the vector object\nn   - the number of values to obtain (do not fill if only one)\npos - locations to obtain values from (as an array of DMStagStencil values) \nval - value at the point\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagVecGetValuesStencil\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.DMStagVecSetValuesStencil","page":"DMStag","title":"PETSc.DMStagVecSetValuesStencil","text":"DMStagVecSetValuesStencil(\n    dm::DMStag, \n    vec::AbstractVec{PetscScalar}, \n    n, \n    pos::Vector{DMStagStencil}, \n    values::Vector{PetscScalar}, \n    insertMode::InsertMode\n    )\n\nThis puts values inside a global vector using DMStagStencil\n\ndm  - the DMStag object\nvec - the Vec\nn   - the number of values (do not fill if only 1)\npos - the location of the set values, given by a DMStagStencil struct\nval - the value to be set\ninsertMode  - INSERT_VALUES or ADD_VALUES\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagVecGetValuesStencil\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.LocalInGlobalIndices","page":"DMStag","title":"PETSc.LocalInGlobalIndices","text":"indices = LocalInGlobalIndices(dm::DMStag)\n\nGive the non-ghosted indices in the local vector that contribute to the global vector.\n\ndm      - the DMStag object\nindices - local indices\n\n\n\n\n\n","category":"function"},{"location":"man/dmstag/#PETSc.destroy-Tuple{PETSc.DMStag}","page":"DMStag","title":"PETSc.destroy","text":"destroy(dm::DMStag)\n\nDestroys a DMSTAG object and releases the memory\n\ndm \t- the DM object to destroy\n\nExternal Links\n\nPETSc Manual: DM/DMDestroy\n\n\n\n\n\n","category":"method"},{"location":"man/dmstag/#PETSc.getcorners-Tuple{PETSc.DMStag}","page":"DMStag","title":"PETSc.getcorners","text":"getcorners(dm::DMSTAG)\n\nReturns a NamedTuple with the global indices (excluding ghost points) of the lower and upper corners as well as the size.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetCorners\n\n\n\n\n\n","category":"method"},{"location":"man/dmstag/#PETSc.getghostcorners-Tuple{PETSc.DMStag}","page":"DMStag","title":"PETSc.getghostcorners","text":"getghostcorners(dm::DMStag)\n\nReturns a NamedTuple with the global indices (including ghost points) of the lower and upper corners as well as the size.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagGetGhostCorners\n\n\n\n\n\n","category":"method"},{"location":"man/dmstag/#PETSc.setuniformcoordinates!-Tuple{PETSc.DMStag, Any, Any}","page":"DMStag","title":"PETSc.setuniformcoordinates!","text":"setuniformcoordinates!(\n    dm::DMStag,\n    xyzmin::NTuple{N, Real},\n    xyzmax::NTuple{N, Real},\n) where {N}\n\nSet uniform coordinates for the dmstag using the lower and upper corners defined by the NTuples xyzmin and xyzmax. If N is less than the dimension of the dm then the value of the trailing coordinates is set to 0.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagSetUniformCoordinatesExplicit\n\n\n\n\n\n","category":"method"},{"location":"man/dmstag/#PETSc.setuniformcoordinatesproduct!","page":"DMStag","title":"PETSc.setuniformcoordinatesproduct!","text":"setuniformcoordinatesproduct!(\n    dm::DMStag,\n    xyzmin::NTuple{N, Real},\n    xyzmax::NTuple{N, Real},\n    )\n\nSet uniform coordinates for the dmstag using the lower and upper corners defined     by the NTuples xyzmin and xyzmax. If N is less than the dimension of the     dmstag then the value of the trailing coordinates is set to 0.\n\nExternal Links\n\nPETSc Manual: DMSTAG/DMStagSetUniformCoordinatesProduct\n\n\n\n\n\n","category":"function"},{"location":"man/vec/#Vec","page":"Vec","title":"Vec","text":"","category":"section"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"The following Vec routines are available:","category":"page"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"Modules = [PETSc]\nPages   = [\"vec.jl\"]","category":"page"},{"location":"man/mat/#Mat","page":"Mat","title":"Mat","text":"","category":"section"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"The following Mat routines are available:","category":"page"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"Modules = [PETSc]\nPages   = [\"mat.jl\"]","category":"page"},{"location":"man/snes/#SNES","page":"SNES","title":"SNES","text":"","category":"section"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"The following SNES routines are available:","category":"page"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"Modules = [PETSc]\nPages   = [\"snes.jl\"]","category":"page"},{"location":"man/ksp/#KSP","page":"KSP","title":"KSP","text":"","category":"section"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"The following KSP routines are available:","category":"page"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"Modules = [PETSc]\nPages   = [\"ksp.jl\"]","category":"page"},{"location":"man/ksp/#PETSc.Fn_KSPComputeOperators","page":"KSP","title":"PETSc.Fn_KSPComputeOperators","text":"struct Fn_KSPComputeOperators{T} end\n\nType used to wrap ComputeOperators! functions in KSP\n\n\n\n\n\n","category":"type"},{"location":"man/ksp/#PETSc.Fn_KSPComputeRHS","page":"KSP","title":"PETSc.Fn_KSPComputeRHS","text":"struct Fn_KSPComputeRHS{T} end\n\nType used to wrap ComputeRHS! functions in KSP\n\n\n\n\n\n","category":"type"},{"location":"man/ksp/#PETSc.KSP-Union{Tuple{PETSc.AbstractDM{PetscLib}}, Tuple{PetscLib}} where PetscLib","page":"KSP","title":"PETSc.KSP","text":"KSP(da::AbstractDM; options...)\n\nConstruct a PETSc Krylov subspace solver from the distributed mesh\n\nAny PETSc options prefixed with ksp_ and pc_ can be passed as keywords.\n\nsee PETSc manual\n\n\n\n\n\n","category":"method"},{"location":"man/ksp/#PETSc.KSP-Union{Tuple{PETSc.AbstractMat{T}}, Tuple{T}, Tuple{PETSc.AbstractMat{T}, PETSc.AbstractMat{T}}} where T","page":"KSP","title":"PETSc.KSP","text":"KSP(A, P; options...)\n\nConstruct a PETSc Krylov subspace solver.\n\nAny PETSc options prefixed with ksp_ and pc_ can be passed as keywords.\n\n\n\n\n\n","category":"method"},{"location":"man/ksp/#PETSc.KSPSetComputeOperators!","page":"KSP","title":"PETSc.KSPSetComputeOperators!","text":"KSPSetComputeOperators!(\n    ksp::KSP{Number},\n    ComputeOperators!,\n    ctx = C_NULL,\n)\n\nSet the linear operators function ComputeOperators! for the ksp using the user ctx. ComputeOperators! should be callable with four arguments of type (::KSP{Number}, ::Mat, ::Mat, ::Ptr); see PETSc manual\n\n\n\n\n\n","category":"function"},{"location":"man/ksp/#PETSc.KSPSetComputeRHS!","page":"KSP","title":"PETSc.KSPSetComputeRHS!","text":"KSPSetComputeRHS!(\n    ksp::KSP{Number},\n    ComputeRHS!,\n    ctx = C_NULL,\n)\n\nSet the right-hand side function ComputeRHS! for the ksp using the user ctx. ComputeRHS! should be callable with three arguments of type (::KSP{Number}, ::Vec, ::Ptr); see PETSc manual\n\n\n\n\n\n","category":"function"},{"location":"man/ksp/#PETSc.iters","page":"KSP","title":"PETSc.iters","text":"iters(ksp::KSP)\n\nGets the current iteration number; if the solve! is complete, returns the number of iterations used.\n\nExternal Links\n\nPETSc Manual: KSP/KSPGetIterationNumber\n\n\n\n\n\n","category":"function"},{"location":"man/ksp/#PETSc.resnorm","page":"KSP","title":"PETSc.resnorm","text":"resnorm(ksp::KSP)\n\nGets the last (approximate preconditioned) residual norm that has been computed.\n\nExternal Links\n\nPETSc Manual: KSP/KSPGetResidualNorm\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Getting started\n1a. Installation using pre-built libraries\n1b. Installation using pre-built libraries\n2. Solving a linear system of equations\n3. Nonlinear example","category":"page"},{"location":"man/getting_started/#a.-Installation-using-pre-built-libraries","page":"Getting Started","title":"1a. Installation using pre-built libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The easiest way to install the package is: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add PETSc","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install a pre-built PETSc library (PETSc_jll) as well as MPI.jl on your system. This will work both in serial and in parallel on your machine.","category":"page"},{"location":"man/getting_started/#b.-Installation-using-pre-built-libraries","page":"Getting Started","title":"1b. Installation using pre-built libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"On many high-performance clusters, you will have to use the provided MPI installation for that cluster and the default download above will not be sufficient. Alternatively, you may be interested in a PETSc installation that comes with additional external packages. Ensure that this PETSc installation is compiled as a dynamic (and not a static) library, after which you need to set the environmental variable JULIA_PETSC_LIBRARY to link to your PETSc installation: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"$export JULIA_PETSC_LIBRARY = /path/to/your/petsc/installation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now rebuild the package:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> build PETSc","category":"page"},{"location":"man/getting_started/#.-Solving-a-linear-system-of-equations","page":"Getting Started","title":"2. Solving a linear system of equations","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Lets consider the following elliptic equation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\npartial^2 T over partial x^2  = 0 T(0) = 1 T(1) = 11\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc\njulia> petsclib = PETSc.petsclibs[1]\njulia> PETSc.initialize(petsclib)\njulia> n   =  11\njulia> Δx  =  1. / (n - 1)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's first define the matrix with coefficients:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> nnz =  ones(Int64,n); nnz[2:n-1] .= 3;\njulia> A   =  PETSc.MatSeqAIJ{Float64}(n,n,nnz);\njulia> for i=2:n-1\n            A[i,i-1] =  1/Δx^2\n            A[i,i  ] = -2/Δx^2\n            A[i,i+1] =  1/Δx^2\n       end\n       A[1,1]=1; A[n,n]=1;\njulia> PETSc.assemble(A)\njulia> A\nMat Object: 1 MPI processes\n  type: seqaij\nrow 0: (0, 1.) \nrow 1: (0, 100.)  (1, -200.)  (2, 100.) \nrow 2: (1, 100.)  (2, -200.)  (3, 100.) \nrow 3: (2, 100.)  (3, -200.)  (4, 100.) \nrow 4: (3, 100.)  (4, -200.)  (5, 100.) \nrow 5: (4, 100.)  (5, -200.)  (6, 100.) \nrow 6: (5, 100.)  (6, -200.)  (7, 100.) \nrow 7: (6, 100.)  (7, -200.)  (8, 100.) \nrow 8: (7, 100.)  (8, -200.)  (9, 100.) \nrow 9: (8, 100.)  (9, -200.)  (10, 100.) \nrow 10: (10, 1.) ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, lets define the right-hand-size vector rhs as a julia vector:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> rhs = zeros(n); rhs[1]=1; rhs[11]=11;","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, we define the linear solver for the matrix A, which is done by setting a KSP solver: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ksp = PETSc.KSP(A; ksp_rtol=1e-8, pc_type=\"jacobi\", ksp_monitor=true)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that you can specify all PETSc command-line options as keywords here.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Solving the system of equations is simple:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> sol = ksp\\rhs\n  0 KSP Residual norm 1.104536101719e+01 \n  1 KSP Residual norm 4.939635614091e+00 \n  2 KSP Residual norm 2.410295378065e+00 \n  3 KSP Residual norm 1.462993806273e+00 \n  4 KSP Residual norm 1.004123728835e+00 \n  5 KSP Residual norm 7.700861485629e-01 \n  6 KSP Residual norm 6.165623662013e-01 \n  7 KSP Residual norm 4.972507567923e-01 \n  8 KSP Residual norm 4.074986825669e-01 \n  9 KSP Residual norm 3.398492183940e-01 \n 10 KSP Residual norm 3.283015493450e-15 \n11-element Vector{Float64}:\n  1.0\n  2.000000000000001\n  3.0000000000000013\n  4.000000000000001\n  5.000000000000002\n  6.0\n  7.0000000000000036\n  8.000000000000002\n  9.000000000000004\n 10.000000000000002\n 11.0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"And since we are using julia, plotting the solution can be done with","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Plots\njulia> plot(0:Δx:1,sol, ylabel=\"solution\",xlabel=\"x\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: linear_solution)","category":"page"},{"location":"man/getting_started/#.-Nonlinear-example","page":"Getting Started","title":"3. Nonlinear example","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's solve the coupled system of nonlinear equations: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\nx^2 + x y  = 3 \nx y + y^2  = 6\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"for x and y, which can be written in terms of a residual vector f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"f = binom x^2 + x y  - 3 x y + y^2  - 6","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this, we need to provide a residual function that computes f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function F!(cfx, cx, args...)\n         x     = PETSc.unsafe_localarray(Float64, cx;  write=false)   # read array\n         fx    = PETSc.unsafe_localarray(Float64, cfx; read=false)    # write array\n         \n         fx[1] = x[1]^2 + x[1]*x[2] - 3\n         fx[2] = x[1]*x[2] + x[2]^2 - 6\n         \n          Base.finalize(fx)\n          Base.finalize(x)\n       end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In addition, we need to provide the Jacobian:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"J = \nbeginpmatrix\nfracpartial f_1 partial x  fracpartial f_1 partial y  \nfracpartial f_2 partial x  fracpartial f_2 partial y  \nendpmatrix\n= \nbeginpmatrix\n2x + y  x  \ny  x + 2y  \nendpmatrix","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In Julia, this is:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function updateJ!(cx, J, args...)\n            x      = PETSc.unsafe_localarray(Float64, cx;  write=false)\n            J[1,1] = 2x[1] + x[2]\n            J[1,2] = x[1]\n            J[2,1] = x[2]\n            J[2,2] = x[1] + 2x[2]\n            Base.finalize(x)\n            PETSc.assemble(J)          \n        end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this using the PETSc nonlinear equation solvers, you first define the SNES solver together with the jacobian and residual functions as ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc, MPI\njulia> S = PETSc.SNES{Float64}(petsclib,MPI.COMM_SELF; ksp_rtol=1e-4, pc_type=\"none\")\njulia> PETSc.setfunction!(S, F!, PETSc.VecSeq(zeros(2)))\njulia> J = zeros(2,2)\njulia> PJ = PETSc.MatSeqDense(J)\njulia> PETSc.setjacobian!(S, updateJ!, PJ, PJ)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can solve this as:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PETSc.solve!([2.0,3.0], S)\n2-element Vector{Float64}:\n 1.000000003259629\n 1.999999998137355","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which indeed recovers the analytical solution (x=1 y=2).","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here a summary of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"CurrentModule = PETSc","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]","category":"page"},{"location":"man/listfunctions/#PETSc.AbstractOptions","page":"List of functions","title":"PETSc.AbstractOptions","text":"AbstractOptions{PetscLib <: PetscLibType}\n\nAbstract type of PETSc solver options.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.AbstractViewer","page":"List of functions","title":"PETSc.AbstractViewer","text":"AbstractViewer{PetscLib <: PetscLibType}\n\nAbstract type of PETSc viewer.\n\nExternal Links\n\nPETSc Manual: Viewer/PetscViewer\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.DMGlobalVec","page":"List of functions","title":"PETSc.DMGlobalVec","text":"DMGlobalVec(v::CVec, dm::AbstractDM)\n\nContainer for an PETSc vector we know is \"global\"\n\nExternal Links\n\nPETSc Manual: Vec/Vec\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.DMLocalVec","page":"List of functions","title":"PETSc.DMLocalVec","text":"DMLocalVec(v::CVec, dm::AbstractDM)\n\nContainer for an PETSc vector we know is \"local\"\n\nExternal Links\n\nPETSc Manual: Vec/Vec\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.GlobalOptions","page":"List of functions","title":"PETSc.GlobalOptions","text":"GlobalOptions{PetscLib <: PetscLibType}\n\nThe PETSc global options database.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.Mat","page":"List of functions","title":"PETSc.Mat","text":"Mat{T}\n\nContainer for an abstract PETSc matrix\n\nSee PETSc manual\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatNullSpace","page":"List of functions","title":"PETSc.MatNullSpace","text":"MatNullSpace{T}\n\nObject that removes a null space from a vector, i.e. orthogonalizes the vector to a subspace; see MatNullSpace and MatNullSpaceCreate\n\n!!! Note     The caller is responsible for calling destroy on this object\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqAIJ","page":"List of functions","title":"PETSc.MatSeqAIJ","text":"MatSeqAIJ{T}\n\nPETSc sparse array using AIJ format (also known as a compressed sparse row or CSR format).\n\nMemory allocation is handled by PETSc.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqDense","page":"List of functions","title":"PETSc.MatSeqDense","text":"MatSeqDense{T}\n\nPETSc dense array. This wraps a Julia Matrix{T} object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatShell","page":"List of functions","title":"PETSc.MatShell","text":"MatShell{T}(obj, m, n)\n\nCreate a m×n PETSc shell matrix object wrapping obj.\n\nIf obj is a Function, then the multiply action obj(y,x); otherwise it calls mul!(y, obj, x). This can be changed by defining PETSc._mul!.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatStencil","page":"List of functions","title":"PETSc.MatStencil","text":"MatStencil{PetscInt}\n\nEquivalent to the MatStencil in PETSc\n\nSee PETSc manual\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.Options","page":"List of functions","title":"PETSc.Options","text":"Options{PetscLib <: PetscLibType}(kw -> arg, ...)\nOptions(petsclib, kw -> arg, ...)\n\nCreate a PETSc options data structure for the petsclib.\n\nFor construction a set of keyword argment pairs should be given. If the option has no value it should be set to nothing or true. Setting an option to false will cause the option not to be set on the PETSc options table.\n\nExamples\n\njulia> using PETSc\n\njulia> petsclib = PETSc.petsclibs[1];\n\njulia> PETSc.initialize(petsclib)\n\njulia> opt = PETSc.Options(\n                         petsclib,\n                         ksp_monitor = nothing,\n                         ksp_view = true,\n                         pc_type = \"mg\",\n                         pc_mg_levels = 1,\n                         false_opt = false,\n                     )\n#PETSc Option Table entries:\n-ksp_monitor\n-ksp_view\n-pc_mg_levels 1\n-pc_type mg\n#End of PETSc Option Table entries\n\n\njulia> opt[\"ksp_monitor\"]\n\"\"\n\njulia> opt[\"pc_type\"]\n\"mg\"\n\njulia> opt[\"pc_type\"] = \"ilu\"\n\"ilu\"\n\njulia> opt[\"pc_type\"]\n\"ilu\"\n\njulia> opt[\"false_opt\"]\nERROR: KeyError: key \"bad_key\" not found\n\njulia> opt[\"bad_key\"]\nERROR: KeyError: key \"bad_key\" not found\n\nExternal Links\n\nPETSc Manual: Sys/PetscOptionsCreate\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.PetscLibType","page":"List of functions","title":"PETSc.PetscLibType","text":"PetscLibType{PetscScalar, PetscInt}(petsc_library)\n\nA container for specific PETSc libraries.\n\nAll other containers for PETSc objects should be typed on this to ensure that dispatch is correct.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.SNES-Tuple{}","page":"List of functions","title":"PETSc.SNES","text":"SNES{PetscScalar}(\n    ::UnionPetscLib,\n    comm::MPI.Comm; \n    snessetfromoptions = true,\n    options...)\n\nInitializes a SNES nonlinear solver object\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.Vec","page":"List of functions","title":"PETSc.Vec","text":"Vec(v::CVec)\n\nContainer for an abstract PETSc vector\n\nExternal Links\n\nPETSc Manual: Vec/Vec\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecSeq","page":"List of functions","title":"PETSc.VecSeq","text":"VecSeq(v::Vector)\n\nA standard, sequentially-stored serial PETSc vector, wrapping the Julia vector v.\n\nThis reuses the array v as storage, and so v should not be resize!-ed or otherwise have its length modified while the PETSc object exists.\n\nThis should only be need to be called for more advanced uses, for most simple usecases, users should be able to pass Vectors directly and have the wrapping performed automatically\n\nExternal Links\n\nPETSc Manual: Vec/VecCreateSeqWithArray\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.ViewerStdout","page":"List of functions","title":"PETSc.ViewerStdout","text":"ViewerStdout(petsclib, comm = MPI.COMM_SELF)\n\nCreate an ASCII PetscViewer for the comm\n\nExternal Links\n\nPETSc Manual: Viewer/PETSC_VIEWER_STDOUT_\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#Base.empty-Union{Tuple{PETSc.DMDA{PetscLib}}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"Base.empty","text":"empty(da::DMDA)\n\nreturn an uninitialized DMDA struct.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.DMDACreate1d","page":"List of functions","title":"PETSc.DMDACreate1d","text":"DMDACreate1d(\n    ::PetscLib\n    comm::MPI.Comm,\n    boundary_type::DMBoundaryType,\n    global_dim,\n    dof_per_node,\n    stencil_width,\n    points_per_proc::Union{Nothing, Vector{PetscInt}};\n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n)\n\nCreates a 1-D distributed array with the options specified using keyword arguments.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDACreate1d\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.DMDACreate2d","page":"List of functions","title":"PETSc.DMDACreate2d","text":"DMDACreate2d(\n    ::PetscLib\n    comm::MPI.Comm,\n    boundary_type_x::DMBoundaryType,\n    boundary_type_y::DMBoundaryType,\n    stencil_type::DMDAStencilType,\n    global_dim_x,\n    global_dim_y,\n    procs_x,\n    procs_y,\n    dof_per_node,\n    stencil_width,\n    points_per_proc_x::Union{Nothing, Vector{PetscInt}};\n    points_per_proc_y::Union{Nothing, Vector{PetscInt}};\n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n)\n\nCreates a 2-D distributed array with the options specified using keyword arguments.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDACreate2d\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.DMDACreate3d","page":"List of functions","title":"PETSc.DMDACreate3d","text":"DMDACreate3d(\n    ::PetscLib\n    comm::MPI.Comm,\n    boundary_type_x::DMBoundaryType,\n    boundary_type_y::DMBoundaryType,\n    boundary_type_z::DMBoundaryType,\n    stencil_type::DMDAStencilType,\n    global_dim_x,\n    global_dim_y,\n    global_dim_z,\n    procs_x,\n    procs_y,\n    procs_z,\n    global_dim_z,\n    dof_per_node,\n    stencil_width,\n    points_per_proc_x::Union{Nothing, Vector{PetscInt}};\n    points_per_proc_y::Union{Nothing, Vector{PetscInt}};\n    points_per_proc_z::Union{Nothing, Vector{PetscInt}};\n    dmsetfromoptions=true,\n    dmsetup=true,\n    options...\n)\n\nCreates a 3-D distributed array with the options specified using keyword arguments.\n\nIf keyword argument dmsetfromoptions == true then setfromoptions! called. If keyword argument dmsetup == true then setup! is called.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDACreate3d\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.Initialize","page":"List of functions","title":"PETSc.Initialize","text":"initialize([petsclib])\n\nInitialized the petsclib, if no petsclib is given then all PETSc.petsclibs will be initialized.\n\nAdditionally:\n\nThis will initialize MPI if it has not already been initialized.\nIt will disable the PETSc signal handler (via Sys/PetscPopSignalHandler\nAdd an atexit hook to call PETSc.finalize.\n\nExternal Links\n\nPETSc Manual: Sys/PetscInitializeNoArguments\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.Initialized","page":"List of functions","title":"PETSc.Initialized","text":"initialized(petsclib)\n\nCheck if petsclib is initialized\n\nExternal Links\n\nPETSc Manual: Sys/PetscInitialized\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.MatNullSpaceRemove!","page":"List of functions","title":"PETSc.MatNullSpaceRemove!","text":"MatNullSpaceRemove!(nullspace, vec)\n\nRemoves all the components of a nullspace from vec\n\nsee PETSc manual\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.MatSetNullSpace!","page":"List of functions","title":"PETSc.MatSetNullSpace!","text":"MatSetNullSpace!(mat, nullspace)\n\nAttach nullspace to mat\n\nsee PETSc manual\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.MatSetValuesStencil!","page":"List of functions","title":"PETSc.MatSetValuesStencil!","text":"MatSetValuesStencil!(mat::AbstractMat{PetscScalar},\n    rows::Vector{MatStencil{PetscInt}}, \n    cols::Vector{MatStencil{PetscInt}}, \n    vals::Vector{PetscScalar},\n    mode;\n    num_cols = length(col),\n    num_rows = length(row)\n  )\n\nInsert the vals specified by rows and cols stencil indices into the mat. The optional arguments num_cosl and num_rows allow the limiting of the elements of the rows and cols vectors.\n\nsee PETSc manual\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.createglobalvector","page":"List of functions","title":"PETSc.createglobalvector","text":"createglobalvector(dm::DM; write::Bool = true, read::Bool = true)\n\nreturns a global vector from the dm object.\n\nExternal Links\n\nPETSc Manual: DM/DMCreateGlobalVector\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.createlocalvector","page":"List of functions","title":"PETSc.createlocalvector","text":"createlocalvector(dm::AbstractDM)\n\nreturns a local vector from the dm object.\n\nExternal Links\n\nPETSc Manual: DM/DMCreateLocalVector\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.creatematrix","page":"List of functions","title":"PETSc.creatematrix","text":"creatematrix(dm::AbstractDM)\n\nGenerates a matrix from the dm object.\n\nExternal Links\n\nPETSc Manual: DM/DMCreateMatrix\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.decref-Tuple{Any}","page":"List of functions","title":"PETSc.decref","text":"decref(obj)\n\nDecrement the reference counter for obj.\n\nIn general we don't need to use this, as we can call destroy instead.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.finalize","page":"List of functions","title":"PETSc.finalize","text":"finalize(petsclib)\n\nFinalize the petsclib, if no petsclib is given then all PETSc.petsclibs will be finalized.\n\nExternal Links\n\nPETSc Manual: Sys/PetscFinalize\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.finalized","page":"List of functions","title":"PETSc.finalized","text":"finalized(petsclib)\n\nCheck if petsclib is finalized\n\nExternal Links\n\nPETSc Manual: Sys/PetscFinalized\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.getcoordinateDM","page":"List of functions","title":"PETSc.getcoordinateDM","text":"getcoordinateDM(dm::AbstractDM)\n\nCreate a coord_dm for the coordinates of dm.\n\nExternal Links\n\nPETSc Manual: DM/DMGetCoordinateDM\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.getcoordinateslocal","page":"List of functions","title":"PETSc.getcoordinateslocal","text":"getcoordinateslocal(dm::AbstractDM)\n\nGets a local vector with the coordinates associated with dm.\n\nExternal Links\n\nPETSc Manual: DM/DMGetCoordinatesLocal\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.getcorners-Tuple{PETSc.DMDA}","page":"List of functions","title":"PETSc.getcorners","text":"getcorners(da::DMDA)\n\nReturns a NamedTuple with the global indices (excluding ghost points) of the lower and upper corners as well as the size.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDAGetCorners\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getdimension-Tuple{PETSc.AbstractDM}","page":"List of functions","title":"PETSc.getdimension","text":"getdimension(dm::AbstractDM)\n\nReturn the topological dimension of the dm\n\nExternal Links\n\nPETSc Manual: DM/DMGetDimension\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getghostcorners-Tuple{PETSc.DMDA}","page":"List of functions","title":"PETSc.getghostcorners","text":"getghostcorners(da::DMDA)\n\nReturns a NamedTuple with the global indices (including ghost points) of the lower and upper corners as well as the size.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDAGetGhostCorners\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getinfo-Tuple{PETSc.DMDA}","page":"List of functions","title":"PETSc.getinfo","text":"getinfo(da::DMDA)\n\nGet the info associated with the distributed array da.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDAGetInfo\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.gettype-Tuple{PETSc.AbstractDM}","page":"List of functions","title":"PETSc.gettype","text":"gettype(dm::AbstractDM)\n\nGets type name of the dm\n\nExternal Links\n\nPETSc Manual: DM/DMGetType\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getvalues!-Tuple{PETSc.AbstractVec}","page":"List of functions","title":"PETSc.getvalues!","text":"getvalues!(\n    vector::AbstractVec{PetscScalar},\n    indices::Vector{PetscInt},\n    vals::Vector{PetscScalar};\n    num_vals = length(inds)\n)\n\nGet a set of values from the vector. Equivalent to one of the following\n\nvals[1:num_vals] .= vector[indices[1:num_vals]]\n\nwarning: Warning\nindices should use 0-based indexing!\n\nExternal Links\n\nPETSc Manual: Vec/VecGetValues\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.incref-Tuple{Any}","page":"List of functions","title":"PETSc.incref","text":"incref(obj)\n\nIncrement the reference counter fo obj. This usually only needs to be called when accessing objects owned by other objects, e.g. via KSPGetPC.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.inttype-Union{Tuple{PETSc.PetscLibType{ST, IT, LibType} where LibType}, Tuple{IT}, Tuple{ST}} where {ST, IT}","page":"List of functions","title":"PETSc.inttype","text":"inttype(petsclib::PetscLibType)\n\nreturn the int type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.map_unsafe_localarray!-Union{Tuple{T}, Tuple{Any, PETSc.AbstractVec{T}}} where T","page":"List of functions","title":"PETSc.map_unsafe_localarray!","text":"map_unsafe_localarray!(f!, x::AbstractVec{T}; read=true, write=true)\n\nConvert x to an Array{T} and apply the function f!.\n\nUse read=false if the array is write-only; write=false if read-only.\n\nExamples\n\n```julia-repl julia> mapunsafelocalarray(x; write=true) do x    @. x .*= 2 end\n\nnote: Note\nBase.finalize should is automatically called on the array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.nrefs-Tuple{Any}","page":"List of functions","title":"PETSc.nrefs","text":"nrefs(obj)\n\nThe current reference count for obj.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ownershiprange","page":"List of functions","title":"PETSc.ownershiprange","text":"ownershiprange(vec::AbstractVec)\n\nThe range of indices owned by this processor, assuming that the vectors are laid out with the first n1 elements on the first processor, next n2 elements on the second, etc. For certain parallel layouts this range may not be well defined.\n\nNote: unlike the C function, the range returned is inclusive (idx_first:idx_last)\n\nExternal Links\n\nPETSc Manual: Vec/VecGetOwnershipRange\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.parse_options-Tuple{Vector{String}}","page":"List of functions","title":"PETSc.parse_options","text":"parse_options(args::Vector{String})\n\nParse the args vector into a NamedTuple that can be used as the options for the PETSc solvers.\n\njulia --project file.jl -ksp_monitor -pc_type mg -ksp_view\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.realtype-Union{Tuple{PETSc.PetscLibType{ST, PetscInt, LibType} where {PetscInt, LibType}}, Tuple{ST}} where ST","page":"List of functions","title":"PETSc.realtype","text":"realtype(petsclib::PetscLibType)\n\nreturn the real type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.scalartype-Union{Tuple{PETSc.PetscLibType{ST, PetscInt, LibType} where {PetscInt, LibType}}, Tuple{ST}} where ST","page":"List of functions","title":"PETSc.scalartype","text":"scalartype(petsclib::PetscLibType)\n\nreturn the scalar type for the associated petsclib\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.setfromoptions!","page":"List of functions","title":"PETSc.setfromoptions!","text":"setfromoptions!(da::DM, opts=da.opts)\n\nExternal Links\n\nPETSc Manual: DM/DMSetFromOptions\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.setuniformcoordinates!","page":"List of functions","title":"PETSc.setuniformcoordinates!","text":"setuniformcoordinates!(\n    da::DMDA\n    xyzmin::NTuple{N, Real},\n    xyzmax::NTuple{N, Real},\n) where {N}\n\nSet uniform coordinates for the da using the lower and upper corners defined by the NTuples xyzmin and xyzmax. If N is less than the dimension of the da then the value of the trailing coordinates is set to 0.\n\nExternal Links\n\nPETSc Manual: DMDA/DMDASetUniformCoordinates\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.setup!","page":"List of functions","title":"PETSc.setup!","text":"setup!(da::DM, opts=da.opts)\n\nExternal Links\n\nPETSc Manual: DM/DMSetUp\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.setvalues!-Tuple{PETSc.AbstractVec}","page":"List of functions","title":"PETSc.setvalues!","text":"setvalues!(\n    vector::AbstractVec{PetscScalar},\n    indices::Vector{PetscInt},\n    vals::Vector{PetscScalar},\n    mode::InsertMode;\n    num_vals = length(ind)\n)\n\nInsert a set of values into the vector. Equivalent to one of the following depending on the mode\n\nvector[indices[1:num_vals]] .= vals[1:num_vals]\nvector[indices[1:num_vals]] .+= vals[1:num_vals]\n\nwarning: Warning\nindices should use 0-based indexing!\n\nExternal Links\n\nPETSc Manual: Vec/VecSetValues\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.unsafe_localarray","page":"List of functions","title":"PETSc.unsafe_localarray","text":"unsafe_localarray(PetscScalar, ptr:CVec; read=true, write=true)\nunsafe_localarray(ptr:AbstractVec; read=true, write=true)\n\nReturn an Array{PetscScalar} containing local portion of the PETSc data.\n\nUse read=false if the array is write-only; write=false if read-only.\n\nnote: Note\nBase.finalize should be called on the Array before the data can be used.\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.update!-Tuple{PETSc.DMGlobalVec, PETSc.DMLocalVec, PETSc.InsertMode}","page":"List of functions","title":"PETSc.update!","text":"update!(\n    global_vec::DMGlobalVec,\n    local_vec::DMLocalVec,\n    mode::InsertMode,\n)\n\nUpdates global_vec from local_vec with insert mode\n\nExternal Links\n\nPETSc Manual: DM/DMLocalToGlobal\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.update!-Tuple{PETSc.DMGlobalVec, Ptr{Nothing}, PETSc.InsertMode}","page":"List of functions","title":"PETSc.update!","text":"update!(\n    global_ptr::CVec,\n    local_vec::DMLocalVec,\n    mode::InsertMode,\n)\n\nUpdates pointer to global vec global_ptr from local_vec with insert mode\n\nExternal Links\n\nPETSc Manual: DM/DMLocalToGlobal\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.update!-Tuple{PETSc.DMLocalVec, PETSc.DMGlobalVec, PETSc.InsertMode}","page":"List of functions","title":"PETSc.update!","text":"update!(\n    local_vec::DMLocalVec,\n    global_vec::DMGlobalVec,\n    mode::InsertMode\n)\n\nUpdates local_vec from a pointer to a global vec global_ptr with insert mode\n\nExternal Links\n\nPETSc Manual: DM/DMGlobalToLocal\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.update!-Tuple{PETSc.DMLocalVec, Ptr{Nothing}, PETSc.InsertMode}","page":"List of functions","title":"PETSc.update!","text":"update!(\n    local_vec::DMLocalVec,\n    global_ptr::CVec,\n    mode::InsertMode,\n)\n\nUpdates local_vec from pointer to global vec global_ptr with insert mode\n\nExternal Links\n\nPETSc Manual: DM/DMGlobalToLocal\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.update!-Tuple{Ptr{Nothing}, PETSc.DMGlobalVec, PETSc.InsertMode}","page":"List of functions","title":"PETSc.update!","text":"update!(\n    local_ptr::CVec,\n    global_vec::DMGlobalVec\n    mode::InsertMode,\n)\n\nUpdates pointer to local vec local_ptr from global_vec with insert mode\n\nExternal Links\n\nPETSc Manual: DM/DMGlobalToLocal\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.update_global2local!","page":"List of functions","title":"PETSc.update_global2local!","text":"update_global2local!(\n    local_ptr::CVec,\n    global_ptr::CVec,\n    mode::InsertMode,\n    dm::AbstractDM\n)\n\nUpdates pointer to local vector from pointer to global vector with insert mode, assuming that both belong to the same dm\n\nThis is a low-level routine that is typically called by update!\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.update_local2global!","page":"List of functions","title":"PETSc.update_local2global!","text":"update_local2global!(\n    global_ptr::CVec,\n    local_ptr::CVec,\n    mode::InsertMode,\n    dm::AbstractDM\n)\n\nUpdates pointer of global_vec from pointer of local_vec with insert mode.  Both vectors should belong to the same dm\n\nThis is a low-level routine that is typically called by update!\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.view-Tuple{PETSc.AbstractDM}","page":"List of functions","title":"PETSc.view","text":"view(dm::AbstractDM, viewer::Viewer=ViewerStdout(petsclib, getcomm(dm)))\n\nview a dm with viewer\n\nExternal Links\n\nPETSc Manual: DM/DMView\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.with-Union{Tuple{T}, Tuple{Any, PETSc.Options{T}}} where T","page":"List of functions","title":"PETSc.with","text":"with(f, opts::Options)\n\nCall f() with the Options opts set temporarily (in addition to any global options).\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Pages = [\"vec.md\", \"mat.md\"]","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]\nOrder   = [:function]","category":"page"},{"location":"#PETSc.jl","page":"Home","title":"PETSc.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PETSc.jl is a Julia wrapper for the Portable, Extensible Toolkit for Scientific Computation PETSc package, which allows solving ordinary and partial differential equations in parallel on laptops or massively parallel high-performance systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The use of Julia greatly simplifies the code that developers have to write, while allowing to employ Julia features such as automatic differentiation. The Julia wrapper also comes with a pre-built library, which greatly simplifies the process of getting your first code working in parallel, on different operating systems. In many cases, the Julia code is significantly shorter than its C counterpart.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This wrapper mimics the PETSc-functionality as closely as possible, but remains work in progress (meaning that not everything has been translated yet). See the official user guide if you want to learn more about PETSc in general. For Julia-specific examples, have a look at our examples or tests. ","category":"page"},{"location":"man/design/#Design-notes","page":"Design notes","title":"Design notes","text":"","category":"section"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"PETSc can only be built for a single PetscScalar type. A workaround is to build multiple PETSc libraries for all supported scalar types (Float32, Float64, Complex{Float64})\nAppears that Complex{Float32} not supported (https://github.com/JuliaParallel/PETSc.jl/blob/old/deps/build_petscs.jl#L128).\nTODO: check if still the case\nshould be supported.\nNeed JLL support for this (https://github.com/JuliaPackaging/Yggdrasil/issues/1527)\nDefine macro to @eval all functions which use ccall for different scalar types.\nAll PETSc types and methods which involve ccall need a PetscScalar parameter.\nTODO: GPU support: need separate ones for CUDA as well?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"We lazily initialize each library if an object of that parameter is constructed.\nAlso initialize MPI if not already initialized\nWhat MPI thread level is required?\nnone.\nAdd atexit hook to finalize PETSc (this should be okay with MPI atexit, due to LIFO)\nDisable the PETSc signal handler","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"A Julia object matching each PETSc object (Vec, Mat, KSP, etc.).\nThese will typically have a ptr as the first field, which lets us use the cconvert/unsafe_convert trick to pass pointer by value/reference.\nMost (all?) objects will have a comm field, for the MPI communicator\nObjects which wrap Julia objects will also need a reference to those objects to prevent GC.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For convenience, attach finalizers to call destroy for single-process (\"sequential\") objects (VecSeq, MatSeqXXX, or any others where comm = MPI.COMM_SELF).\nWe can't attach finalizers for distributed objects (i.e. VecMPI), as destroy needs to be called collectively on all MPI ranks.\nSafe for users to call destroy manually if finalizer already defined\nTODO: check this with PETSc devs\nyes.\nUnclear how to handle objects that are contained within others, e.g. PC from KSPGetPC, KSP from SNESGetKSP, etc.\nThere appears to be some sort of reference counting, unclear if this is valid. PetscObjectReference / PetscObjectDereference\njust need to manually increment reference counter for these.\nFor PETSc objects which are equivalent to Julia objects (e.g. VecSeq : Vector{PetscScalar}, MatSeqDense : Matrix{PetscScalar}), use XXXCreateSeqWithArray methods so that they can share same memory.\nTODO: check PETSc guarantees on accessing the Julia objects directly.\nFor other objects (MatSeqAIJ), for now we let PETSc manage memory (may want to re-evaluate this later)\nDefine conversion routines to wrap with Seq objects where possible.\nDefine convenience versions of functions which take/return Julia Vectors, e.g. y = KSP(M) \\ x where y and x are Vectors.\nCan annotate PETSc objects with Julia ones via PetscContainerCreate & PetscObjectCompose\nFor specifying object options, there are 2 possible approaches:   (a) use PetscOptions objects (key-value pairs) to capture keyword args, which can be pushed and popped to the global options, then use XXXSetFromOption methods, e.g. KSP(mat, ksp_atol=1e-8)   (b) use C setter functions (e.g. KSPSetTolerances)\nfor now, we go with (a).\nit's easier\nnot all options are available via C setters, e.g. mg_coarse_XXX/mg_levels_XXX options\nideally we would create a more \"object-oriented\" interface: e.g. each preconditioner would be a different Julia type, but this doesn't yet seem possible.\ncan use PetscFunctionListGet to get runtime list of PC etc.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For cases where PETSc needs to call Julia functions (MatShell, SNES), PETSc provides a mechanism to pass through a context pointer. We can use this to pass through a pointer to the object itself via pointer_from_objref.\nCan we pass NULL to vec/matrix args? What does that do?\nWhat should the callback interface look like?\nHow to handle errors from within callbacks?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"TODO: Error handling:\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscPushErrorHandler.html","category":"page"}]
}
