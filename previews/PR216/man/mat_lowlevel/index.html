<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mat · PETSc.jl</title><meta name="title" content="Mat · PETSc.jl"/><meta property="og:title" content="Mat · PETSc.jl"/><meta property="twitter:title" content="Mat · PETSc.jl"/><meta name="description" content="Documentation for PETSc.jl."/><meta property="og:description" content="Documentation for PETSc.jl."/><meta property="twitter:description" content="Documentation for PETSc.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PETSc.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">High-level interface</span><ul><li><a class="tocitem" href="../vec/">Vec</a></li><li><a class="tocitem" href="../mat/">Mat</a></li><li><a class="tocitem" href="../dm/">DM</a></li><li><a class="tocitem" href="../dmda/">DMDA</a></li><li><a class="tocitem" href="../dmstag/">DMStag</a></li><li><a class="tocitem" href="../ksp/">KSP</a></li><li><a class="tocitem" href="../snes/">SNES</a></li></ul></li><li><span class="tocitem">Low-level interface (LibPETSc)</span><ul><li><a class="tocitem" href="../lowlevel_intro/">Introduction</a></li><li><a class="tocitem" href="../vec_lowlevel/">Vec</a></li><li class="is-active"><a class="tocitem" href>Mat</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Function-Reference"><span>Function Reference</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">DM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dm_lowlevel/">DM</a></li><li><a class="tocitem" href="../dmda_lowlevel/">DMDA</a></li><li><a class="tocitem" href="../dmplex_lowlevel/">DMPlex</a></li><li><a class="tocitem" href="../dmstag_lowlevel/">DMStag</a></li><li><a class="tocitem" href="../dmswarm_lowlevel/">DMSwarm</a></li><li><a class="tocitem" href="../dmforest_lowlevel/">DMForest</a></li><li><a class="tocitem" href="../dmnetwork_lowlevel/">DMNetwork</a></li><li><a class="tocitem" href="../dmshell_lowlevel/">DMShell and others</a></li></ul></li><li><a class="tocitem" href="../ksp_lowlevel/">KSP</a></li><li><a class="tocitem" href="../snes_lowlevel/">SNES</a></li><li><a class="tocitem" href="../ts_lowlevel/">TS (Time Stepping)</a></li><li><a class="tocitem" href="../tao_lowlevel/">Tao (Optimization)</a></li><li><a class="tocitem" href="../is_lowlevel/">IS (Index Sets)</a></li><li><a class="tocitem" href="../petscviewer_lowlevel/">PetscViewer (I/O)</a></li><li><a class="tocitem" href="../petscsection_lowlevel/">PetscSection (DOF Layout)</a></li><li><a class="tocitem" href="../petscsf_lowlevel/">PetscSF (Communication)</a></li><li><a class="tocitem" href="../ao_lowlevel/">AO (Application Ordering)</a></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-level interface (LibPETSc)</a></li><li class="is-active"><a href>Mat</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mat</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaParallel/PETSc.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaParallel/PETSc.jl/blob/main/docs/src/man/mat_lowlevel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mat-Low-level-Interface"><a class="docs-heading-anchor" href="#Mat-Low-level-Interface">Mat - Low-level Interface</a><a id="Mat-Low-level-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Mat-Low-level-Interface" title="Permalink"></a></h1><p>This page documents the low-level, automatically wrapped PETSc Mat (matrix) functions available through <code>LibPETSc</code>. These functions provide direct access to the PETSc C API.</p><p>For the high-level Julia interface, see <a href="../mat/#Mat">Mat</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The Mat interface includes:</p><ul><li><strong>Core Mat operations</strong>: Creation, manipulation, and mathematical operations on matrices (~632 functions in <code>Mat_wrappers.jl</code>)</li><li><strong>Mat utilities</strong>: Additional matrix operations and conversions (~124 functions in <code>Mataddons_wrappers.jl</code>)</li></ul><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>All low-level Mat functions require a <code>petsclib</code> parameter as the first argument:</p><pre><code class="language-julia hljs">using PETSc

# Get the library instance
petsclib = PETSc.petsclibs[1]
PETSc.initialize(petsclib)

# Get PETSc types
PetscInt = petsclib.PetscInt
PetscScalar = petsclib.PetscScalar

# Create a sparse matrix
mat = LibPETSc.MatCreate(petsclib, LibPETSc.PETSC_COMM_SELF)
LibPETSc.MatSetSizes(petsclib, mat, PetscInt(10), PetscInt(10), PetscInt(10), PetscInt(10))
LibPETSc.MatSetType(petsclib, mat, &quot;seqaij&quot;)
LibPETSc.MatSetUp(petsclib, mat)

# Set values (0-based indexing!)
row = PetscInt[0]
cols = PetscInt[0, 1]
vals = PetscScalar[2.0, -1.0]
LibPETSc.MatSetValues(petsclib, mat, PetscInt(1), row, PetscInt(2), cols, vals, LibPETSc.INSERT_VALUES)

# Assemble
LibPETSc.MatAssemblyBegin(petsclib, mat, LibPETSc.MAT_FINAL_ASSEMBLY)
LibPETSc.MatAssemblyEnd(petsclib, mat, LibPETSc.MAT_FINAL_ASSEMBLY)

# Clean up
LibPETSc.MatDestroy(petsclib, mat)
PETSc.finalize(petsclib)</code></pre><h2 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAIJGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAIJGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatAIJGetLocalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAIJGetLocalMat(petsclib::PetscLibType,A::PetscMat, A_loc::PetscMat)</code></pre><p>Creates a <code>MATSEQAIJ</code> from a <code>MATAIJ</code> matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>A_loc</code> - the local sequential matrix generated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMPIAIJGetLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAIJGetLocalMat.html"><code>Mat/MatAIJGetLocalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15928-L15946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAXPY-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAXPY-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><code>PETSc.LibPETSc.MatAXPY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAXPY(petsclib::PetscLibType,Y::PetscMat, a::PetscScalar, X::PetscMat, str::MatStructure)</code></pre><p>Computes Y = a*X + Y.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>a</code>   - the scalar multiplier</li><li><code>X</code>   - the first matrix</li><li><code>Y</code>   - the second matrix</li><li><code>str</code> - either <code>SAME_NONZERO_PATTERN</code>, <code>DIFFERENT_NONZERO_PATTERN</code>, <code>UNKNOWN_NONZERO_PATTERN</code>, or <code>SUBSET_NONZERO_PATTERN</code> (nonzeros of <code>X</code> is a subset of <code>Y</code>&#39;s)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAYPX()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAXPY.html"><code>Mat/MatAXPY</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19767-L19785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAYPX-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAYPX-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><code>PETSc.LibPETSc.MatAYPX</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAYPX(petsclib::PetscLibType,Y::PetscMat, a::PetscScalar, X::PetscMat, str::MatStructure)</code></pre><p>Computes Y = a*Y + X.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>a</code>   - the <code>PetscScalar</code> multiplier</li><li><code>Y</code>   - the first matrix</li><li><code>X</code>   - the second matrix</li><li><code>str</code> - either <code>SAME_NONZERO_PATTERN</code>, <code>DIFFERENT_NONZERO_PATTERN</code>, <code>UNKNOWN_NONZERO_PATTERN</code>, or <code>SUBSET_NONZERO_PATTERN</code> (nonzeros of <code>X</code> is a subset of <code>Y</code>&#39;s)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAXPY()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAYPX.html"><code>Mat/MatAYPX</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19868-L19886">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAppendOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAppendOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatAppendOptionsPrefix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAppendOptionsPrefix(petsclib::PetscLibType,A::PetscMat, prefix::Vector{Cchar})</code></pre><p>Appends to the prefix used for searching for all matrix options in the database.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - the matrix</li><li><code>prefix</code> - the prefix to prepend to all option names</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOptionsPrefix()</code>, <code>MatAppendOptionsPrefixFactor()</code>, <code>MatSetOptionsPrefix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAppendOptionsPrefix.html"><code>Mat/MatAppendOptionsPrefix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1496-L1513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAppendOptionsPrefixFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAppendOptionsPrefixFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatAppendOptionsPrefixFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAppendOptionsPrefixFactor(petsclib::PetscLibType,A::PetscMat, prefix::Vector{Cchar})</code></pre><p>Appends to the prefix used for searching for all matrix factor options in the database for for matrices created with <code>MatGetFactor()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - the matrix</li><li><code>prefix</code> - the prefix to prepend to all option names for the factored matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>PetscOptionsCreate()</code>, <code>PetscOptionsDestroy()</code>, <code>PetscObjectSetOptionsPrefix()</code>, <code>PetscObjectPrependOptionsPrefix()</code>, <code>PetscObjectGetOptionsPrefix()</code>, <code>TSAppendOptionsPrefix()</code>, <code>SNESAppendOptionsPrefix()</code>, <code>KSPAppendOptionsPrefix()</code>, <code>MatSetOptionsPrefixFactor()</code>, <code>MatSetOptionsPrefix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAppendOptionsPrefixFactor.html"><code>Mat/MatAppendOptionsPrefixFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1461-L1480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAssembled-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAssembled-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatAssembled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembled::PetscBool = MatAssembled(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Indicates if a matrix has been assembled and is ready for use; for example, in matrix-vector product.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>assembled</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatAssemblyBegin()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAssembled.html"><code>Mat/MatAssembled</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4574-L4593">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAssemblyBegin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatAssemblyType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAssemblyBegin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatAssemblyType}"><code>PETSc.LibPETSc.MatAssemblyBegin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAssemblyBegin(petsclib::PetscLibType,mat::PetscMat, type::MatAssemblyType)</code></pre><p>Begins assembling the matrix.  This routine should be called after completing all calls to <code>MatSetValues()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>type</code> - type of assembly, either <code>MAT_FLUSH_ASSEMBLY</code> or <code>MAT_FINAL_ASSEMBLY</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatAssembled()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAssemblyBegin.html"><code>Mat/MatAssemblyBegin</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4541-L4558">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatAssemblyEnd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatAssemblyType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatAssemblyEnd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatAssemblyType}"><code>PETSc.LibPETSc.MatAssemblyEnd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatAssemblyEnd(petsclib::PetscLibType,mat::PetscMat, type::MatAssemblyType)</code></pre><p>Completes assembling the matrix.  This routine should be called after <code>MatAssemblyBegin()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>type</code> - type of assembly, either <code>MAT_FLUSH_ASSEMBLY</code> or <code>MAT_FINAL_ASSEMBLY</code></li></ul><p>Options Database Keys:</p><ul><li><code>-mat_view ::ascii_info</code>             - Prints info on matrix at conclusion of <code>MatAssemblyEnd()</code></li><li><code>-mat_view ::ascii_info_detail</code>      - Prints more detailed info</li><li><code>-mat_view</code>                          - Prints matrix in ASCII format</li><li><code>-mat_view ::ascii_matlab</code>           - Prints matrix in MATLAB format</li><li><code>-mat_view draw</code>                     - draws nonzero structure of matrix, using <code>MatView()</code> and <code>PetscDrawOpenX()</code>.</li><li><code>-display &lt;name&gt;</code>                    - Sets display name (default is host)</li><li><code>-draw_pause &lt;sec&gt;</code>                  - Sets number of seconds to pause after display</li><li><code>-mat_view socket</code>                   - Sends matrix to socket, can be accessed from MATLAB (See <a href="ch_matlab">Using MATLAB with PETSc</a>)</li><li><code>-viewer_socket_machine &lt;machine&gt;</code>   - Machine to use for socket</li><li><code>-viewer_socket_port &lt;port&gt;</code>         - Port number to use for socket</li><li><code>-mat_view binary:filename[:append]</code> - Save matrix to file in binary format</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAssemblyBegin()</code>, <code>MatSetValues()</code>, <code>PetscDrawOpenX()</code>, <code>PetscDrawCreate()</code>, <code>MatView()</code>, <code>MatAssembled()</code>, <code>PetscViewerSocketOpen()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatAssemblyEnd.html"><code>Mat/MatAssemblyEnd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4611-L4641">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatBackwardSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatBackwardSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatBackwardSolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatBackwardSolve(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, x::PetscVec)</code></pre><p>Solves U x = b, given a factored matrix, A = LU. D^(1/2) U x = b, given a factored symmetric matrix, A = U^T<em>D</em>U,</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatForwardSolve()</code>, <code>MatGetFactor()</code>, <code>MatSolve()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatBackwardSolve.html"><code>Mat/MatBackwardSolve</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3349-L3369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatBindToCPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatBindToCPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatBindToCPU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatBindToCPU(petsclib::PetscLibType,A::PetscMat, flg::PetscBool)</code></pre><p>marks a matrix to temporarily stay on the CPU and perform computations on the CPU</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>flg</code> - bind to the CPU if value of <code>PETSC_TRUE</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatBoundToCPU()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatBindToCPU.html"><code>Mat/MatBindToCPU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19495-L19511">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatBlockMatSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatBlockMatSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatBlockMatSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatBlockMatSetPreallocation(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter nz (or the array nnz).  By setting these parameters accurately, performance during matrix assembly can be increased by more than a factor of 50.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>   - The matrix</li><li><code>bs</code>  - size of each block in matrix</li><li><code>nz</code>  - number of nonzeros per block row (same for all rows)</li><li><code>nnz</code> - array containing the number of nonzeros in the various block rows</li></ul><p>(possibly different for each row) or <code>NULL</code></p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateBlockMat()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatBlockMatSetPreallocation.html"><code>Mat/MatBlockMatSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14637-L14659">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatBoundToCPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatBoundToCPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatBoundToCPU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatBoundToCPU(petsclib::PetscLibType,A::PetscMat)</code></pre><p>query if a matrix is bound to the CPU</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the logical flag</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatBindToCPU()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatBoundToCPU.html"><code>Mat/MatBoundToCPU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19527-L19543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCholeskyFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCholeskyFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatCholeskyFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCholeskyFactor(petsclib::PetscLibType,mat::PetscMat, perm::IS, info::MatFactorInfo)</code></pre><p>Performs in symmetric matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>perm</code> - row and column permutations</li><li><code>info</code> - expected fill as ratio of original fill</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatFactorInfo</code>, <code>MatLUFactor()</code>, <code>MatCholeskyFactorSymbolic()</code>, <code>MatCholeskyFactorNumeric()</code> <code>MatGetOrdering()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCholeskyFactor.html"><code>Mat/MatCholeskyFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2973-L2992">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCholeskyFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCholeskyFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatCholeskyFactorNumeric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCholeskyFactorNumeric(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, info::MatFactorInfo)</code></pre><p>Performs numeric Cholesky factorization of a symmetric matrix. Call this routine after first calling <code>MatGetFactor()</code> and <code>MatCholeskyFactorSymbolic()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code>, where the factored values are stored</li><li><code>mat</code>  - the initial matrix that is to be factored</li><li><code>info</code> - options for factorization</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code>, <code>MatCholeskyFactorSymbolic()</code>, <code>MatCholeskyFactor()</code>, <code>MatLUFactorNumeric()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCholeskyFactorNumeric.html"><code>Mat/MatCholeskyFactorNumeric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3041-L3060">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCholeskyFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCholeskyFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatCholeskyFactorSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCholeskyFactorSymbolic(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, perm::IS, info::MatFactorInfo)</code></pre><p>Performs symbolic Cholesky factorization of a symmetric matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>perm</code> - row and column permutations</li><li><code>info</code> - options for factorization, includes</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactor()</code>, <code>MatCholeskyFactorNumeric()</code> <code>MatGetOrdering()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCholeskyFactorSymbolic.html"><code>Mat/MatCholeskyFactorSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3008-L3025">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeAddMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeAddMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeAddMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeAddMat(petsclib::PetscLibType,mat::PetscMat, smat::PetscMat)</code></pre><p>Add another matrix to a composite matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the composite matrix</li><li><code>smat</code> - the partial matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeGetMat()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeAddMat.html"><code>Mat/MatCompositeAddMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12483-L12499">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeGetMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeGetMat(petsclib::PetscLibType,mat::PetscMat, i::PetscInt, Ai::PetscMat)</code></pre><p>Returns the ith matrix from the composite matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the composite matrix</li><li><code>i</code>   - the number of requested matrix</li></ul><p>Output Parameter:</p><ul><li><code>Ai</code> - ith matrix in composite</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeGetNumberMat()</code>, <code>MatCompositeAddMat()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeGetMat.html"><code>Mat/MatCompositeGetMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12755-L12774">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeGetMatStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeGetMatStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><code>PETSc.LibPETSc.MatCompositeGetMatStructure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeGetMatStructure(petsclib::PetscLibType,mat::PetscMat, str::MatStructure)</code></pre><p>Returns the structure of matrices in the composite matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the composite matrix</li></ul><p>Output Parameter:</p><ul><li><code>str</code> - structure of the matrices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeSetMatStructure()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeGetMatStructure.html"><code>Mat/MatCompositeGetMatStructure</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12616-L12634">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeGetNumberMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeGetNumberMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeGetNumberMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nmat::PetscInt = MatCompositeGetNumberMat(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the number of matrices in the composite matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the composite matrix</li></ul><p>Output Parameter:</p><ul><li><code>nmat</code> - number of matrices in the composite matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeGetMat()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeGetNumberMat.html"><code>Mat/MatCompositeGetNumberMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12719-L12737">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type::MatCompositeType = MatCompositeGetType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns type of composite.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the composite matrix</li></ul><p>Output Parameter:</p><ul><li><code>type</code> - type of composite</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeSetType()</code>, <code>MATCOMPOSITE</code>, <code>MatCompositeType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeGetType.html"><code>Mat/MatCompositeGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12548-L12566">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeMerge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeMerge(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Given a composite matrix, replaces it with a &quot;regular&quot; matrix by summing or computing the product of all the matrices inside the composite matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the composite matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_composite_merge</code>      - merge in <code>MatAssemblyEnd()</code></li><li><code>-mat_composite_merge_type</code> - set merge direction</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MatMult()</code>, <code>MatCompositeAddMat()</code>, <code>MatCreateComposite()</code>, <code>MatCompositeSetMatStructure()</code>, <code>MatCompositeSetMergeType()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeMerge.html"><code>Mat/MatCompositeMerge</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12683-L12703">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeSetMatStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeSetMatStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><code>PETSc.LibPETSc.MatCompositeSetMatStructure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeSetMatStructure(petsclib::PetscLibType,mat::PetscMat, str::MatStructure)</code></pre><p>Indicates structure of matrices in the composite matrix.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the composite matrix</li><li><code>str</code> - either <code>SAME_NONZERO_PATTERN</code>, <code>DIFFERENT_NONZERO_PATTERN</code> (default) or <code>SUBSET_NONZERO_PATTERN</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAXPY()</code>, <code>MatCreateComposite()</code>, <code>MatCompositeMerge()</code> <code>MatCompositeGetMatStructure()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeSetMatStructure.html"><code>Mat/MatCompositeSetMatStructure</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12584-L12600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeSetMergeType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatCompositeMergeType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeSetMergeType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatCompositeMergeType}"><code>PETSc.LibPETSc.MatCompositeSetMergeType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeSetMergeType(petsclib::PetscLibType,mat::PetscMat, type::MatCompositeMergeType)</code></pre><p>Sets order of <code>MatCompositeMerge()</code>.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the composite matrix</li><li><code>type</code> - <code>MAT_COMPOSITE_MERGE RIGHT</code> (default) to start merge from right with the first added matrix (mat[0]),</li></ul><p><code>MAT_COMPOSITE_MERGE_LEFT</code> to start merge from left with the last added matrix (mat[nmat-1])</p><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateComposite()</code>, <code>MatCompositeMerge()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeSetMergeType.html"><code>Mat/MatCompositeSetMergeType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12650-L12667">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeSetScalings-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeSetScalings-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCompositeSetScalings</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scalings::PetscScalar = MatCompositeSetScalings(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Sets separate scaling factors for component matrices.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>      - the composite matrix</li><li><code>scalings</code> - array of scaling factors with scalings[i] being factor of i-th matrix, for i in [0, nmat)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatScale()</code>, <code>MatDiagonalScale()</code>, <code>MATCOMPOSITE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeSetScalings.html"><code>Mat/MatCompositeSetScalings</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12792-L12808">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCompositeSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatCompositeType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCompositeSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatCompositeType}"><code>PETSc.LibPETSc.MatCompositeSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCompositeSetType(petsclib::PetscLibType,mat::PetscMat, type::MatCompositeType)</code></pre><p>Indicates if the matrix is defined as the sum of a set of matrices or the product.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the composite matrix</li><li><code>type</code> - the <code>MatCompositeType</code> to use for the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MatMult()</code>, <code>MatCompositeAddMat()</code>, <code>MatCreateComposite()</code>, <code>MatCompositeGetType()</code>, <code>MATCOMPOSITE</code>, <code>MatCompositeType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCompositeSetType.html"><code>Mat/MatCompositeSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12515-L12532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatComputeBandwidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatComputeBandwidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatComputeBandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bw::PetscInt = MatComputeBandwidth(petsclib::PetscLibType,A::PetscMat, fraction::PetscReal)</code></pre><p>Calculate the full bandwidth of the matrix, meaning the width 2k+1 where k diagonals on either side are sufficient to contain all the matrix nonzeros.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>        - The <code>Mat</code></li><li><code>fraction</code> - An optional percentage of the Frobenius norm of the matrix that the bandwidth should enclose</li></ul><p>Output Parameter:</p><ul><li><code>bw</code> - The matrix bandwidth</li></ul><p>Level: beginner</p><p>-seealso: <code>DMPlexCreate()</code>, <code>DMPlexSetConeSize()</code>, <code>DMPlexSetChart()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatComputeBandwidth.html"><code>Mat/MatComputeBandwidth</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19730-L19749">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatComputeOperator-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatComputeOperator-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatComputeOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatComputeOperator(petsclib::PetscLibType,inmat::PetscMat, mattype::MatType, mat::PetscMat)</code></pre><p>Computes the explicit matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>inmat</code>   - the matrix</li><li><code>mattype</code> - the matrix type for the explicit operator</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the explicit  operator</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatConvert()</code>, <code>MatMult()</code>, <code>MatComputeOperatorTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatComputeOperator.html"><code>Mat/MatComputeOperator</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19902-L19921">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatComputeOperatorTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatComputeOperatorTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatComputeOperatorTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatComputeOperatorTranspose(petsclib::PetscLibType,inmat::PetscMat, mattype::MatType, mat::PetscMat)</code></pre><p>Computes the explicit matrix representation of a give matrix that can apply <code>MatMultTranspose()</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>inmat</code>   - the matrix</li><li><code>mattype</code> - the matrix type for the explicit operator</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the explicit  operator transposed</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatConvert()</code>, <code>MatMult()</code>, <code>MatComputeOperator()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatComputeOperatorTranspose.html"><code>Mat/MatComputeOperatorTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19939-L19959">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatComputeVariableBlockEnvelope-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatComputeVariableBlockEnvelope-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatComputeVariableBlockEnvelope</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatComputeVariableBlockEnvelope(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Given a matrix whose nonzeros are in blocks along the diagonal this computes and stores the sizes of these blocks in the matrix. An individual block may lie over several processes.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInvertVariableBlockEnvelope()</code>, <code>MatSetVariableBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatComputeVariableBlockEnvelope.html"><code>Mat/MatComputeVariableBlockEnvelope</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5919-L5935">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatConjugate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatConjugate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatConjugate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatConjugate(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>replaces the matrix values with their complex conjugates</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRealPart()</code>, <code>MatImaginaryPart()</code>, <code>VecConjugate()</code>, <code>MatTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatConjugate.html"><code>Mat/MatConjugate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1260-L1275">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatConstantDiagonalGetConstant-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatConstantDiagonalGetConstant-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatConstantDiagonalGetConstant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">value::PetscScalar = MatConstantDiagonalGetConstant(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Get the scalar constant of a constant diagonal matrix</p><p>Not collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - a <code>MATCONSTANTDIAGONAL</code></li></ul><p>Output Parameter:</p><ul><li><code>value</code> - the scalar value</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MATCONSTANTDIAGONAL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatConstantDiagonalGetConstant.html"><code>Mat/MatConstantDiagonalGetConstant</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9461-L9479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatConvert-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatConvert-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatConvert</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatConvert(petsclib::PetscLibType,mat::PetscMat, newtype::MatType, reuse::MatReuse, M::PetscMat)</code></pre><p>Converts a matrix to another matrix, either of the same or different type.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>newtype</code> - new matrix type.  Use <code>MATSAME</code> to create a new matrix of the</li></ul><p>same type as the original matrix.</p><ul><li><code>reuse</code>   - denotes if the destination matrix is to be created or reused.</li></ul><p>Use <code>MAT_INPLACE_MATRIX</code> for inplace conversion (that is when you want the input <code>Mat</code> to be changed to contain the matrix in the new format), otherwise use <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code> (can only be used after the first call was made with <code>MAT_INITIAL_MATRIX</code>, causes the matrix space in M to be reused).</p><p>Output Parameter:</p><ul><li><code>M</code> - pointer to place new matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, <code>MAT_INPLACE_MATRIX</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatConvert.html"><code>Mat/MatConvert</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3581-L3605">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCopy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCopy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatStructure}"><code>PETSc.LibPETSc.MatCopy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCopy(petsclib::PetscLibType,A::PetscMat, B::PetscMat, str::MatStructure)</code></pre><p>Copies a matrix to another matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>str</code> - <code>SAME_NONZERO_PATTERN</code> or <code>DIFFERENT_NONZERO_PATTERN</code></li></ul><p>Output Parameter:</p><ul><li><code>B</code> - where the copy is put</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatConvert()</code>, <code>MatDuplicate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCopy.html"><code>Mat/MatCopy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3546-L3565">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCopyHashToXAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCopyHashToXAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCopyHashToXAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCopyHashToXAIJ(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>copy hash table entries into an XAIJ matrix type</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - A matrix in unassembled, hash table form</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - The XAIJ matrix. This can either be <code>A</code> or some matrix of equivalent size, e.g. obtained from <code>A</code> via <code>MatDuplicate()</code></li></ul><p>Example: -seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_USE_HASH_TABLE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCopyHashToXAIJ.html"><code>Mat/MatCopyHashToXAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L797-L814">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><code>PETSc.LibPETSc.MatCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreate(petsclib::PetscLibType,comm::MPI_Comm)</code></pre><p>Creates a matrix where the type is determined from either a call to <code>MatSetType()</code> or from the options database with a call to <code>MatSetFromOptions()</code>.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>comm</code> - MPI communicator</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_type seqaij</code>   - <code>MATSEQAIJ</code> type, uses <code>MatCreateSeqAIJ()</code></li><li><code>-mat_type mpiaij</code>   - <code>MATMPIAIJ</code> type, uses <code>MatCreateAIJ()</code></li><li><code>-mat_type seqdense</code> - <code>MATSEQDENSE</code>, uses <code>MatCreateSeqDense()</code></li><li><code>-mat_type mpidense</code> - <code>MATMPIDENSE</code> type, uses <code>MatCreateDense()</code></li><li><code>-mat_type seqbaij</code>  - <code>MATSEQBAIJ</code> type, uses <code>MatCreateSeqBAIJ()</code></li><li><code>-mat_type mpibaij</code>  - <code>MATMPIBAIJ</code> type, uses <code>MatCreateBAIJ()</code></li></ul><p>See the manpages for particular formats (e.g., <code>MATSEQAIJ</code>) for additional format-specific options.</p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqAIJ()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqDense()</code>, <code>MatCreateDense()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatCreateSBAIJ()</code>, <code>MatConvert()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreate.html"><code>Mat/MatCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19174-L19209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateAIJ(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix in <code>MATAIJ</code> format (the default parallel PETSc format).  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameters <code>d_nz</code> (or <code>d_nnz</code>) and <code>o_nz</code> (or <code>o_nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if M is given). This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>     - This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if N is given) For square matrices n is almost always m.</li><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if m is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if n is given)</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix (same value is used for all local rows)</li><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;.</li><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local submatrix (same value is used for all local rows).</li><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_inode</code>                     - Do not use inodes</li><li><code>-mat_inode_limit &lt;limit&gt;</code>          - Sets inode limit (max limit=5)</li><li><code>-matmult_vecscatter_view &lt;viewer&gt;</code> - View the vecscatter (i.e., communication pattern) used in <code>MatMult()</code> of sparse parallel matrices.</li></ul><p>See viewer types in manual of <code>MatView()</code>. Of them, ascii_matlab, draw or binary cause the <code>VecScatter</code> to be viewed as a matrix. Entry (i,j) is the size of message (in bytes) rank i sends to rank j in one <code>MatMult()</code> call.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateMPIAIJWithArrays()</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateAIJ.html"><code>Mat/MatCreateAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15745-L15783">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateAIJKokkos-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateAIJKokkos-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateAIJKokkos</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateAIJKokkos(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateAIJKokkos.html"><code>Mat/MatCreateAIJKokkos</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16211-L16216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateAIJViennaCL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateAIJViennaCL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateAIJViennaCL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateAIJViennaCL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateAIJViennaCL.html"><code>Mat/MatCreateAIJViennaCL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17179-L17184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateBAIJ(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Union{Ptr,Vector{PetscInt}}, o_nz::PetscInt, o_nnz::Union{Ptr,Vector{PetscInt}})</code></pre><p>Creates a sparse parallel matrix in <code>MATBAIJ</code> format (block compressed row).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>bs</code>    - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if M is given). This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>     - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if N is given). This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax.</li><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if m is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if n is given)</li><li><code>d_nz</code>  - number of nonzero blocks per block row in diagonal portion of local submatrix  (same for all local rows)</li><li><code>d_nnz</code> - array containing the number of nonzero blocks in the various block rows of the in diagonal portion of the local (possibly different for each block row) or NULL.  If you plan to factor the matrix you must leave room for the diagonal entry and set it even if it is zero.</li><li><code>o_nz</code>  - number of nonzero blocks per block row in the off-diagonal portion of local submatrix (same for all local rows).</li><li><code>o_nnz</code> - array containing the number of nonzero blocks in the various block rows of the off-diagonal portion of the local submatrix (possibly different for each block row) or NULL.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_block_size</code>            - size of the blocks to use</li><li><code>-mat_use_hash_table &lt;fact&gt;</code> - set hash table factor</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatMPIBAIJSetPreallocationCSR()</code>, <code>MatGetOwnershipRange()</code>,  <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateBAIJ.html"><code>Mat/MatCreateBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9583-L9616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateBAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateBAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateBAIJMKL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateBAIJMKL(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix in <code>MATBAIJMKL</code> format (block compressed row).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>bs</code>    - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given) This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>     - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax.</li><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_nz</code>  - number of nonzero blocks per block row in diagonal portion of local submatrix  (same for all local rows)</li><li><code>d_nnz</code> - array containing the number of nonzero blocks in the various block rows of the in diagonal portion of the local (possibly different for each block row) or <code>NULL</code>.  If you plan to factor the matrix you must leave room for the diagonal entry and set it even if it is zero.</li><li><code>o_nz</code>  - number of nonzero blocks per block row in the off-diagonal portion of local submatrix (same for all local rows).</li><li><code>o_nnz</code> - array containing the number of nonzero blocks in the various block rows of the off-diagonal portion of the local submatrix (possibly different for each block row) or <code>NULL</code>.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_block_size</code>            - size of the blocks to use</li><li><code>-mat_use_hash_table &lt;fact&gt;</code> - set hash table factor</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATBAIJMKL</code>, <code>MATBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqBAIJMKL()</code>, <code>MatSetValues()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatMPIBAIJSetPreallocationCSR()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateBAIJMKL.html"><code>Mat/MatCreateBAIJMKL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9739-L9770">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateBlockMat-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateBlockMat-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateBlockMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateBlockMat(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, bs::PetscInt, nz::PetscInt, nnz::Union{Ptr,Vector{PetscInt}})</code></pre><p>Creates a new matrix in which each block contains a uniform</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>bs</code>   - size of each submatrix</li><li><code>nz</code>   - expected maximum number of nonzero blocks in row (use <code>PETSC_DEFAULT</code> if not known)</li><li><code>nnz</code>  - expected number of nonzers per block row if known (use <code>NULL</code> otherwise)</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATBLOCKMAT</code>, <code>MatCreateNest()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateBlockMat.html"><code>Mat/MatCreateBlockMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14675-L14698">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateCentering-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateCentering-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateCentering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">C::PetscMat = MatCreateCentering(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a new matrix object that implements the (symmetric and idempotent) centering matrix,  I</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) This value should be the same as the local size used in creating the <code>y</code> vector for the matrix-vector product y = Ax.</li><li><code>N</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li></ul><p>Output Parameter:</p><ul><li><code>C</code> - the matrix</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateLRC()</code>, <code>MatCreateComposite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateCentering.html"><code>Mat/MatCreateCentering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14288-L14306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateComposite-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateComposite-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64}"><code>PETSc.LibPETSc.MatCreateComposite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mats::PetscMat,mat::PetscMat = MatCreateComposite(petsclib::PetscLibType,comm::MPI_Comm, nmat::PetscInt)</code></pre><p>Creates a matrix as the sum or product of one or more matrices</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>nmat</code> - number of matrices to put in</li><li><code>mats</code> - the matrices</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_composite_merge</code>       - merge in <code>MatAssemblyEnd()</code></li><li><code>-mat_composite_merge_mvctx</code> - merge Mvctx of component matrices to optimize communication in <code>MatMult()</code> for ADDITIVE matrices</li><li><code>-mat_composite_merge_type</code>  - set merge direction</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MatMult()</code>, <code>MatCompositeAddMat()</code>, <code>MatCompositeGetMat()</code>, <code>MatCompositeMerge()</code>, <code>MatCompositeSetType()</code>, <code>MATCOMPOSITE</code>, <code>MatCompositeType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateComposite.html"><code>Mat/MatCreateComposite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12437-L12463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateConstantDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateConstantDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Float64}"><code>PETSc.LibPETSc.MatCreateConstantDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateConstantDiagonal(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, diag::PetscScalar)</code></pre><p>Creates a matrix with a uniform value along the diagonal</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given). This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>    - This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices n is almost always <code>m</code>.</li><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if m is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if n is given)</li><li><code>diag</code> - the diagonal value</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - the diagonal matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MATCONSTANTDIAGONAL</code>, <code>MatScale()</code>, <code>MatShift()</code>, <code>MatMult()</code>, <code>MatGetDiagonal()</code>, <code>MatGetFactor()</code>, <code>MatSolve()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateConstantDiagonal.html"><code>Mat/MatCreateConstantDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9420-L9443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateDense-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Float64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateDense-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Float64}}}"><code>PETSc.LibPETSc.MatCreateDense</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateDense(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, data::Union{Ptr,Vector{PetscScalar}})</code></pre><p>Creates a matrix in <code>MATDENSE</code> format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li><li><code>n</code>    - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given)</li><li><code>M</code>    - number of global rows (or <code>PETSC_DECIDE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DECIDE</code> to have calculated if <code>n</code> is given)</li><li><code>data</code> - optional location of matrix data.  Set data to <code>NULL</code> (<code>PETSC_NULL_SCALAR_ARRAY</code> for Fortran users) for PETSc to control all matrix memory allocation.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatCreate()</code>, <code>MatCreateSeqDense()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateDense.html"><code>Mat/MatCreateDense</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11442-L11465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateDenseFromVecType-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Ptr{Int8}, Vararg{Int64, 5}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateDenseFromVecType-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Ptr{Int8}, Vararg{Int64, 5}}"><code>PETSc.LibPETSc.MatCreateDenseFromVecType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data::PetscScalar,A::PetscMat = MatCreateDenseFromVecType(petsclib::PetscLibType,comm::MPI_Comm, vtype::VecType, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, lda::PetscInt)</code></pre><p>Create a matrix that matches the type of a Vec.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - the communicator</li><li><code>vtype</code> - the vector type</li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li><li><code>n</code>     - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given)</li><li><code>M</code>     - number of global rows (or <code>PETSC_DECIDE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DECIDE</code> to have calculated if <code>n</code> is given)</li><li><code>lda</code>   - optional leading dimension. Pass any non-positive number to use the default.</li><li><code>data</code>  - optional location of matrix data, which should have the same memory type as the vector. Pass <code>NULL</code> to have PETSc take care of matrix memory allocation.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the dense matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateDense()</code>, <code>MatCreateDenseCUDA()</code>, <code>MatCreateDenseHIP()</code>, <code>PetscMemType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateDenseFromVecType.html"><code>Mat/MatCreateDenseFromVecType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18798-L18823">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatCreateDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateDiagonal(petsclib::PetscLibType,diag::PetscVec)</code></pre><p>Creates a matrix defined by a given vector along its diagonal.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>diag</code> - vector for the diagonal</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - the diagonal matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>MATCONSTANTDIAGONAL</code>, <code>MatScale()</code>, <code>MatShift()</code>, <code>MatMult()</code>, <code>MatGetDiagonal()</code>, <code>MatSolve()</code> <code>MatDiagonalRestoreInverseDiagonal()</code>, <code>MatDiagonalGetDiagonal()</code>, <code>MatDiagonalRestoreDiagonal()</code>, <code>MatDiagonalGetInverseDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateDiagonal.html"><code>Mat/MatCreateDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14456-L14475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateFFT-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Vector{Int64}, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateFFT-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Vector{Int64}, Ptr{Int8}}"><code>PETSc.LibPETSc.MatCreateFFT</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateFFT(petsclib::PetscLibType,comm::MPI_Comm, ndim::PetscInt, dim::Vector{PetscInt}, mattype::MatType)</code></pre><p>Creates a matrix object that provides FFT via an external package</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>    - MPI communicator</li><li><code>ndim</code>    - the ndim-dimensional transform</li><li><code>dim</code>     - array of size ndim, dim[i] contains the vector length in the i-dimension</li><li><code>mattype</code> - package type, e.g., <code>MATFFTW</code> or <code>MATSEQCUFFT</code></li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_fft_type</code> - set FFT type fft or seqcufft</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATFFTW</code>, <code>MATSEQCUFFT</code>, <code>MatCreateVecsFFTW()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateFFT.html"><code>Mat/MatCreateFFT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14716-L14740">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vector{Int8}, Vararg{Int64, 5}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vector{Int8}, Vararg{Int64, 5}}"><code>PETSc.LibPETSc.MatCreateFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateFromOptions(petsclib::PetscLibType,comm::MPI_Comm, prefix::Vector{Cchar}, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt)</code></pre><p>Creates a matrix whose type is set from the options database</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - MPI communicator</li><li><code>prefix</code> - [optional] prefix for the options database</li><li><code>bs</code>     - the blocksize (commonly 1)</li><li><code>m</code>      - the local number of rows (or <code>PETSC_DECIDE</code>)</li><li><code>n</code>      - the local number of columns (or <code>PETSC_DECIDE</code> or <code>PETSC_DETERMINE</code>)</li><li><code>M</code>      - the global number of rows (or <code>PETSC_DETERMINE</code>)</li><li><code>N</code>      - the global number of columns (or <code>PETSC_DETERMINE</code>)</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_type</code> - see <code>MatType</code>, for example <code>aij</code>, <code>aijcusparse</code>, <code>baij</code>, <code>sbaij</code>, <code>dense</code>, defaults to <code>aij</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqAIJ()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqDense()</code>, <code>MatCreateDense()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatCreateSBAIJ()</code>, <code>MatConvert()</code>, <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateFromOptions.html"><code>Mat/MatCreateFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19227-L19258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateGraph-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool, Float64, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateGraph-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool, Float64, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">graph::PetscMat = MatCreateGraph(petsclib::PetscLibType,A::PetscMat, sym::PetscBool, scale::PetscBool, filter::PetscReal, num_idx::PetscInt, index::Vector{PetscInt})</code></pre><p>create a scalar matrix (that is a matrix with one vertex for each block vertex in the original matrix), for use in graph algorithms and possibly removes small values from the graph structure.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>       - the matrix</li><li><code>sym</code>     - <code>PETSC_TRUE</code> indicates that the graph should be symmetrized</li><li><code>scale</code>   - <code>PETSC_TRUE</code> indicates that the graph edge weights should be symmetrically scaled with the diagonal entry</li><li><code>filter</code>  - filter value - &lt; 0: does nothing; == 0: removes only 0.0 entries; otherwise: removes entries with abs(entries) &lt;= value</li><li><code>num_idx</code> - size of &#39;index&#39; array</li><li><code>index</code>   - array of block indices to use for graph strength of connection weight</li></ul><p>Output Parameter:</p><ul><li><code>graph</code> - the resulting graph</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>PCGAMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateGraph.html"><code>Mat/MatCreateGraph</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8723-L8747">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateHermitianTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">N::PetscMat = MatCreateHermitianTranspose(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Creates a new matrix object of <code>MatType</code> <code>MATHERMITIANTRANSPOSEVIRTUAL</code> that behaves like A&#39;*</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the (possibly rectangular) matrix</li></ul><p>Output Parameter:</p><ul><li><code>N</code> - the matrix that represents A&#39;*</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatMultHermitianTranspose()</code>, <code>MatCreate()</code>, <code>MATTRANSPOSEVIRTUAL</code>, <code>MatCreateTranspose()</code>, <code>MatHermitianTransposeGetMat()</code>, <code>MATNORMAL</code>, <code>MATNORMALHERMITIAN</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateHermitianTranspose.html"><code>Mat/MatCreateHermitianTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11161-L11180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateHtoolFromKernel-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateHtoolFromKernel-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateHtoolFromKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kernel::MatHtoolKernelFn,kernelctx::Cvoid,B::PetscMat = MatCreateHtoolFromKernel(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, spacedim::PetscInt, coords_target::Vector{PetscReal}, coords_source::Vector{PetscReal})</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateHtoolFromKernel.html"><code>Mat/MatCreateHtoolFromKernel</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14909-L14914">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateIS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateIS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><code>PETSc.LibPETSc.MatCreateIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateIS(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, rmap::ISLocalToGlobalMapping, cmap::ISLocalToGlobalMapping)</code></pre><p>Creates a &quot;process&quot; unassembled matrix.</p><p>Collective.</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator that will share the matrix</li><li><code>bs</code>   - block size of the matrix</li><li><code>m</code>    - local size of left vector used in matrix vector products</li><li><code>n</code>    - local size of right vector used in matrix vector products</li><li><code>M</code>    - global size of left vector used in matrix vector products</li><li><code>N</code>    - global size of right vector used in matrix vector products</li><li><code>rmap</code> - local to global map for rows</li><li><code>cmap</code> - local to global map for cols</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the resulting matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatSetLocalToGlobalMapping()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateIS.html"><code>Mat/MatCreateIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11047-L11072">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateKAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Float64}}, Union{Ptr, Vector{Float64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateKAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Float64}}, Union{Ptr, Vector{Float64}}}"><code>PETSc.LibPETSc.MatCreateKAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kaij::PetscMat = MatCreateKAIJ(petsclib::PetscLibType,A::PetscMat, p::PetscInt, q::PetscInt, S::Vector{PetscScalar}, T::Vector{PetscScalar})</code></pre><p>Creates a matrix of type <code>MATKAIJ</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATAIJ</code> matrix</li><li><code>p</code> - number of rows in <code>S</code> and <code>T</code></li><li><code>q</code> - number of columns in <code>S</code> and <code>T</code></li><li><code>S</code> - the <code>S</code> matrix (can be <code>NULL</code>), stored as a <code>PetscScalar</code> array (column-major)</li><li><code>T</code> - the <code>T</code> matrix (can be <code>NULL</code>), stored as a <code>PetscScalar</code> array (column-major)</li></ul><p>Output Parameter:</p><ul><li><code>kaij</code> - the new <code>MATKAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatKAIJSetAIJ()</code>, <code>MatKAIJSetS()</code>, <code>MatKAIJSetT()</code>, <code>MatKAIJGetAIJ()</code>, <code>MatKAIJGetS()</code>, <code>MatKAIJGetT()</code>, <code>MATKAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateKAIJ.html"><code>Mat/MatCreateKAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13953-L13975">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMBFGS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMBFGS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMBFGS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMBFGS(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited matrix used for approximating Jacobians. L-BFGS is symmetric positive-definite by construction, and is commonly used to approximate Hessians in optimization problems.</p><p>To use the L-BFGS matrix with other vector types, the matrix must be created using <code>MatCreate()</code> and <code>MatSetType()</code>, followed by <code>MatLMVMAllocate()</code>. This ensures that the internal storage and work vectors are duplicated from the correct type of vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_scale_type</code> - (developer) type of scaling applied to J0 (none, scalar, diagonal)</li><li><code>-mat_lmvm_theta</code>      - (developer) convex ratio between BFGS and DFP components of the diagonal J0 scaling</li><li><code>-mat_lmvm_rho</code>        - (developer) update limiter for the J0 scaling</li><li><code>-mat_lmvm_alpha</code>      - (developer) coefficient factor for the quadratic subproblem in J0 scaling</li><li><code>-mat_lmvm_beta</code>       - (developer) exponential factor for the diagonal J0 scaling</li><li><code>-mat_lmvm_sigma_hist</code> - (developer) number of past updates to use in J0 scaling</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMBFGS</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMBadBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMBFGS.html"><code>Ksp/MatCreateLMVMBFGS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21766-L21803">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMBadBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMBadBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMBadBroyden</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMBadBroyden(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited approximation matrix used for a Jacobian. L-BadBrdn is not guaranteed to be symmetric or positive-definite.</p><p>To use the L-BadBrdn matrix with other vector types, the matrix must be created using <code>MatCreate()</code> and <code>MatSetType()</code>, followed by <code>MatLMVMAllocate()</code>. This ensures that the internal storage and work vectors are duplicated from the correct type of vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_hist_size</code>         - the number of history vectors to keep</li><li><code>-mat_lmvm_mult_algorithm</code>    - the algorithm to use for multiplication (recursive, dense, compact_dense)</li><li><code>-mat_lmvm_cache_J0_products</code> - whether products between the base Jacobian J0 and history vectors should be cached or recomputed</li><li><code>-mat_lmvm_debug</code>             - (developer) perform internal debugging checks</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMBADBRDN</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMBadBroyden.html"><code>Ksp/MatCreateLMVMBadBroyden</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21453-L21487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMBroyden</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMBroyden(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited matrix used for a Jacobian. L-Brdn is not guaranteed to be symmetric or positive-definite.</p><p>To use the L-Brdn matrix with other vector types, the matrix must be created using <code>MatCreate()</code> and <code>MatSetType()</code>, followed by <code>MatLMVMAllocate()</code>. This ensures that the internal storage and work vectors are duplicated from the correct type of vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_hist_size</code>         - the number of history vectors to keep</li><li><code>-mat_lmvm_mult_algorithm</code>    - the algorithm to use for multiplication (recursive, dense, compact_dense)</li><li><code>-mat_lmvm_cache_J0_products</code> - whether products between the base Jacobian J0 and history vectors should be cached or recomputed</li><li><code>-mat_lmvm_debug</code>             - (developer) perform internal debugging checks</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMBRDN</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMBadBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMBroyden.html"><code>Ksp/MatCreateLMVMBroyden</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21505-L21539">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMDBFGS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMDBFGS-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMDBFGS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMDBFGS(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a dense representation of the limited Broyden-Fletcher-Goldfarb-Shanno (BFGS) approximation to a Hessian.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMDBFGS</code>, <code>MatCreateLMVMBFGS()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMDBFGS.html"><code>Ksp/MatCreateLMVMDBFGS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21596-L21617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMDDFP-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMDDFP-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMDDFP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMDDFP(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a dense representation of the limited Davidon-Fletcher-Powell (DFP) approximation to a Hessian.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMDDFP</code>, <code>MatCreateLMVMDFP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMDDFP.html"><code>Ksp/MatCreateLMVMDDFP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21635-L21656">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMDFP-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMDFP-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMDFP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMDFP(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited used for approximating Jacobians. L-DFP is symmetric positive-definite by construction, and is the dual of L-BFGS where Y and S vectors swap roles.</p><p>To use the L-DFP matrix with other vector types, the matrix must be created using <code>MatCreate()</code> and <code>MatSetType()</code>, followed by <code>MatLMVMAllocate()</code>. This ensures that the internal storage and work vectors are duplicated from the correct type of vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_scale_type</code> - (developer) type of scaling applied to J0 (none, scalar, diagonal)</li><li><code>-mat_lmvm_theta</code>      - (developer) convex ratio between BFGS and DFP components of the diagonal J0 scaling</li><li><code>-mat_lmvm_rho</code>        - (developer) update limiter for the J0 scaling</li><li><code>-mat_lmvm_alpha</code>      - (developer) coefficient factor for the quadratic subproblem in J0 scaling</li><li><code>-mat_lmvm_beta</code>       - (developer) exponential factor for the diagonal J0 scaling</li><li><code>-mat_lmvm_sigma_hist</code> - (developer) number of past updates to use in J0 scaling</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMDFP</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMBadBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMDFP.html"><code>Ksp/MatCreateLMVMDFP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22144-L22180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMDQN-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMDQN-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMDQN</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMDQN(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a dense representation of the limited Quasi-Newton approximation to a Hessian.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMDBFGS</code>, <code>MATLMVMDDFP</code>, <code>MatCreateLMVMDDFP()</code>, <code>MatCreateLMVMDBFGS()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMDQN.html"><code>Ksp/MatCreateLMVMDQN</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21557-L21578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMDiagBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMDiagBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMDiagBroyden</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMDiagBroyden(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>DiagBrdn creates a symmetric Broyden for approximating Hessians.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_theta</code>      - (developer) convex ratio between BFGS and DFP components of the diagonal J0 scaling</li><li><code>-mat_lmvm_rho</code>        - (developer) update limiter for the J0 scaling</li><li><code>-mat_lmvm_alpha</code>      - (developer) coefficient factor for the quadratic subproblem in J0 scaling</li><li><code>-mat_lmvm_beta</code>       - (developer) exponential factor for the diagonal J0 scaling</li><li><code>-mat_lmvm_sigma_hist</code> - (developer) number of past updates to use in J0 scaling.</li><li><code>-mat_lmvm_tol</code>        - (developer) tolerance for bounding the denominator of the rescaling away from 0.</li><li><code>-mat_lmvm_forward</code>    - (developer) whether or not to use the forward or backward Broyden update to the diagonal</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMDIAGBRDN</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMDiagBroyden.html"><code>Ksp/MatCreateLMVMDiagBroyden</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21404-L21435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMSR1-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMSR1-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMSR1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMSR1(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited matrix used for a Jacobian. L-SR1 is symmetric by construction, but is not guaranteed to be positive-definite.</p><p>To use the L-SR1 matrix with other vector types, the matrix must be created using <code>MatCreate()</code> and <code>MatSetType()</code>, followed by <code>MatLMVMAllocate()</code>. This ensures that the internal storage and work vectors are duplicated from the correct type of vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_hist_size</code>         - the number of history vectors to keep</li><li><code>-mat_lmvm_mult_algorithm</code>    - the algorithm to use for multiplication (recursive, dense, compact_dense)</li><li><code>-mat_lmvm_cache_J0_products</code> - whether products between the base Jacobian J0 and history vectors should be cached or recomputed</li><li><code>-mat_lmvm_eps</code>               - (developer) numerical zero tolerance for testing when an update should be skipped</li><li><code>-mat_lmvm_debug</code>             - (developer) perform internal debugging checks</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMSR1</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMBadBroyden()</code>, <code>MatCreateLMVMSymBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMSR1.html"><code>Ksp/MatCreateLMVMSR1</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21713-L21748">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMSymBadBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMSymBadBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMSymBadBroyden</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMSymBadBroyden(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited for approximating Jacobians.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_hist_size</code>         - the number of history vectors to keep</li><li><code>-mat_lmvm_psi</code>               - convex ratio between BFGS and DFP components of the update</li><li><code>-mat_lmvm_scale_type</code>        - type of scaling applied to J0 (none, scalar, diagonal)</li><li><code>-mat_lmvm_mult_algorithm</code>    - the algorithm to use for multiplication (recursive, dense, compact_dense)</li><li><code>-mat_lmvm_cache_J0_products</code> - whether products between the base Jacobian J0 and history vectors should be cached or recomputed</li><li><code>-mat_lmvm_eps</code>               - (developer) numerical zero tolerance for testing when an update should be skipped</li><li><code>-mat_lmvm_debug</code>             - (developer) perform internal debugging checks</li><li><code>-mat_lmvm_theta</code>             - (developer) convex ratio between BFGS and DFP components of the diagonal J0 scaling</li><li><code>-mat_lmvm_rho</code>               - (developer) update limiter for the J0 scaling</li><li><code>-mat_lmvm_alpha</code>             - (developer) coefficient factor for the quadratic subproblem in J0 scaling</li><li><code>-mat_lmvm_beta</code>              - (developer) exponential factor for the diagonal J0 scaling</li><li><code>-mat_lmvm_sigma_hist</code>        - (developer) number of past updates to use in J0 scaling</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMSYMBROYDEN</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMBadBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMSymBadBroyden.html"><code>Ksp/MatCreateLMVMSymBadBroyden</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22090-L22126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLMVMSymBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLMVMSymBroyden-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateLMVMSymBroyden</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateLMVMSymBroyden(petsclib::PetscLibType,comm::MPI_Comm, n::PetscInt, N::PetscInt)</code></pre><p>Creates a limited for approximating Jacobians.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>n</code>    - number of local rows for storage vectors</li><li><code>N</code>    - global size of the storage vectors</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lmvm_hist_size</code>         - the number of history vectors to keep</li><li><code>-mat_lmvm_phi</code>               - convex ratio between BFGS and DFP components of the update</li><li><code>-mat_lmvm_scale_type</code>        - type of scaling applied to J0 (none, scalar, diagonal)</li><li><code>-mat_lmvm_mult_algorithm</code>    - the algorithm to use for multiplication (recursive, dense, compact_dense)</li><li><code>-mat_lmvm_cache_J0_products</code> - whether products between the base Jacobian J0 and history vectors should be cached or recomputed</li><li><code>-mat_lmvm_eps</code>               - (developer) numerical zero tolerance for testing when an update should be skipped</li><li><code>-mat_lmvm_debug</code>             - (developer) perform internal debugging checks</li><li><code>-mat_lmvm_theta</code>             - (developer) convex ratio between BFGS and DFP components of the diagonal J0 scaling</li><li><code>-mat_lmvm_rho</code>               - (developer) update limiter for the J0 scaling</li><li><code>-mat_lmvm_alpha</code>             - (developer) coefficient factor for the quadratic subproblem in J0 scaling</li><li><code>-mat_lmvm_beta</code>              - (developer) exponential factor for the diagonal J0 scaling</li><li><code>-mat_lmvm_sigma_hist</code>        - (developer) number of past updates to use in J0 scaling</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreate()</code>, <code>MATLMVM</code>, <code>MATLMVMSYMBROYDEN</code>, <code>MatCreateLMVMDFP()</code>, <code>MatCreateLMVMSR1()</code>, <code>MatCreateLMVMBFGS()</code>, <code>MatCreateLMVMBroyden()</code>, <code>MatCreateLMVMBadBroyden()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateLMVMSymBroyden.html"><code>Ksp/MatCreateLMVMSymBroyden</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22036-L22072">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLRC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscVec}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLRC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscVec}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateLRC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">N::PetscMat = MatCreateLRC(petsclib::PetscLibType,A::PetscMat, U::PetscMat, c::PetscVec, V::PetscMat)</code></pre><p>Creates a new matrix object that behaves like A + U<em>C</em>V&#39; of type <code>MATLRC</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the (sparse) matrix (can be <code>NULL</code>)</li><li><code>U</code> - dense rectangular (tall and skinny) matrix</li><li><code>V</code> - dense rectangular (tall and skinny) matrix</li><li><code>c</code> - a vector containing the diagonal of C (can be <code>NULL</code>)</li></ul><p>Output Parameter:</p><ul><li><code>N</code> - the matrix that represents A + U<em>C</em>V&#39;</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATLRC</code>, <code>MatLRCGetMats()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateLRC.html"><code>Mat/MatCreateLRC</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12906-L12927">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLaplacian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLaplacian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatCreateLaplacian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">L::PetscMat = MatCreateLaplacian(petsclib::PetscLibType,A::PetscMat, tol::PetscReal, weighted::PetscBool)</code></pre><p>Create the matrix Laplacian, with all values in the matrix less than the tolerance set to zero</p><p>Input Parameters:</p><ul><li><code>A</code>        - The matrix</li><li><code>tol</code>      - The zero tolerance</li><li><code>weighted</code> - Flag for using edge weights</li></ul><p>Output Parameter:</p><ul><li><code>L</code> - The graph Laplacian matrix</li></ul><p>Level: intermediate</p><p>-seealso: <code>MatFilter()</code>, <code>MatGetGraph()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateLaplacian.html"><code>Mat/MatCreateLaplacian</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20501-L20519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateLocalRef-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateLocalRef-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatCreateLocalRef</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newmat::PetscMat = MatCreateLocalRef(petsclib::PetscLibType,A::PetscMat, isrow::IS, iscol::IS)</code></pre><p>Gets a logical reference to a local submatrix, for use in assembly, that is to set values into the matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - full matrix, generally parallel</li><li><code>isrow</code> - Local index set for the rows</li><li><code>iscol</code> - Local index set for the columns</li></ul><p>Output Parameter:</p><ul><li><code>newmat</code> - new serial <code>Mat</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSUBMATRIX</code>, <code>MatCreateSubMatrixVirtual()</code>, <code>MatSetValuesLocal()</code>, <code>MatSetValuesBlockedLocal()</code>, <code>MatGetLocalSubMatrix()</code>, <code>MatCreateSubMatrix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateLocalRef.html"><code>Mat/MatCreateLocalRef</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10221-L10241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatCreateMAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maij::PetscMat = MatCreateMAIJ(petsclib::PetscLibType,A::PetscMat, dof::PetscInt)</code></pre><p>Creates a matrix type providing restriction and interpolation operations for multicomponent problems.  It interpolates each component the same way independently.  The matrix type is based on <code>MATSEQAIJ</code> for sequential matrices, and <code>MATMPIAIJ</code> for distributed matrices.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>MATAIJ</code> matrix describing the action on blocks</li><li><code>dof</code> - the block size (number of components per node)</li></ul><p>Output Parameter:</p><ul><li><code>maij</code> - the new <code>MATMAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATAIJ</code>, <code>MATMAIJ</code>, <code>MatMAIJGetAIJ()</code>, <code>MatMAIJRedimension()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMAIJ.html"><code>Mat/MatCreateMAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10693-L10715">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMFFD-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMFFD-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 4}}"><code>PETSc.LibPETSc.MatCreateMFFD</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateMFFD(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt)</code></pre><p>Creates a matrix approximately multiply a vector by the matrix (Jacobian) . See also <code>MatCreateSNESMF()</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given). This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>    - This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</li><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - the matrix-free matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_mffd_type</code>             - wp or ds (see <code>MATMFFD_WP</code> or <code>MATMFFD_DS</code>)</li><li><code>-mat_mffd_err</code>              - square root of estimated relative error in function evaluation</li><li><code>-mat_mffd_period</code>           - how often h is recomputed, defaults to 1, every time</li><li><code>-mat_mffd_check_positivity</code> - possibly decrease <code>h</code> until U + h*a has only positive values</li><li><code>-mat_mffd_umin &lt;umin&gt;</code>      - Sets umin (for default PETSc routine that computes h only)</li><li><code>-mat_mffd_complex</code>          - use the Lyness trick with complex numbers to compute the matrix-vector product instead of differencing (requires real valued functions but that PETSc be configured for complex numbers)</li><li><code>-snes_mf</code>                   - use the finite difference based matrix-free matrix with <code>SNESSolve()</code> and no preconditioner</li><li><code>-snes_mf_operator</code>          - use the finite difference based matrix-free matrix with <code>SNESSolve()</code> but construct a preconditioner</li></ul><p>using the matrix passed as <code>pmat</code> to <code>SNESSetJacobian()</code>.</p><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatDestroy()</code>, <code>MatMFFDSetFunctionError()</code>, <code>MatMFFDDSSetUmin()</code>, <code>MatMFFDSetFunction()</code> <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code>, <code>MatCreateSNESMF()</code>, <code>MatCreateShell()</code>, <code>MATSHELL</code>, <code>MatMFFDGetH()</code>, <code>MatMFFDRegister()</code>, <code>MatMFFDComputeJacobian()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMFFD.html"><code>Mat/MatCreateMFFD</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12945-L12981">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJCRL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJCRL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateMPIAIJCRL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateMPIAIJCRL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt}, onz::PetscInt, onnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATMPIAIJCRL</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows), for the &quot;diagonal&quot; submatrix</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows (possibly different for each row) or <code>NULL</code>, for the &quot;diagonal&quot; submatrix</li><li><code>onz</code>  - number of nonzeros per row (same for all rows), for the &quot;off-diagonal&quot; submatrix</li><li><code>onnz</code> - array containing the number of nonzeros in the various rows (possibly different for each row) or <code>NULL</code>, for the &quot;off-diagonal&quot; submatrix</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MATAIJ</code>, <code>MATAIJSELL</code>, <code>MATAIJPERM</code>, <code>MATAIJMKL</code>, <code>MatCreate()</code>, <code>MatCreateMPIAIJPERM()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJCRL.html"><code>Mat/MatCreateMPIAIJCRL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16169-L16193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateMPIAIJMKL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateMPIAIJMKL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix whose local portions are stored as <code>MATSEQAIJMKL</code> matrices (a matrix class that inherits from <code>MATSEQAIJ</code> but uses some operations provided by Intel MKL).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li></ul><p>This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</p><ul><li><code>n</code>     - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if N is given) For square matrices n is almost always <code>m</code>.</p><ul><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>. For matrices you plan to factor you must leave room for the diagonal entry and put in the entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_aijmkl_no_spmv2</code> - disables use of the SpMV2 inspector-executor routines</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MATMPIAIJMKL</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJMKL()</code>, <code>MatSetValues()</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJMKL.html"><code>Mat/MatCreateMPIAIJMKL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16234-L16282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJPERM-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJPERM-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateMPIAIJPERM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateMPIAIJPERM(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix whose local portions are stored as <code>MATSEQAIJPERM</code> matrices (a matrix class that inherits from SEQAIJ but includes some optimizations to allow more effective vectorization).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li></ul><p>This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</p><ul><li><code>n</code>     - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product y = Ax. (or PETSC_DECIDE to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</p><ul><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>. For matrices you plan to factor you must leave room for the diagonal entry and put in the entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_inode</code>            - Do not use inodes</li><li><code>-mat_inode_limit &lt;limit&gt;</code> - Sets inode limit (max limit=5)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MATMPIAIJPERM</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJPERM()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJPERM.html"><code>Mat/MatCreateMPIAIJPERM</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17225-L17273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateMPIAIJSELL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateMPIAIJSELL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix whose local portions are stored as <code>MATSEQAIJSELL</code> matrices (a matrix class that inherits from SEQAIJ but performs some operations in SELL format).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li></ul><p>This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</p><ul><li><code>n</code>     - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</p><ul><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>. For matrices you plan to factor you must leave room for the diagonal entry and put in the entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_aijsell_eager_shadow</code> - Construct shadow matrix upon matrix assembly; default is to take a &quot;lazy&quot; approach, performing this step the first</li></ul><p>time the matrix is applied</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MATSEQAIJSELL</code>, <code>MATMPIAIJSELL</code>, <code>MATAIJSELL</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJSELL()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJSELL.html"><code>Mat/MatCreateMPIAIJSELL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17114-L17161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mpimat::PetscMat = MatCreateMPIAIJSumSeqAIJ(petsclib::PetscLibType,comm::MPI_Comm, seqmat::PetscMat, m::PetscInt, n::PetscInt, scall::MatReuse)</code></pre><p>Creates a <code>MATMPIAIJ</code> matrix by adding sequential matrices from each processor</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - the communicators the parallel matrix will live on</li><li><code>seqmat</code> - the input sequential matrices</li><li><code>m</code>      - number of local rows (or <code>PETSC_DECIDE</code>)</li><li><code>n</code>      - number of local columns (or <code>PETSC_DECIDE</code>)</li><li><code>scall</code>  - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>mpimat</code> - the parallel matrix generated</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJSumSeqAIJ.html"><code>Mat/MatCreateMPIAIJSumSeqAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15887-L15910">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJNumeric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCreateMPIAIJSumSeqAIJNumeric(petsclib::PetscLibType,seqmat::PetscMat, mpimat::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJSumSeqAIJNumeric.html"><code>Mat/MatCreateMPIAIJSumSeqAIJNumeric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15843-L15848">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatCreateMPIAIJSumSeqAIJSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mpimat::PetscMat = MatCreateMPIAIJSumSeqAIJSymbolic(petsclib::PetscLibType,comm::MPI_Comm, seqmat::PetscMat, m::PetscInt, n::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJSumSeqAIJSymbolic.html"><code>Mat/MatCreateMPIAIJSumSeqAIJSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15864-L15869">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateMPIAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateMPIAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>creates a <code>MATMPIAIJ</code> matrix using arrays that contain in standard CSR format for the local rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (Cannot be <code>PETSC_DECIDE</code>)</li><li><code>n</code>    - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product  y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices n is almost always <code>m</code>.</p><ul><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>i</code>    - row indices (of length m+1); that is i[0] = 0, i[row] = i[row-1] + number of elements in that row of the matrix</li><li><code>j</code>    - global column indices</li><li><code>a</code>    - optional matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code>, <code>MatUpdateMPIAIJWithArray()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJWithArrays.html"><code>Mat/MatCreateMPIAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15620-L15649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJWithSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJWithSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateMPIAIJWithSeqAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">garray::PetscInt,mat::PetscMat = MatCreateMPIAIJWithSeqAIJ(petsclib::PetscLibType,comm::MPI_Comm, M::PetscInt, N::PetscInt, A::PetscMat, B::PetscMat)</code></pre><p>creates a <code>MATMPIAIJ</code> matrix using <code>MATSEQAIJ</code> matrices that contain the &quot;diagonal&quot; and &quot;off-diagonal&quot; part of the matrix in CSR format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - MPI communicator</li><li><code>M</code>      - the global row size</li><li><code>N</code>      - the global column size</li><li><code>A</code>      - &quot;diagonal&quot; portion of matrix</li><li><code>B</code>      - if garray is <code>NULL</code>, B should be the offdiag matrix using global col ids and of size N - if garray is not <code>NULL</code>, B should be the offdiag matrix using local col ids and of size garray</li><li><code>garray</code> - either <code>NULL</code> or the global index of <code>B</code> columns. If not <code>NULL</code>, it should be allocated by <code>PetscMalloc1()</code> and will be owned by <code>mat</code> thereafter.</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix, with input <code>A</code> as its local diagonal matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MATSEQAIJ</code>, <code>MatCreateMPIAIJWithSplitArrays()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJWithSeqAIJ.html"><code>Mat/MatCreateMPIAIJWithSeqAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15492-L15516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAIJWithSplitArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAIJWithSplitArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateMPIAIJWithSplitArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateMPIAIJWithSplitArrays(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar}, oi::Vector{PetscInt}, oj::Vector{PetscInt}, oa::Vector{PetscScalar})</code></pre><p>creates a <code>MATMPIAIJ</code> matrix using arrays that contain the &quot;diagonal&quot; and &quot;off-diagonal&quot; part of the matrix in CSR format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (Cannot be <code>PETSC_DECIDE</code>)</li><li><code>n</code>    - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</p><ul><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>i</code>    - row indices for &quot;diagonal&quot; portion of matrix; that is i[0] = 0, i[row] = i[row-1] + number of elements in that row of the matrix</li><li><code>j</code>    - column indices, which must be local, i.e., based off the start column of the diagonal portion</li><li><code>a</code>    - matrix values</li><li><code>oi</code>   - row indices for &quot;off-diagonal&quot; portion of matrix; that is oi[0] = 0, oi[row] = oi[row-1] + number of elements in that row of the matrix</li><li><code>oj</code>   - column indices, which must be global, representing global columns in the <code>MATMPIAIJ</code> matrix</li><li><code>oa</code>   - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithArrays()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAIJWithSplitArrays.html"><code>Mat/MatCreateMPIAIJWithSplitArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16119-L16151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIAdj-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIAdj-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateMPIAdj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateMPIAdj(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, N::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, values::Vector{PetscInt})</code></pre><p>Creates a sparse matrix representing an adjacency list. The matrix need not have numerical values associated with it, it is intended for ordering (to reduce bandwidth etc) and partitioning.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - MPI communicator</li><li><code>m</code>      - number of local rows</li><li><code>N</code>      - number of global columns</li><li><code>i</code>      - the indices into <code>j</code> for the start of each row</li><li><code>j</code>      - the column indices for each row (sorted for each row).</li><li><code>values</code> - the values, optional, use <code>NULL</code> if not provided</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatConvert()</code>, <code>MatGetOrdering()</code>, <code>MATMPIADJ</code>, <code>MatMPIAdjSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIAdj.html"><code>Mat/MatCreateMPIAdj</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14142-L14167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateMPIBAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateMPIBAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>creates a <code>MATMPIBAIJ</code> matrix using arrays that contain in standard block CSR format for the local rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>bs</code>   - the block size, only a block size of 1 is supported</li><li><code>m</code>    - number of local rows (Cannot be <code>PETSC_DECIDE</code>)</li><li><code>n</code>    - This value should be the same as the local size used in creating the x vector for the matrix-vector product  y = Ax . (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</li><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>i</code>    - row indices; that is i[0] = 0, i[row] = i[row-1] + number of block elements in that rowth block row of the matrix</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIBAIJWithArrays.html"><code>Mat/MatCreateMPIBAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9694-L9721">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPIMatConcatenateSeqMat-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPIMatConcatenateSeqMat-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateMPIMatConcatenateSeqMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mpimat::PetscMat = MatCreateMPIMatConcatenateSeqMat(petsclib::PetscLibType,comm::MPI_Comm, seqmat::PetscMat, n::PetscInt, reuse::MatReuse)</code></pre><p>Creates a single large PETSc matrix by concatenating sequential matrices from each processor</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - the communicators the parallel matrix will live on</li><li><code>seqmat</code> - the input sequential matrices</li><li><code>n</code>      - number of local columns (or <code>PETSC_DECIDE</code>)</li><li><code>reuse</code>  - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>mpimat</code> - the parallel matrix generated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPIMatConcatenateSeqMat.html"><code>Mat/MatCreateMPIMatConcatenateSeqMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8501-L8523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateMPISBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateMPISBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateMPISBAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateMPISBAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>creates a <code>MATMPISBAIJ</code> matrix using arrays that contain in standard CSR format for the local rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>bs</code>   - the block size, only a block size of 1 is supported</li><li><code>m</code>    - number of local rows (Cannot be <code>PETSC_DECIDE</code>)</li><li><code>n</code>    - This value should be the same as the local size used in creating the x vector for the matrix-vector product  y = Ax . (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices <code>n</code> is almost always <code>m</code>.</li><li><code>M</code>    - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>i</code>    - row indices; that is i[0] = 0, i[row] = i[row-1] + number of block elements in that row block row of the matrix</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPISBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code>, <code>MatMPISBAIJSetPreallocationCSR()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateMPISBAIJWithArrays.html"><code>Mat/MatCreateMPISBAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13105-L13132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateNest-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Vector{PETSc.LibPETSc.IS}, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateNest-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Vector{PETSc.LibPETSc.IS}, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatCreateNest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatCreateNest(petsclib::PetscLibType,comm::MPI_Comm, nr::PetscInt, is_row::Vector{IS}, nc::PetscInt, is_col::Vector{IS}, a::Vector{PetscMat})</code></pre><p>Creates a new <code>MATNEST</code> matrix containing several nested submatrices, each stored separately</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>   - Communicator for the new <code>MATNEST</code></li><li><code>nr</code>     - number of nested row blocks</li><li><code>is_row</code> - index sets for each nested row block, or <code>NULL</code> to make contiguous</li><li><code>nc</code>     - number of nested column blocks</li><li><code>is_col</code> - index sets for each nested column block, or <code>NULL</code> to make contiguous</li><li><code>a</code>      - array of nr 	imes nc submatrices, empty submatrices can be passed using <code>NULL</code></li></ul><p>Output Parameter:</p><ul><li><code>B</code> - new matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatCreate()</code>, <code>VecCreateNest()</code>, <code>DMCreateMatrix()</code>, <code>MatNestSetSubMat()</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetLocalISs()</code>, <code>MatNestGetSize()</code>, <code>MatNestGetISs()</code>, <code>MatNestSetSubMats()</code>, <code>MatNestGetSubMats()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateNest.html"><code>Mat/MatCreateNest</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15383-L15408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateNormal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateNormal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateNormal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">N::PetscMat = MatCreateNormal(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Creates a new <code>MATNORMAL</code> matrix object that behaves like A^T A.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the (possibly rectangular) matrix</li></ul><p>Output Parameter:</p><ul><li><code>N</code> - the matrix that represents A^T A </li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNORMAL</code>, <code>MatMult()</code>, <code>MatNormalGetMat()</code>, <code>MATNORMALHERMITIAN</code>, <code>MatCreateNormalHermitian()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateNormal.html"><code>Mat/MatCreateNormal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14529-L14547">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateNormalHermitian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateNormalHermitian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateNormalHermitian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">N::PetscMat = MatCreateNormalHermitian(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Creates a new matrix object <code>MATNORMALHERMITIAN</code> that behaves like A^* A.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the (possibly rectangular complex) matrix</li></ul><p>Output Parameter:</p><ul><li><code>N</code> - the matrix that represents  A^* A</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNORMAL</code>, <code>MATNORMALHERMITIAN</code>, <code>MatNormalHermitianGetMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateNormalHermitian.html"><code>Mat/MatCreateNormalHermitian</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14601-L14619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateRedundantMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, MPI.Comm, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateRedundantMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, MPI.Comm, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateRedundantMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">matredundant::PetscMat = MatCreateRedundantMatrix(petsclib::PetscLibType,mat::PetscMat, nsubcomm::PetscInt, subcomm::MPI_Comm, reuse::MatReuse)</code></pre><p>Create redundant matrices and put them into processors of subcommunicators.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>      - the matrix</li><li><code>nsubcomm</code> - the number of subcommunicators (= number of redundant parallel or sequential matrices)</li><li><code>subcomm</code>  - MPI communicator split from the communicator where mat resides in (or <code>MPI_COMM_NULL</code> if nsubcomm is used)</li><li><code>reuse</code>    - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>matredundant</code> - redundant matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroy()</code>, <code>PetscSubcommCreate()</code>, <code>PetscSubcomm</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateRedundantMatrix.html"><code>Mat/MatCreateRedundantMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8067-L8088">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSBAIJ(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix in symmetric block AIJ format, <code>MATSBAIJ</code>, (block compressed row).  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameters <code>d_nz</code> (or <code>d_nnz</code>) and <code>o_nz</code> (or <code>o_nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>bs</code>    - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></li><li><code>m</code>     - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given) This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>     - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax.</li><li><code>M</code>     - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>     - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_nz</code>  - number of block nonzeros per block row in diagonal portion of local submatrix (same for all local rows)</li><li><code>d_nnz</code> - array containing the number of block nonzeros in the various block rows in the upper triangular portion of the in diagonal portion of the local (possibly different for each block block row) or <code>NULL</code>. If you plan to factor the matrix you must leave room for the diagonal entry and set its value even if it is zero.</li><li><code>o_nz</code>  - number of block nonzeros per block row in the off-diagonal portion of local submatrix (same for all local rows).</li><li><code>o_nnz</code> - array containing the number of nonzeros in the various block rows of the off-diagonal portion of the local submatrix (possibly different for each block row) or <code>NULL</code>.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use</li><li><code>-mat_mpi</code>        - use the parallel matrix data structures even on one processor (defaults to using SeqBAIJ format on one processor)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetOwnershipRange()</code>,  <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSBAIJ.html"><code>Mat/MatCreateSBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13051-L13087">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSELL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSELL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, d_rlenmax::PetscInt, d_rlen::Vector{PetscInt}, o_rlenmax::PetscInt, o_rlen::Vector{PetscInt})</code></pre><p>Creates a sparse parallel matrix in <code>MATSELL</code> format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>      - MPI communicator</li><li><code>m</code>         - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if M is given). This value should be the same as the local size used in creating the y vector for the matrix-vector product y = Ax.</li><li><code>n</code>         - This value should be the same as the local size used in creating the x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given) For square matrices n is almost always <code>m</code>.</li><li><code>M</code>         - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>         - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>d_rlenmax</code> - max number of nonzeros per row in DIAGONAL portion of local submatrix (same value is used for all local rows)</li><li><code>d_rlen</code>    - array containing the number of nonzeros in the various rows of the DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if d_rlenmax is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</li><li><code>o_rlenmax</code> - max number of nonzeros per row in the OFF-DIAGONAL portion of local submatrix (same value is used for all local rows).</li><li><code>o_rlen</code>    - array containing the number of nonzeros in the various rows of the OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_rlenmax</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_sell_oneindex</code> - Internally use indexing starting at 1</li></ul><p>rather than 0.  When calling <code>MatSetValues()</code>, the user still MUST index entries starting at 0!</p><p>Example: Consider the following 8x8 matrix with 34 non-zero values, that is assembled across 3 processors. Lets assume that proc0 owns 3 rows, proc1 owns 3 rows, proc2 owns 2 rows. This division can be shown as follows</p><p>-seealso: <code>Mat</code>, <code>MATSELL</code>, <code>MatCreate()</code>, <code>MatCreateSeqSELL()</code>, <code>MatSetValues()</code>, <code>MatMPISELLSetPreallocation()</code>, <code>MATMPISELL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSELL.html"><code>Mat/MatCreateSELL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9007-L9042">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSNESMF-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSNESMF-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES}"><code>PETSc.LibPETSc.MatCreateSNESMF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateSNESMF(petsclib::PetscLibType,snes::PetscSNES)</code></pre><p>Creates a finite differencing based matrix a <code>SNES</code> solver.  This matrix can be used as the Jacobian argument for the routine <code>SNESSetJacobian()</code>. See <code>MatCreateMFFD()</code> for details on how the finite difference computation is done.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>snes</code> - the <code>SNES</code> context</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - the matrix-free matrix which is of type <code>MATMFFD</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>SNES</code>, <code>MATMFFD</code>, <code>MatDestroy()</code>, <code>MatMFFDSetFunction()</code>, <code>MatMFFDSetFunctionError()</code>, <code>MatMFFDDSSetUmin()</code> <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code>, <code>MatCreateMFFD()</code>, <code>MatCreateShell()</code>, <code>MatMFFDGetH()</code>, <code>MatMFFDRegister()</code>, <code>MatMFFDComputeJacobian()</code>, <code>MatSNESMFSetReuseBase()</code>, <code>MatSNESMFGetReuseBase()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatCreateSNESMF.html"><code>Snes/MatCreateSNESMF</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22857-L22880">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSNESMFMore-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSNESMFMore-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatCreateSNESMFMore</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateSNESMFMore(petsclib::PetscLibType,snes::PetscSNES, x::PetscVec)</code></pre><p>Creates a matrix context for use with a <code>SNES</code> solver that uses the More method to compute an optimal h based on the noise of the function.  This matrix can be used as the Jacobian argument for the routine <code>SNESSetJacobian()</code>.</p><p>Input Parameters:</p><ul><li><code>snes</code> - the <code>SNES</code> context</li><li><code>x</code>    - vector where <code>SNES</code> solution is to be stored.</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - the matrix-free matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-snes_mf_err &lt;error_rel&gt;</code> - see <code>MatCreateSNESMF()</code></li><li><code>-snes_mf_umin &lt;umin&gt;</code>     - see <code>MatCreateSNESMF()</code></li><li><code>-snes_mf_compute_err</code>     - compute the square root or relative error in function</li><li><code>-snes_mf_freq_err &lt;freq&gt;</code> - set the frequency to recompute the parameters</li><li><code>-snes_mf_jorge</code>           - use the method of Jorge More</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>SNESCreateMF()</code>, <code>MatCreateMFFD()</code>, <code>MatDestroy()</code>, <code>MatMFFDSetFunctionError()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatCreateSNESMFMore.html"><code>Snes/MatCreateSNESMFMore</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22665-L22691">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateScaLAPACK-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 6}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateScaLAPACK-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 6}}"><code>PETSc.LibPETSc.MatCreateScaLAPACK</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateScaLAPACK(petsclib::PetscLibType,comm::MPI_Comm, mb::PetscInt, nb::PetscInt, M::PetscInt, N::PetscInt, rsrc::PetscInt, csrc::PetscInt)</code></pre><p>Creates a dense parallel matrix in ScaLAPACK format (2D block cyclic distribution) for a <code>MATSCALAPACK</code> matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>mb</code>   - row block size (or <code>PETSC_DECIDE</code> to have it set)</li><li><code>nb</code>   - column block size (or <code>PETSC_DECIDE</code> to have it set)</li><li><code>M</code>    - number of global rows</li><li><code>N</code>    - number of global columns</li><li><code>rsrc</code> - coordinate of process that owns the first row of the distributed matrix</li><li><code>csrc</code> - coordinate of process that owns the first column of the distributed matrix</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_scalapack_block_sizes</code> - size of the blocks to use (one or two integers separated by comma)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSCALAPACK</code>, <code>MATDENSE</code>, <code>MATELEMENTAL</code>, <code>MatCreate()</code>, <code>MatCreateDense()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateScaLAPACK.html"><code>Mat/MatCreateScaLAPACK</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8908-L8936">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateScatter-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Ptr{PETSc.LibPETSc._p_PetscSF}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateScatter-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Ptr{PETSc.LibPETSc._p_PetscSF}}"><code>PETSc.LibPETSc.MatCreateScatter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateScatter(petsclib::PetscLibType,comm::MPI_Comm, scatter::VecScatter)</code></pre><p>Creates a new matrix of <code>MatType</code> <code>MATSCATTER</code>, based on a VecScatter</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>    - MPI communicator</li><li><code>scatter</code> - a <code>VecScatter</code></li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatScatterSetVecScatter()</code>, <code>MatScatterGetVecScatter()</code>, <code>MATSCATTER</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateScatter.html"><code>Mat/MatCreateScatter</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14219-L14238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 5}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 5}}"><code>PETSc.LibPETSc.MatCreateSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S::PetscMat = MatCreateSchurComplement(petsclib::PetscLibType,A00::PetscMat, Ap00::PetscMat, A01::PetscMat, A10::PetscMat, A11::PetscMat)</code></pre><p>Creates a new <code>Mat</code> that behaves like the Schur complement of a matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A00</code>  - the upper-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>Ap00</code> - matrix from which the preconditioner is constructed for use in ksp(A00,Ap00) to approximate the action of A00^{-1}</li><li><code>A01</code>  - the upper-right block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A10</code>  - the lower-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A11</code>  - (optional) the lower-right block of the original matrix A = [A00 A01; A10 A11]</li></ul><p>Output Parameter:</p><ul><li><code>S</code> - the matrix that behaves as the Schur complement S = A11 - A10 ksp(A00,Ap00) A01</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MatSchurComplementGetKSP()</code>, <code>MatSchurComplementUpdateSubMatrices()</code>, <code>MatCreateTranspose()</code>, <code>MatGetSchurComplement()</code>, <code>MatSchurComplementGetPmat()</code>, <code>MatSchurComplementSetSubMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateSchurComplement.html"><code>Ksp/MatCreateSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22198-L22221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSchurComplementPmat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSchurComplementPmat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateSchurComplementPmat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Sp::PetscMat = MatCreateSchurComplementPmat(petsclib::PetscLibType,A00::PetscMat, A01::PetscMat, A10::PetscMat, A11::PetscMat, ainvtype::MatSchurComplementAinvType, preuse::MatReuse)</code></pre><p>create a matrix for preconditioning the Schur complement by explicitly assembling the sparse matrix Sp = A11 - A10 inv(DIAGFORM(A00)) A01</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A00</code>      - the upper-left part of the original matrix A = [A00 A01; A10 A11]</li><li><code>A01</code>      - (optional) the upper-right part of the original matrix A = [A00 A01; A10 A11]</li><li><code>A10</code>      - (optional) the lower-left part of the original matrix A = [A00 A01; A10 A11]</li><li><code>A11</code>      - (optional) the lower-right part of the original matrix A = [A00 A01; A10 A11]</li><li><code>ainvtype</code> - type of approximation for DIAGFORM(A00) used when forming Sp = A11 - A10 inv(DIAGFORM(A00)) A01. See <code>MatSchurComplementAinvType</code>.</li><li><code>preuse</code>   - <code>MAT_INITIAL_MATRIX</code> for a new <code>Sp</code>, or <code>MAT_REUSE_MATRIX</code> to reuse an existing <code>Sp</code>, or <code>MAT_IGNORE_MATRIX</code> to put nothing in <code>Sp</code></li></ul><p>Output Parameter:</p><ul><li><code>Sp</code> - approximate Schur complement suitable for constructing a preconditioner for the true Schur complement S = A11 - A10 inv(A00) A01</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateSchurComplement()</code>, <code>MatGetSchurComplement()</code>, <code>MatSchurComplementGetPmat()</code>, <code>MatSchurComplementAinvType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatCreateSchurComplementPmat.html"><code>Ksp/MatCreateSchurComplementPmat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22586-L22610">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJ(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix in <code>MATSEQAIJ</code> (compressed row) format (the default parallel PETSc format).  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows)</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows</li></ul><p>(possibly different for each row) or NULL</p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_inode</code>            - Do not use inodes</li><li><code>-mat_inode_limit &lt;limit&gt;</code> - Sets inode limit (max limit=5)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrix Creation</a>, <code>MatCreate()</code>, <code>MatCreateAIJ()</code>, <code>MatSetValues()</code>, <code>MatSeqAIJSetColumnIndices()</code>, <code>MatCreateSeqAIJWithArrays()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJ.html"><code>Mat/MatCreateSeqAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17872-L17902">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJCRL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJCRL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqAIJCRL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJCRL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATSEQAIJCRL</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows), ignored if <code>nnz</code> is given</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows</li></ul><p>(possibly different for each row) or <code>NULL</code></p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateMPIAIJPERM()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJCRL.html"><code>Mat/MatCreateSeqAIJCRL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18544-L18567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJFromTriple-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}, Int64, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJFromTriple-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}, Int64, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatCreateSeqAIJFromTriple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateSeqAIJFromTriple(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar}, nz::PetscCount, idx::PetscBool)</code></pre><p>Creates an sequential <code>MATSEQAIJ</code> matrix using matrix elements (in COO format) provided by the user.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - must be an MPI communicator of size 1</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>i</code>    - row indices</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li><li><code>nz</code>   - number of nonzeros</li><li><code>idx</code>  - if the <code>i</code> and <code>j</code> indices start with 1 use <code>PETSC_TRUE</code> otherwise use <code>PETSC_FALSE</code></li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>Example: For the following matrix, the input data expected is as shown (using 0 based indexing) -seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatCreateSeqAIJWithArrays()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MatSetValuesCOO()</code>, <code>MatSetPreallocationCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJFromTriple.html"><code>Mat/MatCreateSeqAIJFromTriple</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18367-L18395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJKokkos-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJKokkos-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqAIJKokkos</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJKokkos(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJKokkos.html"><code>Mat/MatCreateSeqAIJKokkos</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18586-L18591">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateSeqAIJMKL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJMKL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATSEQAIJMKL</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows)</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows</li></ul><p>(possibly different for each row) or <code>NULL</code></p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_aijmkl_no_spmv2</code>         - disable use of the SpMV2 inspector-executor routines</li><li><code>-mat_aijmkl_eager_inspection</code> - perform MKL &quot;inspection&quot; phase upon matrix assembly; default is to do &quot;lazy&quot; inspection,</li></ul><p>performing this step the first time the matrix is applied</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateMPIAIJMKL()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJMKL.html"><code>Mat/MatCreateSeqAIJMKL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18667-L18695">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJPERM-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJPERM-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCreateSeqAIJPERM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJPERM(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATSEQAIJPERM</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows), ignored if <code>nnz</code> is given</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows (possibly different for each row) or <code>NULL</code></li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateMPIAIJPERM()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJPERM.html"><code>Mat/MatCreateSeqAIJPERM</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18758-L18780">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqAIJSELL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJSELL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATSEQAIJSELL</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzeros per row (same for all rows)</li><li><code>nnz</code>  - array containing the number of nonzeros in the various rows</li></ul><p>(possibly different for each row) or <code>NULL</code></p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_aijsell_eager_shadow</code> - Construct shadow matrix upon matrix assembly; default is to take a &quot;lazy&quot; approach,</li></ul><p>performing this step the first time the matrix is applied</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateMPIAIJSELL()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJSELL.html"><code>Mat/MatCreateSeqAIJSELL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18713-L18740">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJViennaCL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJViennaCL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqAIJViennaCL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqAIJViennaCL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJViennaCL.html"><code>Mat/MatCreateSeqAIJViennaCL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18644-L18649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateSeqAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateSeqAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>Creates an sequential <code>MATSEQAIJ</code> matrix using matrix elements (in CSR format) provided by the user.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - must be an MPI communicator of size 1</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>i</code>    - row indices; that is i[0] = 0, i[row] = i[row-1] + number of elements in that row of the matrix</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatCreateMPIAIJWithArrays()</code>, <code>MatMPIAIJSetPreallocationCSR()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqAIJWithArrays.html"><code>Mat/MatCreateSeqAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18325-L18349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqBAIJ(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix in <code>MATSEQAIJ</code> (block compressed row) format.  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>bs</code>   - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row</li></ul><p>blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></p><ul><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzero blocks  per block row (same for all rows)</li><li><code>nnz</code>  - array containing the number of nonzero blocks in the various block rows</li></ul><p>(possibly different for each block row) or <code>NULL</code></p><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrices</a>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqBAIJ.html"><code>Mat/MatCreateSeqBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9890-L9922">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqBAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqBAIJMKL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqBAIJMKL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqBAIJMKL(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse matrix of type <code>MATSEQBAIJMKL</code>. This type inherits from <code>MATSEQBAIJ</code> and is largely identical, but uses sparse BLAS routines from Intel MKL whenever possible.</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>bs</code>   - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of nonzero blocks  per block row (same for all rows)</li><li><code>nnz</code>  - array containing the number of nonzero blocks in the various block rows (possibly different for each block row) or <code>NULL</code></li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>It is recommended that one use the <code>MatCreate()</code>, <code>MatSetType()</code> and/or <code>MatSetFromOptions()</code>, MatXXXXSetPreallocation() paradigm instead of this routine directly. [MatXXXXSetPreallocation() is, for example, <code>MatSeqBAIJSetPreallocation()</code>]</p><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use</li></ul><p>Level: intermediate</p><p>-seealso: <a href="sec_matsparse">Sparse Matrices</a>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqBAIJMKL.html"><code>Mat/MatCreateSeqBAIJMKL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10060-L10091">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateSeqBAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateSeqBAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>Creates a <code>MATSEQBAIJ</code> matrix using matrix elements provided by the user.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - must be an MPI communicator of size 1</li><li><code>bs</code>   - size of block</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>i</code>    - row indices; that is i[0] = 0, i[row] = i[row-1] + number of elements in that row block row of the matrix</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateBAIJ()</code>, <code>MatCreateSeqBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqBAIJWithArrays.html"><code>Mat/MatCreateSeqBAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10018-L10042">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqDense-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Union{Ptr, Vector{Float64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqDense-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Union{Ptr, Vector{Float64}}}"><code>PETSc.LibPETSc.MatCreateSeqDense</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqDense(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, data::Vector{PetscScalar})</code></pre><p>Creates a <code>MATSEQDENSE</code> that is stored in column major order (the usual Fortran format).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>data</code> - optional location of matrix data in column major order.  Use <code>NULL</code> for PETSc to control all matrix memory allocation.</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQDENSE</code>, <code>MatCreate()</code>, <code>MatCreateDense()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqDense.html"><code>Mat/MatCreateSeqDense</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11983-L12005">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqSBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqSBAIJ(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse symmetric matrix in (block compressed row) <code>MATSEQSBAIJ</code> format.  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>bs</code>   - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with MatCreateVecs()</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>nz</code>   - number of block nonzeros per block row (same for all rows)</li><li><code>nnz</code>  - array containing the number of block nonzeros in the upper triangular plus diagonal portion of each block (possibly different for each block row) or <code>NULL</code></li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the symmetric matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrices</a>, <code>MATSEQSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateSBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqSBAIJ.html"><code>Mat/MatCreateSeqSBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13365-L13395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqSBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqSBAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatCreateSeqSBAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat::PetscMat = MatCreateSeqSBAIJWithArrays(petsclib::PetscLibType,comm::MPI_Comm, bs::PetscInt, m::PetscInt, n::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, a::Vector{PetscScalar})</code></pre><p>Creates an sequential <code>MATSEQSBAIJ</code> matrix using matrix elements (upper triangular entries in CSR format) provided by the user.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - must be an MPI communicator of size 1</li><li><code>bs</code>   - size of block</li><li><code>m</code>    - number of rows</li><li><code>n</code>    - number of columns</li><li><code>i</code>    - row indices; that is i[0] = 0, i[row] = i[row-1] + number of block elements in that row block row of the matrix</li><li><code>j</code>    - column indices</li><li><code>a</code>    - matrix values</li></ul><p>Output Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSBAIJ()</code>, <code>MatCreateSeqSBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqSBAIJWithArrays.html"><code>Mat/MatCreateSeqSBAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13413-L13438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSeqSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSeqSELL-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatCreateSeqSELL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateSeqSELL(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, rlenmax::PetscInt, rlen::Union{Ptr,Vector{PetscInt}})</code></pre><p>Creates a sparse matrix in <code>MATSEQSELL</code> format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>    - MPI communicator, set to <code>PETSC_COMM_SELF</code></li><li><code>m</code>       - number of rows</li><li><code>n</code>       - number of columns</li><li><code>rlenmax</code> - maximum number of nonzeros in a row, ignored if <code>rlen</code> is provided</li><li><code>rlen</code>    - array containing the number of nonzeros in the various rows (possibly different for each row) or NULL</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MATSEQSELL</code>, <code>MatCreate()</code>, <code>MatCreateSELL()</code>, <code>MatSetValues()</code>, <code>MatSeqSELLSetPreallocation()</code>, <code>MATSELL</code>, <code>MATMPISELL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSeqSELL.html"><code>Mat/MatCreateSeqSELL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9351-L9373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateShell-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateShell-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Vararg{Int64, 4}}"><code>PETSc.LibPETSc.MatCreateShell</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatCreateShell(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, ctx::Ptr)</code></pre><p>Creates a new matrix of <code>MatType</code> <code>MATSHELL</code> for use with a user private matrix data storage format.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code> - MPI communicator</li><li><code>m</code>    - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li><li><code>n</code>    - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given)</li><li><code>M</code>    - number of global rows (may be <code>PETSC_DETERMINE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>    - number of global columns (may be <code>PETSC_DETERMINE</code> to have calculated if <code>n</code> is given)</li><li><code>ctx</code>  - pointer to data needed by the shell matrix routines</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatShellSetOperation()</code>, <code>MatHasOperation()</code>, <code>MatShellGetContext()</code>, <code>MatShellSetContext()</code>, <code>MatShellSetManageScalingShifts()</code>, <code>MatShellSetMatProductOperation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateShell.html"><code>Mat/MatCreateShell</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10329-L10353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateSubMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">submat::Vector{PetscMat} = MatCreateSubMatrices(petsclib::PetscLibType,mat::PetscMat, n::PetscInt, irow::Vector{IS}, icol::Vector{IS}, scall::MatReuse)</code></pre><p>Extracts several submatrices from a matrix. If submat points to an array of valid matrices, they may be reused to store the new submatrices.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>n</code>     - the number of submatrixes to be extracted (on this processor, may be zero)</li><li><code>irow</code>  - index set of rows to extract</li><li><code>icol</code>  - index set of columns to extract</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>submat</code> - the array of submatrices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroySubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRow()</code>, <code>MatGetDiagonal()</code>, <code>MatReuse</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSubMatrices.html"><code>Mat/MatCreateSubMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5517-L5541">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSubMatricesMPI-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSubMatricesMPI-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateSubMatricesMPI</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">submat::Vector{PetscMat} = MatCreateSubMatricesMPI(petsclib::PetscLibType,mat::PetscMat, n::PetscInt, irow::Vector{IS}, icol::Vector{IS}, scall::MatReuse)</code></pre><p>Extracts MPI submatrices across a sub communicator of <code>mat</code> (by pairs of <code>IS</code> that may live on subcomms).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>n</code>     - the number of submatrixes to be extracted</li><li><code>irow</code>  - index set of rows to extract</li><li><code>icol</code>  - index set of columns to extract</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>submat</code> - the array of submatrices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCGASM</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRow()</code>, <code>MatGetDiagonal()</code>, <code>MatReuse</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSubMatricesMPI.html"><code>Mat/MatCreateSubMatricesMPI</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5559-L5581">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatReuse}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatReuse}"><code>PETSc.LibPETSc.MatCreateSubMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newmat::PetscMat = MatCreateSubMatrix(petsclib::PetscLibType,mat::PetscMat, isrow::IS, iscol::IS, cll::MatReuse)</code></pre><p>Gets a single submatrix on the same number of processors as the original matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the original matrix</li><li><code>isrow</code> - parallel <code>IS</code> containing the rows this processor should obtain</li><li><code>iscol</code> - parallel <code>IS</code> containing all columns you wish to keep. Each process should list the columns that will be in IT&#39;s &quot;diagonal part&quot; in the new matrix.</li><li><code>cll</code>   - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>newmat</code> - the new submatrix, of the same type as the original matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatricesMPI()</code>, <code>MatCreateSubMatrixVirtual()</code>, <code>MatSubMatrixVirtualUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSubMatrix.html"><code>Mat/MatCreateSubMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6429-L6451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSubMatrixFree-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSubMatrixFree-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatCreateSubMatrixFree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J::PetscMat = MatCreateSubMatrixFree(petsclib::PetscLibType,mat::PetscMat, Rows::IS, Cols::IS)</code></pre><p>Creates a reduced matrix by masking a full matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - matrix of arbitrary type</li><li><code>Rows</code> - the rows that will be in the submatrix</li><li><code>Cols</code> - the columns that will be in the submatrix</li></ul><p>Output Parameter:</p><ul><li><code>J</code> - New matrix</li></ul><p>Level: developer</p><p>-seealso: <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Tao/MatCreateSubMatrixFree.html"><code>Tao/MatCreateSubMatrixFree</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23069-L23090">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateSubMatrixVirtual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateSubMatrixVirtual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatCreateSubMatrixVirtual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newmat::PetscMat = MatCreateSubMatrixVirtual(petsclib::PetscLibType,A::PetscMat, isrow::IS, iscol::IS)</code></pre><p>Creates a virtual matrix <code>MATSUBMATRIX</code> that acts as a submatrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - matrix that we will extract a submatrix of</li><li><code>isrow</code> - rows to be present in the submatrix</li><li><code>iscol</code> - columns to be present in the submatrix</li></ul><p>Output Parameter:</p><ul><li><code>newmat</code> - new matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSUBMATRIX</code>, <code>MATLOCALREF</code>, <code>MatCreateLocalRef()</code>, <code>MatCreateSubMatrix()</code>, <code>MatSubMatrixVirtualUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateSubMatrixVirtual.html"><code>Mat/MatCreateSubMatrixVirtual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15016-L15036">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">N::PetscMat = MatCreateTranspose(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Creates a new matrix <code>MATTRANSPOSEVIRTUAL</code> object that behaves like A&#39;</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the (possibly rectangular) matrix</li></ul><p>Output Parameter:</p><ul><li><code>N</code> - the matrix that represents A&#39;</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATTRANSPOSEVIRTUAL</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatMultTranspose()</code>, <code>MatCreate()</code>, <code>MATNORMALHERMITIAN</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateTranspose.html"><code>Mat/MatCreateTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11234-L11253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateVecs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateVecs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateVecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right::PetscVec,left::PetscVec = MatCreateVecs(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Get vector(s) compatible with the matrix, i.e. with the same parallel layout, <code>PetscLayout</code> for rows and columns</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>right</code> - (optional) vector that the matrix can be multiplied against</li><li><code>left</code>  - (optional) vector that the matrix vector product can be stored in</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>Vec</code>, <code>VecCreate()</code>, <code>VecDestroy()</code>, <code>DMCreateGlobalVector()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateVecs.html"><code>Mat/MatCreateVecs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7485-L7505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCreateVecsFFTW-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCreateVecsFFTW-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCreateVecsFFTW</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">x::PetscVec,y::PetscVec,z::PetscVec = MatCreateVecsFFTW(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get vector(s) compatible with the matrix, i.e. with the parallel layout determined by <code>MATFFTW</code></p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>x</code> - (optional) input vector of forward FFTW</li><li><code>y</code> - (optional) output vector of forward FFTW</li><li><code>z</code> - (optional) output vector of backward FFTW</li></ul><p>Options Database Key:</p><ul><li><code>-mat_fftw_plannerflags</code> - set FFTW planner flags</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATFFTW</code>, <code>MatCreateFFT()</code>, <code>MatCreateVecs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCreateVecsFFTW.html"><code>Mat/MatCreateVecsFFTW</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14758-L14782">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDFischer-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vararg{PETSc.LibPETSc.PetscVec, 8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDFischer-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vararg{PETSc.LibPETSc.PetscVec, 8}}"><code>PETSc.LibPETSc.MatDFischer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDFischer(petsclib::PetscLibType,jac::PetscMat, X::PetscVec, Con::PetscVec, XL::PetscVec, XU::PetscVec, T1::PetscVec, T2::PetscVec, Da::PetscVec, Db::PetscVec)</code></pre><p>Calculates an element of the B Fischer-Burmeister function for complementarity problems.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>jac</code> - the jacobian of <code>f</code> at <code>X</code></li><li><code>X</code>   - current point</li><li><code>Con</code> - constraints function evaluated at <code>X</code></li><li><code>XL</code>  - lower bounds</li><li><code>XU</code>  - upper bounds</li><li><code>T1</code>  - work vector</li><li><code>T2</code>  - work vector</li></ul><p>Output Parameters:</p><ul><li><code>Da</code> - diagonal perturbation component of the result</li><li><code>Db</code> - row scaling component of the result</li></ul><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>VecFischer()</code>, <code>VecSFischer()</code>, <code>MatDSFischer()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Tao/MatDFischer.html"><code>Tao/MatDFischer</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22983-L23009">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDSFischer-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, Float64, Vararg{PETSc.LibPETSc.PetscVec, 5}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDSFischer-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, Float64, Vararg{PETSc.LibPETSc.PetscVec, 5}}"><code>PETSc.LibPETSc.MatDSFischer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDSFischer(petsclib::PetscLibType,jac::PetscMat, X::PetscVec, Con::PetscVec, XL::PetscVec, XU::PetscVec, mu::PetscReal, T1::PetscVec, T2::PetscVec, Da::PetscVec, Db::PetscVec, Dm::PetscVec)</code></pre><p>Calculates an element of the B smoothed Fischer-Burmeister function for complementarity problems.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>jac</code> - the jacobian of f at X</li><li><code>X</code>   - current point</li><li><code>Con</code> - constraint function evaluated at X</li><li><code>XL</code>  - lower bounds</li><li><code>XU</code>  - upper bounds</li><li><code>mu</code>  - smoothing parameter</li><li><code>T1</code>  - work vector</li><li><code>T2</code>  - work vector</li></ul><p>Output Parameters:</p><ul><li><code>Da</code> - diagonal perturbation component of the result</li><li><code>Db</code> - row scaling component of the result</li><li><code>Dm</code> - derivative with respect to scaling parameter</li></ul><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>VecFischer()</code>, <code>VecDFischer()</code>, <code>MatDFischer()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Tao/MatDSFischer.html"><code>Tao/MatDSFischer</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23025-L23053">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseGetArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArray.html"><code>Mat/MatDenseGetArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11551-L11569">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArrayAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArrayAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArrayAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar},mtype::PetscMemType = MatDenseGetArrayAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameters:</p><ul><li><code>array</code> - pointer to the data</li><li><code>mtype</code> - memory type of the returned pointer</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArrayAndMemType()</code>, <code>MatDenseGetArrayReadAndMemType()</code>, <code>MatDenseGetArrayWriteAndMemType()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code>, <code>MatSeqAIJGetCSRAndMemType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArrayAndMemType.html"><code>Mat/MatDenseGetArrayAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11761-L11781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArrayRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseGetArrayRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArrayRead.html"><code>Mat/MatDenseGetArrayRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11621-L11639">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArrayReadAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArrayReadAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArrayReadAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar},mtype::PetscMemType = MatDenseGetArrayReadAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameters:</p><ul><li><code>array</code> - pointer to the data</li><li><code>mtype</code> - memory type of the returned pointer</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArrayReadAndMemType()</code>, <code>MatDenseGetArrayWriteAndMemType()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code>, <code>MatSeqAIJGetCSRAndMemType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArrayReadAndMemType.html"><code>Mat/MatDenseGetArrayReadAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11835-L11855">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArrayWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseGetArrayWrite(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives write</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArrayWrite()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArrayWrite.html"><code>Mat/MatDenseGetArrayWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11691-L11709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetArrayWriteAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetArrayWriteAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetArrayWriteAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar},mtype::PetscMemType = MatDenseGetArrayWriteAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives write</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a dense matrix</li></ul><p>Output Parameters:</p><ul><li><code>array</code> - pointer to the data</li><li><code>mtype</code> - memory type of the returned pointer</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreArrayWriteAndMemType()</code>, <code>MatDenseGetArrayReadAndMemType()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code>, <code>MatSeqAIJGetCSRAndMemType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetArrayWriteAndMemType.html"><code>Mat/MatDenseGetArrayWriteAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11909-L11929">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatDenseGetColumn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals::Vector{PetscScalar} = MatDenseGetColumn(petsclib::PetscLibType,A::PetscMat, col::PetscInt)</code></pre><p>gives access to a column of a dense matrix. This is only the local part of the column. You MUST call <code>MatDenseRestoreColumn()</code> to avoid memory bleeding.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - a <code>MATSEQDENSE</code> or <code>MATMPIDENSE</code> matrix</li><li><code>col</code> - column index</li></ul><p>Output Parameter:</p><ul><li><code>vals</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseRestoreColumn()</code>, <code>MatDenseGetColumnVec()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetColumn.html"><code>Mat/MatDenseGetColumn</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12055-L12074">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetColumnVec-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetColumnVec-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseGetColumnVec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseGetColumnVec(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Gives read</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVecRead()</code>, <code>MatDenseGetColumnVecWrite()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreColumnVecRead()</code>, <code>MatDenseRestoreColumnVecWrite()</code>, <code>MatDenseGetColumn()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetColumnVec.html"><code>Mat/MatDenseGetColumnVec</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12126-L12145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetColumnVecRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetColumnVecRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseGetColumnVecRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseGetColumnVecRead(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Gives read</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseGetColumnVecWrite()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreColumnVecRead()</code>, <code>MatDenseRestoreColumnVecWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetColumnVecRead.html"><code>Mat/MatDenseGetColumnVecRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12198-L12217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetColumnVecWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetColumnVecWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseGetColumnVecWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseGetColumnVecWrite(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Gives write</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseGetColumnVecRead()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreColumnVecRead()</code>, <code>MatDenseRestoreColumnVecWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetColumnVecWrite.html"><code>Mat/MatDenseGetColumnVecWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12270-L12289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetLDA-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetLDA-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetLDA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lda::PetscInt = MatDenseGetLDA(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gets the leading dimension of the array returned from <code>MatDenseGetArray()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATDENSE</code> or <code>MATDENSECUDA</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>lda</code> - the leading dimension</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseSetLDA()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetLDA.html"><code>Mat/MatDenseGetLDA</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11483-L11501">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetLocalMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetLocalMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetLocalMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseGetLocalMatrix(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>For a <code>MATMPIDENSE</code> or <code>MATSEQDENSE</code> matrix returns the sequential matrix that represents the operator. For sequential matrices it returns itself.</p><p>Input Parameter:</p><ul><li><code>A</code> - the sequential or MPI <code>MATDENSE</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the inner matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATMPIDENSE</code>, <code>MATSEQDENSE</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetLocalMatrix.html"><code>Mat/MatDenseGetLocalMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11271-L11288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseGetSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseGetSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseGetSubMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseGetSubMatrix(petsclib::PetscLibType,A::PetscMat, rbegin::PetscInt, rend::PetscInt, cbegin::PetscInt, cend::PetscInt, v::PetscMat)</code></pre><p>Gives access to a block of rows and columns of a dense matrix, represented as a <code>Mat</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - the <code>Mat</code> object</li><li><code>rbegin</code> - the first global row index in the block (if <code>PETSC_DECIDE</code>, is 0)</li><li><code>rend</code>   - the global row index past the last one in the block (if <code>PETSC_DECIDE</code>, is <code>M</code>)</li><li><code>cbegin</code> - the first global column index in the block (if <code>PETSC_DECIDE</code>, is 0)</li><li><code>cend</code>   - the global column index past the last one in the block (if <code>PETSC_DECIDE</code>, is <code>N</code>)</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreSubMatrix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseGetSubMatrix.html"><code>Mat/MatDenseGetSubMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12342-L12364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDensePlaceArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDensePlaceArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDensePlaceArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::PetscScalar = MatDensePlaceArray(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Allows one to replace the array in a <code>MATDENSE</code> matrix with an array provided by the user. This is useful to avoid copying an array into a matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>array</code> - the array in column major order</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArray()</code>, <code>MatDenseResetArray()</code>, <code>VecPlaceArray()</code>, <code>VecGetArray()</code>, <code>VecRestoreArray()</code>, <code>VecReplaceArray()</code>, <code>VecResetArray()</code>, <code>MatDenseReplaceArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDensePlaceArray.html"><code>Mat/MatDensePlaceArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11338-L11357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseReplaceArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseReplaceArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseReplaceArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::PetscScalar = MatDenseReplaceArray(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Allows one to replace the array in a dense matrix with an array provided by the user. This is useful to avoid copying an array into a matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>array</code> - the array in column major order</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDensePlaceArray()</code>, <code>MatDenseGetArray()</code>, <code>VecReplaceArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseReplaceArray.html"><code>Mat/MatDenseReplaceArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11406-L11424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseResetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseResetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseResetArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseResetArray(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Resets the matrix array to that it previously had before the call to <code>MatDensePlaceArray()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArray()</code>, <code>MatDensePlaceArray()</code>, <code>VecPlaceArray()</code>, <code>VecGetArray()</code>, <code>VecRestoreArray()</code>, <code>VecReplaceArray()</code>, <code>VecResetArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseResetArray.html"><code>Mat/MatDenseResetArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11375-L11390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the data for a <code>MATDENSE</code> matrix is stored obtained by <code>MatDenseGetArray()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArray.html"><code>Mat/MatDenseRestoreArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11587-L11603">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArrayAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArrayAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArrayAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArrayAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array that is obtained by <code>MatDenseGetArrayAndMemType()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArrayAndMemType()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArrayAndMemType.html"><code>Mat/MatDenseRestoreArrayAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11801-L11817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArrayRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArrayRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the data for a <code>MATDENSE</code> matrix is stored obtained by <code>MatDenseGetArrayRead()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArrayRead.html"><code>Mat/MatDenseRestoreArrayRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11657-L11673">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArrayReadAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArrayReadAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArrayReadAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArrayReadAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array that is obtained by <code>MatDenseGetArrayReadAndMemType()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArrayReadAndMemType()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArrayReadAndMemType.html"><code>Mat/MatDenseRestoreArrayReadAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11875-L11891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArrayWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArrayWrite(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the data for a <code>MATDENSE</code> matrix is stored obtained by <code>MatDenseGetArrayWrite()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArrayWrite.html"><code>Mat/MatDenseRestoreArrayWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11727-L11743">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreArrayWriteAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreArrayWriteAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreArrayWriteAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatDenseRestoreArrayWriteAndMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array that is obtained by <code>MatDenseGetArrayReadAndMemType()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a dense matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetArrayWriteAndMemType()</code>, <code>MatDenseGetArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetArrayWrite()</code>, <code>MatDenseRestoreArrayWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreArrayWriteAndMemType.html"><code>Mat/MatDenseRestoreArrayWriteAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11949-L11965">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreColumn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals::Vector{PetscScalar} = MatDenseRestoreColumn(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to a column of a <code>MATDENSE</code> matrix which is returned by <code>MatDenseGetColumn()</code>.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - a <code>MATSEQDENSE</code> or <code>MATMPIDENSE</code> matrix</li><li><code>vals</code> - pointer to the data (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MatDenseGetColumn()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreColumn.html"><code>Mat/MatDenseRestoreColumn</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12092-L12108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreColumnVec-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreColumnVec-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseRestoreColumnVec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseRestoreColumnVec(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Returns access to a column of a dense matrix obtained from <code>MatDenseGetColumnVec()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li><li><code>v</code>   - the <code>Vec</code> object (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseGetColumnVecRead()</code>, <code>MatDenseGetColumnVecWrite()</code>, <code>MatDenseRestoreColumnVecRead()</code>, <code>MatDenseRestoreColumnVecWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreColumnVec.html"><code>Mat/MatDenseRestoreColumnVec</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12163-L12180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreColumnVecRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreColumnVecRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseRestoreColumnVecRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseRestoreColumnVecRead(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Returns access to a column of a dense matrix obtained from <code>MatDenseGetColumnVecRead()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li><li><code>v</code>   - the <code>Vec</code> object (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseGetColumnVecRead()</code>, <code>MatDenseGetColumnVecWrite()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreColumnVecWrite()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreColumnVecRead.html"><code>Mat/MatDenseRestoreColumnVecRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12235-L12252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreColumnVecWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreColumnVecWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDenseRestoreColumnVecWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseRestoreColumnVecWrite(petsclib::PetscLibType,A::PetscMat, col::PetscInt, v::PetscVec)</code></pre><p>Returns access to a column of a dense matrix obtained from <code>MatDenseGetColumnVecWrite()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>Mat</code> object</li><li><code>col</code> - the column index</li><li><code>v</code>   - the <code>Vec</code> object (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseGetColumnVecRead()</code>, <code>MatDenseGetColumnVecWrite()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseRestoreColumnVecRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreColumnVecWrite.html"><code>Mat/MatDenseRestoreColumnVecWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12307-L12324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseRestoreSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseRestoreSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDenseRestoreSubMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseRestoreSubMatrix(petsclib::PetscLibType,A::PetscMat, v::PetscMat)</code></pre><p>Returns access to a block of columns of a dense matrix obtained from <code>MatDenseGetSubMatrix()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>Mat</code> object</li><li><code>v</code> - the <code>Mat</code> object (may be <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MATDENSEHIP</code>, <code>MatDenseGetColumnVec()</code>, <code>MatDenseRestoreColumnVec()</code>, <code>MatDenseGetSubMatrix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseRestoreSubMatrix.html"><code>Mat/MatDenseRestoreSubMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12382-L12398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDenseSetLDA-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDenseSetLDA-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatDenseSetLDA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDenseSetLDA(petsclib::PetscLibType,A::PetscMat, lda::PetscInt)</code></pre><p>Sets the leading dimension of the array used by the <code>MATDENSE</code> matrix</p><p>Collective if the matrix layouts have not yet been setup</p><p>Input Parameters:</p><ul><li><code>A</code>   - a <code>MATDENSE</code> or <code>MATDENSECUDA</code> matrix</li><li><code>lda</code> - the leading dimension</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATDENSE</code>, <code>MATDENSECUDA</code>, <code>MatDenseGetArray()</code>, <code>MatDenseRestoreArray()</code>, <code>MatDenseGetArrayRead()</code>, <code>MatDenseRestoreArrayRead()</code>, <code>MatDenseGetLDA()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDenseSetLDA.html"><code>Mat/MatDenseSetLDA</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11519-L11535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDestroy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDestroy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><code>PETSc.LibPETSc.MatDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDestroy(petsclib::PetscLibType,A::AbstractPetscMat)</code></pre><p>Frees space taken by a matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDestroy.html"><code>Mat/MatDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1814-L1829">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDestroyMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDestroyMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatDestroyMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDestroyMatrices(petsclib::PetscLibType,n::PetscInt, mat::Vector{PetscMat})</code></pre><p>Destroys an array of matrices</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>n</code>   - the number of local matrices</li><li><code>mat</code> - the matrices (this is a pointer to the array of matrices)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSubMatrices()</code>, <code>MatDestroySubMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDestroyMatrices.html"><code>Mat/MatDestroyMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5599-L5615">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDestroySeqNonzeroStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDestroySeqNonzeroStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDestroySeqNonzeroStructure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDestroySeqNonzeroStructure(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Destroys matrix obtained with <code>MatGetSeqNonzeroStructure()</code>.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetSeqNonzeroStructure()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDestroySeqNonzeroStructure.html"><code>Mat/MatDestroySeqNonzeroStructure</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5701-L5716">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDestroySubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDestroySubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatDestroySubMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDestroySubMatrices(petsclib::PetscLibType,n::PetscInt, mat::Vector{PetscMat})</code></pre><p>Destroys a set of matrices obtained with <code>MatCreateSubMatrices()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>n</code>   - the number of local matrices</li><li><code>mat</code> - the matrices (this is a pointer to the array of matrices, to match the calling sequence of <code>MatCreateSubMatrices()</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSubMatrices()</code>, <code>MatDestroyMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDestroySubMatrices.html"><code>Mat/MatDestroySubMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5632-L5648">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalGetDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalGetDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDiagonalGetDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalGetDiagonal(petsclib::PetscLibType,A::PetscMat, diag::PetscVec)</code></pre><p>Get the diagonal of a <code>MATDIAGONAL</code></p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATDIAGONAL</code></li></ul><p>Output Parameter:</p><ul><li><code>diag</code> - the <code>Vec</code> that defines the diagonal</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>MATDIAGONAL</code>, <code>MatCreateDiagonal()</code>, <code>MatDiagonalRestoreDiagonal()</code>, <code>MatDiagonalGetInverseDiagonal()</code>, <code>MatGetDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalGetDiagonal.html"><code>Mat/MatDiagonalGetDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14324-L14340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalGetInverseDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalGetInverseDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDiagonalGetInverseDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalGetInverseDiagonal(petsclib::PetscLibType,A::PetscMat, inv_diag::PetscVec)</code></pre><p>Get the inverse diagonal of a <code>MATDIAGONAL</code></p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATDIAGONAL</code></li></ul><p>Output Parameter:</p><ul><li><code>inv_diag</code> - the <code>Vec</code> that defines the inverse diagonal</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>MATDIAGONAL</code>, <code>MatCreateDiagonal()</code>, <code>MatDiagonalRestoreInverseDiagonal()</code>, <code>MatDiagonalGetDiagonal()</code>, <code>MATLMVMBROYDEN</code>, <code>MatSolve()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalGetInverseDiagonal.html"><code>Mat/MatDiagonalGetInverseDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14390-L14406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalRestoreDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalRestoreDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDiagonalRestoreDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalRestoreDiagonal(petsclib::PetscLibType,A::PetscMat, diag::PetscVec)</code></pre><p>Restore the diagonal of a <code>MATDIAGONAL</code></p><p>Input Parameters:</p><ul><li><code>A</code>    - the <code>MATDIAGONAL</code></li><li><code>diag</code> - the <code>Vec</code> obtained from <code>MatDiagonalGetDiagonal()</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>MATDIAGONAL</code>, <code>MatCreateDiagonal()</code>, <code>MatDiagonalGetDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalRestoreDiagonal.html"><code>Mat/MatDiagonalRestoreDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14358-L14372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalRestoreInverseDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalRestoreInverseDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDiagonalRestoreInverseDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalRestoreInverseDiagonal(petsclib::PetscLibType,A::PetscMat, inv_diag::PetscVec)</code></pre><p>Restore the inverse diagonal of a <code>MATDIAGONAL</code></p><p>Input Parameters:</p><ul><li><code>A</code>        - the <code>MATDIAGONAL</code></li><li><code>inv_diag</code> - the <code>Vec</code> obtained from <code>MatDiagonalGetInverseDiagonal()</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>MATDIAGONAL</code>, <code>MatCreateDiagonal()</code>, <code>MatDiagonalGetInverseDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalRestoreInverseDiagonal.html"><code>Mat/MatDiagonalRestoreInverseDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14424-L14438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalScale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscVec}, Union{Ptr, PETSc.LibPETSc.PetscVec}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalScale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscVec}, Union{Ptr, PETSc.LibPETSc.PetscVec}}"><code>PETSc.LibPETSc.MatDiagonalScale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalScale(petsclib::PetscLibType,mat::PetscMat, l::PetscVec, r::PetscVec)</code></pre><p>Scales a matrix on the left and right by diagonal matrices that are stored as vectors.  Either of the two scaling matrices can be <code>NULL</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix to be scaled</li><li><code>l</code>   - the left scaling vector (or <code>NULL</code>)</li><li><code>r</code>   - the right scaling vector (or <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatScale()</code>, <code>MatShift()</code>, <code>MatDiagonalSet()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalScale.html"><code>Mat/MatDiagonalScale</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4437-L4456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalScaleLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalScaleLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatDiagonalScaleLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalScaleLocal(petsclib::PetscLibType,mat::PetscMat, diag::PetscVec)</code></pre><p>Scales columns of a matrix given the scaling values including the ghosted ones.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>diag</code> - the diagonal values, including ghost ones</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDiagonalScale()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalScaleLocal.html"><code>Mat/MatDiagonalScaleLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7061-L7078">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDiagonalSet-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDiagonalSet-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatDiagonalSet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDiagonalSet(petsclib::PetscLibType,Y::PetscMat, D::PetscVec, is::InsertMode)</code></pre><p>Computes <code>Y</code> = <code>Y</code> + <code>D</code>, where <code>D</code> is a diagonal matrix that is represented as a vector. Or Y[i,i] = D[i] if <code>InsertMode</code> is <code>INSERT_VALUES</code>.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>Y</code>  - the input matrix</li><li><code>D</code>  - the diagonal matrix, represented as a vector</li><li><code>is</code> - <code>INSERT_VALUES</code> or <code>ADD_VALUES</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatShift()</code>, <code>MatScale()</code>, <code>MatDiagonalScale()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDiagonalSet.html"><code>Mat/MatDiagonalSet</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19833-L19852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatDuplicate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatDuplicateOption, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatDuplicate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatDuplicateOption, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatDuplicate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatDuplicate(petsclib::PetscLibType,mat::PetscMat, op::MatDuplicateOption, M::PetscMat)</code></pre><p>Duplicates a matrix including the non</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>op</code>  - One of <code>MAT_DO_NOT_COPY_VALUES</code>, <code>MAT_COPY_VALUES</code>, or <code>MAT_SHARE_NONZERO_PATTERN</code>.</li></ul><p>See the manual page for <code>MatDuplicateOption()</code> for an explanation of these options.</p><p>Output Parameter:</p><ul><li><code>M</code> - pointer to place new matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCopy()</code>, <code>MatConvert()</code>, <code>MatDuplicateOption</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatDuplicate.html"><code>Mat/MatDuplicate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3850-L3870">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatEliminateZeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatEliminateZeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatEliminateZeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatEliminateZeros(petsclib::PetscLibType,A::PetscMat, keep::PetscBool)</code></pre><p>eliminate the nondiagonal zero entries in place from the nonzero structure of a sparse <code>Mat</code> in place, meaning the same memory is used for the matrix, and no new memory is allocated.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>keep</code> - if for a given row of <code>A</code>, the diagonal coefficient is zero, indicates whether it should be left in the structure or eliminated as well</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateGraph()</code>, <code>MatFilter()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatEliminateZeros.html"><code>Mat/MatEliminateZeros</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8765-L8782">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Compares two matrices.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the matrices are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatEqual.html"><code>Mat/MatEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4400-L4419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorClearError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorClearError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorClearError</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorClearError(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>clears the error code in a factorization</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the factored matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroEntries()</code>, <code>MatFactor()</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code>, <code>MatFactorGetError()</code>, <code>MatFactorGetErrorZeroPivot()</code>, <code>MatGetErrorCode()</code>, <code>MatFactorError</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorClearError.html"><code>Mat/MatFactorClearError</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L907-L923">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorCreateSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorCreateSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorCreateSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S::PetscMat,status::MatFactorSchurStatus = MatFactorCreateSchurComplement(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Create a Schur complement matrix object using Schur data computed during the factorization step</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>      - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>S</code>      - location where to return the Schur complement, can be <code>NULL</code></li><li><code>status</code> - the status of the Schur complement matrix, can be <code>NULL</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorGetSchurComplement()</code>, <code>MatFactorSchurStatus</code>, <code>MATSOLVERMUMPS</code>, <code>MATSOLVERMKL_PARDISO</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorCreateSchurComplement.html"><code>Mat/MatFactorCreateSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7590-L7607">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorFactorizeSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorFactorizeSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorFactorizeSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorFactorizeSchurComplement(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Factorize the Schur complement matrix computed during the factorization step</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorInvertSchurComplement()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorFactorizeSchurComplement.html"><code>Mat/MatFactorFactorizeSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7794-L7809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetCanUseOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetCanUseOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorGetCanUseOrdering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatFactorGetCanUseOrdering(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Indicates if the factorization can use the ordering provided in <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if uses the ordering</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatGetFactorAvailable()</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetCanUseOrdering.html"><code>Mat/MatFactorGetCanUseOrdering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3694-L3712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorError}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorError}"><code>PETSc.LibPETSc.MatFactorGetError</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorGetError(petsclib::PetscLibType,mat::PetscMat, err::MatFactorError)</code></pre><p>gets the error code from a factorization</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the factored matrix</li></ul><p>Output Parameter:</p><ul><li><code>err</code> - the error code</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroEntries()</code>, <code>MatFactor()</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code>, <code>MatFactorClearError()</code>, <code>MatFactorGetErrorZeroPivot()</code>, <code>MatFactorError</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetError.html"><code>Mat/MatFactorGetError</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L872-L891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetErrorZeroPivot-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetErrorZeroPivot-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorGetErrorZeroPivot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pivot::PetscReal,row::PetscInt = MatFactorGetErrorZeroPivot(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>returns the pivot value that was determined to be zero and the row it occurred in</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the factored matrix</li></ul><p>Output Parameters:</p><ul><li><code>pivot</code> - the pivot value computed</li><li><code>row</code>   - the row that the zero pivot occurred. This row value must be interpreted carefully due to row reorderings and which processes</li></ul><p>the share the matrix</p><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroEntries()</code>, <code>MatFactor()</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code>, <code>MatFactorClearError()</code>, <code>MAT_FACTOR_NUMERIC_ZEROPIVOT</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetErrorZeroPivot.html"><code>Mat/MatFactorGetErrorZeroPivot</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L830-L852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetPreferredOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorType, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetPreferredOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorType, Ptr{Int8}}"><code>PETSc.LibPETSc.MatFactorGetPreferredOrdering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorGetPreferredOrdering(petsclib::PetscLibType,mat::PetscMat, ftype::MatFactorType, otype::MatOrderingType)</code></pre><p>The preferred ordering for a particular matrix factor object</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix obtained with <code>MatGetFactor()</code></li><li><code>ftype</code> - the factorization type to be used</li></ul><p>Output Parameter:</p><ul><li><code>otype</code> - the preferred ordering type</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorType</code>, <code>MatOrderingType</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatGetFactorAvailable()</code>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatCholeskyFactorSymbolic()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetPreferredOrdering.html"><code>Mat/MatFactorGetPreferredOrdering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3730-L3749">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}, Union{PETSc.LibPETSc.MatFactorSchurStatus, Ptr}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}, Union{PETSc.LibPETSc.MatFactorSchurStatus, Ptr}}"><code>PETSc.LibPETSc.MatFactorGetSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorGetSchurComplement(petsclib::PetscLibType,F::PetscMat, S::PetscMat, status::MatFactorSchurStatus)</code></pre><p>Gets access to a Schur complement matrix using the current Schur data within a factored matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>      - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>S</code>      - location where to return the Schur complement, can be <code>NULL</code></li><li><code>status</code> - the status of the Schur complement matrix, can be <code>NULL</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorRestoreSchurComplement()</code>, <code>MatFactorCreateSchurComplement()</code>, <code>MatFactorSchurStatus</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetSchurComplement.html"><code>Mat/MatFactorGetSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7627-L7644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorGetSolverType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorGetSolverType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorGetSolverType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type::MatSolverType = MatFactorGetSolverType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns name of the package providing the factorization routines</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix, must be a factored matrix</li></ul><p>Output Parameter:</p><ul><li><code>type</code> - the string name of the package (do not free this string)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatSolverType</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatGetFactorAvailable()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorGetSolverType.html"><code>Mat/MatFactorGetSolverType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3623-L3641">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorInfoInitialize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorInfoInitialize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatFactorInfoInitialize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorInfoInitialize(petsclib::PetscLibType,info::MatFactorInfo)</code></pre><p>Initializes a <code>MatFactorInfo</code> data structure with default values.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>info</code> - the <code>MatFactorInfo</code> data structure</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorInfo</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorInfoInitialize.html"><code>Mat/MatFactorInfoInitialize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7525-L7541">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorInvertSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorInvertSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatFactorInvertSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorInvertSchurComplement(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Invert the Schur complement matrix computed during the factorization step</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorGetSchurComplement()</code>, <code>MatFactorCreateSchurComplement()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorInvertSchurComplement.html"><code>Mat/MatFactorInvertSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7763-L7778">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorRestoreSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorSchurStatus}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorRestoreSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorSchurStatus}"><code>PETSc.LibPETSc.MatFactorRestoreSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorRestoreSchurComplement(petsclib::PetscLibType,F::PetscMat, S::PetscMat, status::MatFactorSchurStatus)</code></pre><p>Restore the Schur complement matrix object obtained from a call to <code>MatFactorGetSchurComplement()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>      - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>S</code>      - location where the Schur complement is stored</li><li><code>status</code> - the status of the Schur complement matrix (see <code>MatFactorSchurStatus</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorCreateSchurComplement()</code>, <code>MatFactorSchurStatus</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorRestoreSchurComplement.html"><code>Mat/MatFactorRestoreSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7662-L7679">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorSetSchurIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorSetSchurIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatFactorSetSchurIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorSetSchurIS(petsclib::PetscLibType,mat::PetscMat, is::IS)</code></pre><p>Set indices corresponding to the Schur complement you wish to have computed</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>is</code>  - the index set defining the Schur indices (0-based)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorGetSchurComplement()</code>, <code>MatFactorRestoreSchurComplement()</code>, <code>MatFactorCreateSchurComplement()</code>, <code>MatFactorSolveSchurComplement()</code>, <code>MatFactorSolveSchurComplementTranspose()</code>, <code>MATSOLVERMUMPS</code>, <code>MATSOLVERMKL_PARDISO</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorSetSchurIS.html"><code>Mat/MatFactorSetSchurIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7557-L7574">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorSolveSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorSolveSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatFactorSolveSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorSolveSchurComplement(petsclib::PetscLibType,F::PetscMat, rhs::PetscVec, sol::PetscVec)</code></pre><p>Solve the Schur complement system computed during the factorization step</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>   - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>rhs</code> - location where the right-hand side of the Schur complement system is stored</li><li><code>sol</code> - location where the solution of the Schur complement system has to be returned</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorSolveSchurComplementTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorSolveSchurComplement.html"><code>Mat/MatFactorSolveSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7730-L7747">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFactorSolveSchurComplementTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFactorSolveSchurComplementTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatFactorSolveSchurComplementTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFactorSolveSchurComplementTranspose(petsclib::PetscLibType,F::PetscMat, rhs::PetscVec, sol::PetscVec)</code></pre><p>Solve the transpose of the Schur complement system computed during the factorization step</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>   - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>rhs</code> - location where the right-hand side of the Schur complement system is stored</li><li><code>sol</code> - location where the solution of the Schur complement system has to be returned</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatFactorSetSchurIS()</code>, <code>MatFactorSolveSchurComplement()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFactorSolveSchurComplementTranspose.html"><code>Mat/MatFactorSolveSchurComplementTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7697-L7714">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFilter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFilter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatFilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFilter(petsclib::PetscLibType,A::PetscMat, tol::PetscReal, compress::PetscBool, keep::PetscBool)</code></pre><p>Set all values in the matrix with an absolute value less than or equal to the tolerance to zero, and optionally compress the underlying storage</p><p>Input Parameters:</p><ul><li><code>A</code>        - The matrix</li><li><code>tol</code>      - The zero tolerance</li><li><code>compress</code> - Whether the storage from the input matrix <code>A</code> should be compressed once values less than or equal to <code>tol</code> are set to zero</li><li><code>keep</code>     - If <code>compress</code> is true and for a given row of <code>A</code>, the diagonal coefficient is less than or equal to <code>tol</code>, indicates whether it should be left in the structure or eliminated as well</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatZeroEntries()</code>, <code>MatEliminateZeros()</code>, <code>VecFilter()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFilter.html"><code>Mat/MatFilter</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19977-L19993">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFinalizePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFinalizePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><code>PETSc.LibPETSc.MatFinalizePackage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFinalizePackage(petsclib::PetscLibType)</code></pre><p>This function destroys everything in the PETSc interface to the <code>Mat</code> package. It is called from <code>PetscFinalize()</code>.</p><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>PetscFinalize()</code>, <code>MatInitializePackage()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFinalizePackage.html"><code>Mat/MatFinalizePackage</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L712-L723">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFindNonzeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFindNonzeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatFindNonzeroRows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFindNonzeroRows(petsclib::PetscLibType,mat::PetscMat, keptrows::IS)</code></pre><p>Locate all rows that are not completely zero in the matrix</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>keptrows</code> - the rows that are not completely zero</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatFindZeroRows()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFindNonzeroRows.html"><code>Mat/MatFindNonzeroRows</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L939-L955">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFindOffBlockDiagonalEntries-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFindOffBlockDiagonalEntries-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatFindOffBlockDiagonalEntries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFindOffBlockDiagonalEntries(petsclib::PetscLibType,mat::PetscMat, is::IS)</code></pre><p>Finds all the rows of a matrix that have entries outside of the main diagonal block (defined by the matrix block size)</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>is</code> - contains the list of rows with off block diagonal entries</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFindOffBlockDiagonalEntries.html"><code>Mat/MatFindOffBlockDiagonalEntries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8253-L8271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFindZeroDiagonals-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFindZeroDiagonals-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatFindZeroDiagonals</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFindZeroDiagonals(petsclib::PetscLibType,mat::PetscMat, is::IS)</code></pre><p>Finds all the rows of a matrix that have zero or no diagonal entry in the matrix</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>is</code> - if any rows have zero diagonals this contains the list of them</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFindZeroDiagonals.html"><code>Mat/MatFindZeroDiagonals</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8219-L8237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFindZeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFindZeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatFindZeroRows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFindZeroRows(petsclib::PetscLibType,mat::PetscMat, zerorows::IS)</code></pre><p>Locate all rows that are completely zero in the matrix</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>zerorows</code> - the rows that are completely zero</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatFindNonzeroRows()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFindZeroRows.html"><code>Mat/MatFindZeroRows</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L971-L987">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatForwardSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatForwardSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatForwardSolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatForwardSolve(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, x::PetscVec)</code></pre><p>Solves  L x = b , given a factored matrix, A = LU , or U^T<em>D^(1/2) x = b, given a factored symmetric matrix, A = U^T</em>D*U,</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatBackwardSolve()</code>, <code>MatGetFactor()</code>, <code>MatSolve()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatForwardSolve.html"><code>Mat/MatForwardSolve</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3313-L3333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGalerkin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGalerkin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGalerkin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGalerkin(petsclib::PetscLibType,restrct::PetscMat, dA::PetscMat, interpolate::PetscMat, reuse::MatReuse, fill::PetscReal, A::PetscMat)</code></pre><p>Constructs the coarse grid problem matrix via Galerkin projection.</p><p>If the interpolation and restriction operators are the same, uses <code>MatPtAP()</code>. If they are not the same, uses <code>MatMatMatMult()</code>.</p><p>Once the coarse grid problem is constructed, correct for interpolation operators that are not of full rank, which can legitimately happen in the case of non-nested geometric multigrid.</p><p>Input Parameters:</p><ul><li><code>restrct</code>     - restriction operator</li><li><code>dA</code>          - fine grid matrix</li><li><code>interpolate</code> - interpolation operator</li><li><code>reuse</code>       - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>        - expected fill, use <code>PETSC_DETERMINE</code> or <code>PETSC_DETERMINE</code> if you do not have a good estimate</li></ul><p>Output Parameter:</p><ul><li><code>A</code> - the Galerkin coarse matrix</li></ul><p>Options Database Key:</p><ul><li><code>-pc_mg_galerkin &lt;both,pmat,mat,none&gt;</code> - for what matrices the Galerkin process should be used</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPtAP()</code>, <code>MatMatMatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGalerkin.html"><code>Mat/MatGalerkin</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8581-L8611">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetBindingPropagates-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetBindingPropagates-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetBindingPropagates</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatGetBindingPropagates(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Gets whether the state of being bound to the CPU for a GPU matrix type propagates to child and some other associated objects</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - flag indicating whether the boundtocpu flag will be propagated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetBindingPropagates()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetBindingPropagates.html"><code>Mat/MatGetBindingPropagates</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19696-L19712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetBlockSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bs::PetscInt = MatGetBlockSize(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the matrix block size.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>bs</code> - block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATBAIJ</code>, <code>MATSBAIJ</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetBlockSize.html"><code>Mat/MatGetBlockSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5812-L5830">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rbs::PetscInt,cbs::PetscInt = MatGetBlockSizes(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the matrix block row and column sizes.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>rbs</code> - row block size</li><li><code>cbs</code> - column block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATBAIJ</code>, <code>MATSBAIJ</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSize()</code>, <code>MatSetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetBlockSizes.html"><code>Mat/MatGetBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5848-L5867">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetBrowsOfAcols-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetBrowsOfAcols-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetBrowsOfAcols</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetBrowsOfAcols(petsclib::PetscLibType,A::PetscMat, B::PetscMat, scall::MatReuse, rowb::IS, colb::IS, B_seq::PetscMat)</code></pre><p>Returns <code>IS</code> that contain rows of <code>B</code> that equal to nonzero columns of local <code>A</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the first matrix in <code>MATMPIAIJ</code> format</li><li><code>B</code>     - the second matrix in <code>MATMPIAIJ</code> format</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameters:</p><ul><li><code>rowb</code>  - On input index sets of rows of B to extract (or <code>NULL</code>), modified on output</li><li><code>colb</code>  - On input index sets of columns of B to extract (or <code>NULL</code>), modified on output</li><li><code>B_seq</code> - the sequential matrix generated</li></ul><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>MATMPIAIJ</code>, <code>IS</code>, <code>MatReuse</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetBrowsOfAcols.html"><code>Mat/MatGetBrowsOfAcols</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16079-L16101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatGetColumnIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,ia::Vector{PetscInt},ja::Vector{PetscInt},done::PetscBool = MatGetColumnIJ(petsclib::PetscLibType,mat::PetscMat, shift::PetscInt, symmetric::PetscBool, inodecompressed::PetscBool)</code></pre><p>Returns the compressed column storage i and j indices for sequential matrices.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>             - the matrix</li><li><code>shift</code>           - 1 or zero indicating we want the indices starting at 0 or 1</li><li><code>symmetric</code>       - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating the matrix data structure should be</li></ul><p>symmetrized</p><ul><li><code>inodecompressed</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating if the nonzero structure of the</li></ul><p>inodes or the nonzero elements is wanted. For <code>MATBAIJ</code> matrices the compressed version is always used.</p><p>Output Parameters:</p><ul><li><code>n</code>    - number of columns in the (possibly compressed) matrix</li><li><code>ia</code>   - the column pointers; that is ia[0] = 0, ia[col] = i[col-1] + number of elements in that col of the matrix</li><li><code>ja</code>   - the row indices</li><li><code>done</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code>, indicating whether the values have been returned</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRowIJ()</code>, <code>MatRestoreColumnIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnIJ.html"><code>Mat/MatGetColumnIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6247-L6274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnMeans-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnMeans-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnMeans</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnMeans(petsclib::PetscLibType,A::PetscMat, means::Vector{PetscScalar})</code></pre><p>Gets the arithmetic means of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>means</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>VecSum()</code>, <code>MatGetColumnSums()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnMeans.html"><code>Mat/MatGetColumnMeans</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19069-L19085">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnMeansImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnMeansImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnMeansImaginaryPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnMeansImaginaryPart(petsclib::PetscLibType,A::PetscMat, means::Vector{PetscReal})</code></pre><p>Gets the arithmetic means of the imaginary part of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>means</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetColumnMeansRealPart()</code>, <code>VecSum()</code>, <code>MatGetColumnSums()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnMeansImaginaryPart.html"><code>Mat/MatGetColumnMeansImaginaryPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19037-L19053">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnMeansRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnMeansRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnMeansRealPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnMeansRealPart(petsclib::PetscLibType,A::PetscMat, means::Vector{PetscReal})</code></pre><p>Gets the arithmetic means of the real part of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>means</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetColumnMeansImaginaryPart()</code>, <code>VecSum()</code>, <code>MatGetColumnSums()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnMeansRealPart.html"><code>Mat/MatGetColumnMeansRealPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19005-L19021">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnNorms-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.NormType, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnNorms-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.NormType, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnNorms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnNorms(petsclib::PetscLibType,A::PetscMat, type::NormType, norms::Vector{PetscReal})</code></pre><p>Gets the norms of each column of a sparse or dense matrix.</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>type</code> - <code>NORM_2</code>, <code>NORM_1</code> or <code>NORM_INFINITY</code></li></ul><p>Output Parameter:</p><ul><li><code>norms</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>NormType</code>, <code>MatNorm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnNorms.html"><code>Mat/MatGetColumnNorms</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18876-L18893">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnReductions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnReductions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnReductions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnReductions(petsclib::PetscLibType,A::PetscMat, type::PetscInt, reductions::Vector{PetscReal})</code></pre><p>Gets the reductions of each column of a sparse or dense matrix.</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>type</code> - A constant defined in <code>NormType</code> or <code>ReductionType</code>: <code>NORM_2</code>, <code>NORM_1</code>, <code>NORM_INFINITY</code>, <code>REDUCTION_SUM_REALPART</code>,</li></ul><p><code>REDUCTION_SUM_IMAGINARYPART</code>, <code>REDUCTION_MEAN_REALPART</code>, <code>REDUCTION_MEAN_IMAGINARYPART</code></p><p>Output Parameter:</p><ul><li><code>reductions</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>ReductionType</code>, <code>NormType</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnSums()</code>, <code>MatGetColumnMeans()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnReductions.html"><code>Mat/MatGetColumnReductions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19101-L19119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnSums-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnSums-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnSums</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnSums(petsclib::PetscLibType,A::PetscMat, sums::Vector{PetscScalar})</code></pre><p>Gets the sums of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>sums</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>VecSum()</code>, <code>MatGetColumnMeans()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnSums.html"><code>Mat/MatGetColumnSums</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18973-L18989">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnSumsImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnSumsImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnSumsImaginaryPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnSumsImaginaryPart(petsclib::PetscLibType,A::PetscMat, sums::Vector{PetscReal})</code></pre><p>Gets the sums of the imaginary part of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>sums</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetColumnSumsRealPart()</code>, <code>VecSum()</code>, <code>MatGetColumnMeans()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnSumsImaginaryPart.html"><code>Mat/MatGetColumnSumsImaginaryPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18941-L18957">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnSumsRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnSumsRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetColumnSumsRealPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnSumsRealPart(petsclib::PetscLibType,A::PetscMat, sums::Vector{PetscReal})</code></pre><p>Gets the sums of the real part of each column of a sparse or dense matrix.</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>sums</code> - an array as large as the TOTAL number of columns in the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetColumnSumsImaginaryPart()</code>, <code>VecSum()</code>, <code>MatGetColumnMeans()</code>, <code>MatGetColumnNorms()</code>, <code>MatGetColumnReductions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnSumsRealPart.html"><code>Mat/MatGetColumnSumsRealPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18909-L18925">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetColumnVector-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetColumnVector-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Int64}"><code>PETSc.LibPETSc.MatGetColumnVector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetColumnVector(petsclib::PetscLibType,A::PetscMat, yy::PetscVec, col::PetscInt)</code></pre><p>Gets the values from a given column of a matrix.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>yy</code>  - the vector</li><li><code>col</code> - the column requested (in global numbering)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRow()</code>, <code>MatGetDiagonal()</code>, <code>MatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetColumnVector.html"><code>Mat/MatGetColumnVector</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18843-L18860">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetCurrentMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetCurrentMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetCurrentMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscMemType = MatGetCurrentMemType(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get the memory location of the matrix</p><p>Not Collective, but the result will be the same on all MPI processes</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix whose memory type we are checking</li></ul><p>Output Parameter:</p><ul><li><code>m</code> - the memory type</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatBoundToCPU()</code>, <code>PetscMemType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetCurrentMemType.html"><code>Mat/MatGetCurrentMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8798-L8816">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetDM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dm::PetscDM = MatGetDM(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Gets the <code>DM</code> defining the data layout of the matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - The <code>Mat</code></li></ul><p>Output Parameter:</p><ul><li><code>dm</code> - The <code>DM</code></li></ul><p>Level: intermediate</p><p>Note: A matrix may not have a <code>DM</code> associated with it</p><p>Developer Note: Since the <code>Mat</code> class doesn&#39;t know about the <code>DM</code> class the <code>DM</code> object is associated with the <code>Mat</code> through a <code>PetscObjectCompose()</code> operation</p><p><strong>See also:</strong></p><p><code>DM</code>, <code>MatSetDM()</code>, <code>DMCreateMatrix()</code>, <code>DMSetMatType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/DM/MatGetDM.html"><code>DM/MatGetDM</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22898-L22924">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatGetDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetDiagonal(petsclib::PetscLibType,mat::PetscMat, v::PetscVec)</code></pre><p>Gets the diagonal of a matrix as a <code>Vec</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the diagonal of the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>Vec</code>, <code>MatGetRow()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMaxAbs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetDiagonal.html"><code>Mat/MatGetDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3888-L3906">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetDiagonalBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetDiagonalBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetDiagonalBlock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetDiagonalBlock(petsclib::PetscLibType,A::PetscMat, a::PetscMat)</code></pre><p>Returns the part of the matrix associated with the on</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>a</code> - the diagonal part (which is a SEQUENTIAL matrix)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateAIJ()</code>, <code>MATAIJ</code>, <code>MATBAIJ</code>, <code>MATSBAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetDiagonalBlock.html"><code>Mat/MatGetDiagonalBlock</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1003-L1021">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatFactorType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatFactorType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetFactor(petsclib::PetscLibType,mat::PetscMat, type::MatSolverType, ftype::MatFactorType, f::PetscMat)</code></pre><p>Returns a matrix suitable to calls to MatXXFactorSymbolic,Numeric()</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>type</code>  - name of solver type, for example, <code>superlu</code>, <code>petsc</code> (to use PETSc&#39;s solver if it is available), if this is &#39;NULL&#39;, then the first result that satisfies</li></ul><p>the other criteria is returned</p><ul><li><code>ftype</code> - factor type, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ICC</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_QR</code></li></ul><p>Output Parameter:</p><ul><li><code>f</code> - the factor matrix used with MatXXFactorSymbolic,Numeric() calls. Can be <code>NULL</code> in some cases, see notes below.</li></ul><p>Options Database Keys:</p><ul><li><code>-pc_factor_mat_solver_type &lt;type&gt;</code>    - choose the type at run time. When using <code>KSP</code> solvers</li><li><code>-pc_factor_mat_factor_on_host &lt;bool&gt;</code> - do mat factorization on host (with device matrices). Default is doing it on device</li><li><code>-pc_factor_mat_solve_on_host &lt;bool&gt;</code>  - do mat solve on host (with device matrices). Default is doing it on device</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>KSP</code>, <code>MatSolverType</code>, <code>MatFactorType</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatGetFactorAvailable()</code>, <code>MatFactorGetCanUseOrdering()</code>, <code>MatSolverTypeRegister()</code>, <code>MatSolverTypeGet()</code> <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ICC</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_QR</code>, <code>MatInitializePackage()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetFactor.html"><code>Mat/MatGetFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3765-L3793">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetFactorAvailable-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatFactorType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetFactorAvailable-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.MatFactorType}"><code>PETSc.LibPETSc.MatGetFactorAvailable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatGetFactorAvailable(petsclib::PetscLibType,mat::PetscMat, type::MatSolverType, ftype::MatFactorType)</code></pre><p>Returns a flag if matrix supports particular type and factor type</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>type</code>  - name of solver type, for example, <code>superlu</code>, <code>petsc</code> (to use PETSc&#39;s default)</li><li><code>ftype</code> - factor type, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ICC</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_QR</code></li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - PETSC_TRUE if the factorization is available</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatSolverType</code>, <code>MatFactorType</code>, <code>MatGetFactor()</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatSolverTypeRegister()</code>, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ICC</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_QR</code>, <code>MatSolverTypeGet()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetFactorAvailable.html"><code>Mat/MatGetFactorAvailable</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3811-L3832">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetFactorType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetFactorType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetFactorType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">t::MatFactorType = MatGetFactorType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>gets the type of factorization a matrix is</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>t</code> - the type, one of <code>MAT_FACTOR_NONE</code>, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_ICC,MAT_FACTOR_ILUDT</code>, <code>MAT_FACTOR_QR</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorType</code>, <code>MatGetFactor()</code>, <code>MatSetFactorType()</code>, <code>MAT_FACTOR_NONE</code>, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_ICC</code>,<code>MAT_FACTOR_ILUDT</code>, <code>MAT_FACTOR_QR</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetFactorType.html"><code>Mat/MatGetFactorType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2734-L2753">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetGhosts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetGhosts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetGhosts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nghosts::PetscInt,ghosts::Vector{PetscInt} = MatGetGhosts(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Get the global indices of all ghost nodes defined by the sparse matrix</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>nghosts</code> - number of ghosts (for <code>MATBAIJ</code> and <code>MATSBAIJ</code> matrices there is one ghost for each matrix block)</li><li><code>ghosts</code>  - the global indices of the ghost points</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>VecCreateGhost()</code>, <code>VecCreateGhostBlock()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetGhosts.html"><code>Mat/MatGetGhosts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1106-L1125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetInertia-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetInertia-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetInertia</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nneg::PetscInt,nzero::PetscInt,npos::PetscInt = MatGetInertia(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets the inertia from a factored matrix</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>nneg</code>  - number of negative eigenvalues</li><li><code>nzero</code> - number of zero eigenvalues</li><li><code>npos</code>  - number of positive eigenvalues</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetInertia.html"><code>Mat/MatGetInertia</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7094-L7114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatInfoType, PETSc.LibPETSc.MatInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatInfoType, PETSc.LibPETSc.MatInfo}"><code>PETSc.LibPETSc.MatGetInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetInfo(petsclib::PetscLibType,mat::PetscMat, flag::MatInfoType, info::MatInfo)</code></pre><p>Returns information about matrix storage (number of nonzeros, memory, etc.).</p><p>Collective if <code>MAT_GLOBAL_MAX</code> or <code>MAT_GLOBAL_SUM</code> is used as the flag</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>flag</code> - flag indicating the type of parameters to be returned (<code>MAT_LOCAL</code> - local matrix, <code>MAT_GLOBAL_MAX</code> - maximum over all processors, <code>MAT_GLOBAL_SUM</code> - sum over all processors)</li></ul><p>Output Parameter:</p><ul><li><code>info</code> - matrix information context</li></ul><p>Options Database Key:</p><ul><li><code>-mat_view ::ascii_info</code> - print matrix info to <code>PETSC_STDOUT</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInfo</code>, <code>MatStashGetInfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetInfo.html"><code>Mat/MatGetInfo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2804-L2827">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PetscLayout}, Ptr{PETSc.LibPETSc._n_PetscLayout}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PetscLayout}, Ptr{PETSc.LibPETSc._n_PetscLayout}}"><code>PETSc.LibPETSc.MatGetLayouts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetLayouts(petsclib::PetscLibType,A::PetscMat, rmap::PetscLayout, cmap::PetscLayout)</code></pre><p>Gets the <code>PetscLayout</code> objects for rows and columns</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>rmap</code> - row layout</li><li><code>cmap</code> - column layout</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matlayout">Matrix Layouts</a>, <code>PetscLayout</code>, <code>MatCreateVecs()</code>, <code>MatGetLocalToGlobalMapping()</code>, <code>MatSetLayouts()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetLayouts.html"><code>Mat/MatGetLayouts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2371-L2390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetLocalSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetLocalSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetLocalSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt = MatGetLocalSize(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>For most matrix formats, excluding <code>MATELEMENTAL</code> and <code>MATSCALAPACK</code>, Returns the number of local rows and local columns of a matrix. For all matrices this is the local size of the left and right vectors as returned by <code>MatCreateVecs()</code>.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of local rows, use <code>NULL</code> to not obtain this value</li><li><code>n</code> - the number of local columns, use <code>NULL</code> to not obtain this value</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetSizes()</code>, <code>MatGetSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetLocalSize.html"><code>Mat/MatGetLocalSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5213-L5233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetLocalSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetLocalSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetLocalSubMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetLocalSubMatrix(petsclib::PetscLibType,mat::PetscMat, isrow::IS, iscol::IS, submat::PetscMat)</code></pre><p>Gets a reference to a submatrix specified in local numbering</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - matrix to extract local submatrix from</li><li><code>isrow</code> - local row indices for submatrix</li><li><code>iscol</code> - local column indices for submatrix</li></ul><p>Output Parameter:</p><ul><li><code>submat</code> - the submatrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRestoreLocalSubMatrix()</code>, <code>MatCreateLocalRef()</code>, <code>MatSetLocalToGlobalMapping()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetLocalSubMatrix.html"><code>Mat/MatGetLocalSubMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8145-L8165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><code>PETSc.LibPETSc.MatGetLocalToGlobalMapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetLocalToGlobalMapping(petsclib::PetscLibType,A::PetscMat, rmapping::ISLocalToGlobalMapping, cmapping::ISLocalToGlobalMapping)</code></pre><p>Gets the local</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>rmapping</code> - row mapping</li><li><code>cmapping</code> - column mapping</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatSetValuesLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetLocalToGlobalMapping.html"><code>Mat/MatGetLocalToGlobalMapping</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2303-L2322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetMultiProcBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, MPI.Comm, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetMultiProcBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, MPI.Comm, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetMultiProcBlock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetMultiProcBlock(petsclib::PetscLibType,mat::PetscMat, subComm::MPI_Comm, scall::MatReuse, subMat::PetscMat)</code></pre><p>Create multiple &#39;parallel submatrices&#39; from a given <code>Mat</code>. Each submatrix can span multiple procs.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>subComm</code> - the sub communicator obtained as if by <code>MPI_Comm_split(PetscObjectComm((PetscObject)mat))</code></li><li><code>scall</code>   - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>subMat</code> - parallel sub-matrices each spanning a given <code>subcomm</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateRedundantMatrix()</code>, <code>MatCreateSubMatrices()</code>, <code>PCBJACOBI</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetMultiProcBlock.html"><code>Mat/MatGetMultiProcBlock</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8106-L8127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetNearNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetNearNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatGetNearNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetNearNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>Get null space attached with <code>MatSetNearNullSpace()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>nullsp</code> - the null space object, <code>NULL</code> if not set</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatSetNearNullSpace()</code>, <code>MatGetNullSpace()</code>, <code>MatNullSpaceCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetNearNullSpace.html"><code>Mat/MatGetNearNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6994-L7012">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetNonzeroState-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetNonzeroState-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatGetNonzeroState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetNonzeroState(petsclib::PetscLibType,mat::PetscMat, state::PetscObjectState)</code></pre><p>Returns a 64 matrix has had new nonzero locations added to (or removed from) the matrix since the previous call, the value will be larger.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>state</code> - the current state</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscObjectStateGet()</code>, <code>PetscObjectGetId()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetNonzeroState.html"><code>Mat/MatGetNonzeroState</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8466-L8485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatGetNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>retrieves the null space of a matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>nullsp</code> - the null space object</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatSetNullSpace()</code>, <code>MatNullSpace</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetNullSpace.html"><code>Mat/MatGetNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6760-L6776">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetNullSpaces-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}, Vector{Ptr{PETSc.LibPETSc._n_MatNullSpace}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetNullSpaces-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}, Vector{Ptr{PETSc.LibPETSc._n_MatNullSpace}}}"><code>PETSc.LibPETSc.MatGetNullSpaces</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetNullSpaces(petsclib::PetscLibType,n::PetscInt, mat::Vector{PetscMat}, nullsp::Vector{MatNullSpace})</code></pre><p>gets the null spaces, transpose null spaces, and near null spaces from an array of matrices</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>n</code>   - the number of matrices</li><li><code>mat</code> - the array of matrices</li></ul><p>Output Parameters:</p><ul><li><code>nullsp</code> - an array of null spaces, <code>NULL</code> for each matrix that does not have a null space, length 3 * <code>n</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatGetNullSpace()</code>, <code>MatSetTransposeNullSpace()</code>, <code>MatGetTransposeNullSpace()</code>, <code>MatNullSpaceRemove()</code>, <code>MatRestoreNullSpaces()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetNullSpaces.html"><code>Mat/MatGetNullSpaces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6792-L6812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOption-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOption}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOption-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOption}"><code>PETSc.LibPETSc.MatGetOption</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatGetOption(petsclib::PetscLibType,mat::PetscMat, op::MatOption)</code></pre><p>Gets a parameter option that has been set for a matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>op</code>  - the option, this only responds to certain options, check the code for which ones</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - turn the option on (<code>PETSC_TRUE</code>) or off (<code>PETSC_FALSE</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatOption</code>, <code>MatSetOption()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatIsSymmetricKnown()</code>, <code>MatIsHermitianKnown()</code>, <code>MatIsStructurallySymmetricKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOption.html"><code>Mat/MatGetOption</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4728-L4748">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatGetOptionsPrefix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetOptionsPrefix(petsclib::PetscLibType,A::PetscMat, prefix::Vector{Cchar})</code></pre><p>Gets the prefix used for searching for all matrix options in the database.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>prefix</code> - pointer to the prefix string used</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAppendOptionsPrefix()</code>, <code>MatSetOptionsPrefix()</code>, <code>MatAppendOptionsPrefixFactor()</code>, <code>MatSetOptionsPrefixFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOptionsPrefix.html"><code>Mat/MatGetOptionsPrefix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1529-L1548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOrdering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatGetOrdering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetOrdering(petsclib::PetscLibType,mat::PetscMat, type::MatOrderingType, rperm::IS, cperm::IS)</code></pre><p>Gets a reordering for a matrix to reduce fill or to improve numerical stability of LU factorization.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>type</code> - type of reordering, one of the following</li></ul><p>-seealso: <code>MatOrderingRegister()</code>, <code>PCFactorSetMatOrderingType()</code>, <code>MatColoring</code>, <code>MatColoringCreate()</code>, <code>MatOrderingType</code>, <code>Mat</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOrdering.html"><code>Mat/MatGetOrdering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20569-L20583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOrderingList-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_PetscFunctionList}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOrderingList-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_PetscFunctionList}}"><code>PETSc.LibPETSc.MatGetOrderingList</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetOrderingList(petsclib::PetscLibType,list::PetscFunctionList)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOrderingList.html"><code>Mat/MatGetOrderingList</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20599-L20604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOwnershipIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOwnershipIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatGetOwnershipIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetOwnershipIS(petsclib::PetscLibType,A::PetscMat, rows::IS, cols::IS)</code></pre><p>Get row and column ownership of a matrices&#39; values as index sets.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - matrix</li></ul><p>Output Parameters:</p><ul><li><code>rows</code> - rows in which this process owns elements, , use <code>NULL</code> to not obtain this value</li><li><code>cols</code> - columns in which this process owns elements, use <code>NULL</code> to not obtain this value</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>IS</code>, <code>Mat</code>, <code>MatGetOwnershipRanges()</code>, <code>MatSetValues()</code>, <code>MATELEMENTAL</code>, <code>MATSCALAPACK</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOwnershipIS.html"><code>Mat/MatGetOwnershipIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5414-L5433">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOwnershipRange-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOwnershipRange-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetOwnershipRange</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt = MatGetOwnershipRange(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>For matrices that own values by row, excludes <code>MATELEMENTAL</code> and <code>MATSCALAPACK</code>, returns the range of matrix rows owned by this MPI process.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the global index of the first local row, use <code>NULL</code> to not obtain this value</li><li><code>n</code> - one more than the global index of the last local row, use <code>NULL</code> to not obtain this value</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscSplitOwnership()</code>, <code>PetscSplitOwnershipBlock()</code>, <code>PetscLayout</code>, <code>MatSetSizes()</code>, <code>MatCreateAIJ()</code>, <code>DMDAGetGhostCorners()</code>, <code>DM</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOwnershipRange.html"><code>Mat/MatGetOwnershipRange</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5294-L5315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOwnershipRangeColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOwnershipRangeColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetOwnershipRangeColumn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt = MatGetOwnershipRangeColumn(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the range of matrix columns associated with rows of a vector one multiplies this matrix by that are owned by this processor.</p><p>Not Collective, unless matrix has not been allocated, then collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the global index of the first local column, use <code>NULL</code> to not obtain this value</li><li><code>n</code> - one more than the global index of the last local column, use <code>NULL</code> to not obtain this value</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code>, <code>MatSetSizes()</code>, <code>MatCreateAIJ()</code>, <code>DMDAGetGhostCorners()</code>, <code>DM</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOwnershipRangeColumn.html"><code>Mat/MatGetOwnershipRangeColumn</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5253-L5274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOwnershipRanges-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOwnershipRanges-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetOwnershipRanges</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ranges::Vector{PetscInt} = MatGetOwnershipRanges(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>For matrices that own values by row, excludes <code>MATELEMENTAL</code> and <code>MATSCALAPACK</code>, returns the range of matrix rows owned by each process.</p><p>Not Collective, unless matrix has not been allocated</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>ranges</code> - start of each processors portion plus one more than the total length at the end, of length <code>size</code> + 1</li></ul><p>where <code>size</code> is the number of MPI processes used by <code>mat</code></p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code>, <code>PetscSplitOwnership()</code>, <code>PetscSplitOwnershipBlock()</code>, <code>MatSetSizes()</code>, <code>MatCreateAIJ()</code>, <code>DMDAGetGhostCorners()</code>, <code>DM</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOwnershipRanges.html"><code>Mat/MatGetOwnershipRanges</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5335-L5357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetOwnershipRangesColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetOwnershipRangesColumn-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetOwnershipRangesColumn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ranges::Vector{PetscInt} = MatGetOwnershipRangesColumn(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the ranges of matrix columns associated with rows of a vector one multiplies this vector by that are owned by each processor.</p><p>Not Collective, unless matrix has not been allocated</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>ranges</code> - start of each processors portion plus one more than the total length at the end</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRanges()</code>, <code>PetscSplitOwnership()</code>, <code>PetscSplitOwnershipBlock()</code>, <code>PetscLayout</code>, <code>MatSetSizes()</code>, <code>MatCreateAIJ()</code>, <code>DMDAGetGhostCorners()</code>, <code>DM</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetOwnershipRangesColumn.html"><code>Mat/MatGetOwnershipRangesColumn</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5375-L5396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatGetRow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ncols::PetscInt,cols::Vector{PetscInt},vals::Vector{PetscScalar} = MatGetRow(petsclib::PetscLibType,mat::PetscMat, row::PetscInt)</code></pre><p>Gets a row of a matrix.  You MUST call <code>MatRestoreRow()</code> for each row that you get to ensure that your application does not bleed memory.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>row</code> - the row to get</li></ul><p>Output Parameters:</p><ul><li><code>ncols</code> - if not <code>NULL</code>, the number of nonzeros in <code>row</code></li><li><code>cols</code>  - if not <code>NULL</code>, the column numbers</li><li><code>vals</code>  - if not <code>NULL</code>, the numerical values</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRestoreRow()</code>, <code>MatSetValues()</code>, <code>MatGetValues()</code>, <code>MatCreateSubMatrices()</code>, <code>MatGetDiagonal()</code>, <code>MatGetRowIJ()</code>, <code>MatRestoreRowIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRow.html"><code>Mat/MatGetRow</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1215-L1238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatGetRowIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,ia::Vector{PetscInt},ja::Vector{PetscInt},done::PetscBool = MatGetRowIJ(petsclib::PetscLibType,mat::PetscMat, shift::PetscInt, symmetric::PetscBool, inodecompressed::PetscBool)</code></pre><p>Returns the compressed row storage i and j indices for the local rows of a sparse matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>             - the matrix</li><li><code>shift</code>           - 0 or 1 indicating we want the indices starting at 0 or 1</li><li><code>symmetric</code>       - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating the matrix data structure should be symmetrized</li><li><code>inodecompressed</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code>  indicating if the nonzero structure of the</li></ul><p>inodes or the nonzero elements is wanted. For <code>MATBAIJ</code> matrices the compressed version is always used.</p><p>Output Parameters:</p><ul><li><code>n</code>    - number of local rows in the (possibly compressed) matrix, use <code>NULL</code> if not needed</li><li><code>ia</code>   - the row pointers; that is ia[0] = 0, ia[row] = ia[row-1] + number of elements in that row of the matrix, use <code>NULL</code> if not needed</li><li><code>ja</code>   - the column indices, use <code>NULL</code> if not needed</li><li><code>done</code> - indicates if the routine actually worked and returned appropriate ia[] and ja[] arrays; callers</li></ul><p>are responsible for handling the case when done == <code>PETSC_FALSE</code> and ia and ja are not set</p><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATAIJ</code>, <code>MatGetColumnIJ()</code>, <code>MatRestoreRowIJ()</code>, <code>MatSeqAIJGetArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowIJ.html"><code>Mat/MatGetRowIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6196-L6223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowMax-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowMax-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><code>PETSc.LibPETSc.MatGetRowMax</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowMax(petsclib::PetscLibType,mat::PetscMat, v::PetscVec, idx::Vector{PetscInt})</code></pre><p>Gets the maximum value (of the real part) of each row of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>v</code>   - the vector for storing the maximums</li><li><code>idx</code> - the indices of the column found for each row (optional, otherwise pass <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMaxAbs()</code>, <code>MatGetRowMin()</code>, <code>MatGetRowMinAbs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowMax.html"><code>Mat/MatGetRowMax</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3995-L4015">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowMaxAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowMaxAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><code>PETSc.LibPETSc.MatGetRowMaxAbs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowMaxAbs(petsclib::PetscLibType,mat::PetscMat, v::PetscVec, idx::Vector{PetscInt})</code></pre><p>Gets the maximum value (in absolute value) of each row of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>v</code>   - the vector for storing the maximums</li><li><code>idx</code> - the indices of the column found for each row (or <code>NULL</code> if not needed)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowSum()</code>, <code>MatGetRowMin()</code>, <code>MatGetRowMinAbs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowMaxAbs.html"><code>Mat/MatGetRowMaxAbs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4031-L4051">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowMin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowMin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><code>PETSc.LibPETSc.MatGetRowMin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowMin(petsclib::PetscLibType,mat::PetscMat, v::PetscVec, idx::Vector{PetscInt})</code></pre><p>Gets the minimum value (of the real part) of each row of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>v</code>   - the vector for storing the maximums</li><li><code>idx</code> - the indices of the column found for each row (optional, pass <code>NULL</code> if not needed)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMaxAbs()</code>, <code>MatGetRowMinAbs()</code>, <code>MatGetRowMax()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowMin.html"><code>Mat/MatGetRowMin</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3922-L3943">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowMinAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowMinAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Vector{Int64}}"><code>PETSc.LibPETSc.MatGetRowMinAbs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowMinAbs(petsclib::PetscLibType,mat::PetscMat, v::PetscVec, idx::Vector{PetscInt})</code></pre><p>Gets the minimum value (in absolute value) of each row of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>v</code>   - the vector for storing the minimums</li><li><code>idx</code> - the indices of the column found for each row (or <code>NULL</code> if not needed)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMax()</code>, <code>MatGetRowMaxAbs()</code>, <code>MatGetRowMin()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowMinAbs.html"><code>Mat/MatGetRowMinAbs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3959-L3979">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowSum-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowSum-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatGetRowSum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowSum(petsclib::PetscLibType,mat::PetscMat, v::PetscVec)</code></pre><p>Gets the sum of each row of the matrix</p><p>Logically or Neighborhood Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the vector for storing the sum of rows</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMax()</code>, <code>MatGetRowMin()</code>, <code>MatGetRowMaxAbs()</code>, <code>MatGetRowMinAbs()</code>, <code>MatGetRowSumAbs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowSum.html"><code>Mat/MatGetRowSum</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4103-L4121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowSumAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowSumAbs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatGetRowSumAbs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowSumAbs(petsclib::PetscLibType,mat::PetscMat, v::PetscVec)</code></pre><p>Gets the sum value (in absolute value) of each row of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>v</code> - the vector for storing the sum</li></ul><p>Level: intermediate</p><p>This code is only implemented for a couple of matrix formats.</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetDiagonal()</code>, <code>MatCreateSubMatrices()</code>, <code>MatCreateSubMatrix()</code>, <code>MatGetRowMax()</code>, <code>MatGetRowMin()</code>, <code>MatGetRowMinAbs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowSumAbs.html"><code>Mat/MatGetRowSumAbs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4067-L4087">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetRowUpperTriangular-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetRowUpperTriangular-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetRowUpperTriangular</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetRowUpperTriangular(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Sets a flag to enable calls to <code>MatGetRow()</code> for matrix in <code>MATSBAIJ</code> format. You should call <code>MatRestoreRowUpperTriangular()</code> after calling<code>MatGetRow()</code> and <code>MatRestoreRow()</code> to disable the flag.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSBAIJ</code>, <code>MatRestoreRowUpperTriangular()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetRowUpperTriangular.html"><code>Mat/MatGetRowUpperTriangular</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1332-L1348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetSchurComplement-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetSchurComplement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetSchurComplement(petsclib::PetscLibType,A::PetscMat, isrow0::IS, iscol0::IS, isrow1::IS, iscol1::IS, mreuse::MatReuse, S::PetscMat, ainvtype::MatSchurComplementAinvType, preuse::MatReuse, Sp::PetscMat)</code></pre><p>Obtain the Schur complement from eliminating part of the matrix in another part.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>        - matrix in which the complement is to be taken</li><li><code>isrow0</code>   - rows to eliminate</li><li><code>iscol0</code>   - columns to eliminate, (isrow0,iscol0) should be square and nonsingular</li><li><code>isrow1</code>   - rows in which the Schur complement is formed</li><li><code>iscol1</code>   - columns in which the Schur complement is formed</li><li><code>mreuse</code>   - <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code>, use <code>MAT_IGNORE_MATRIX</code> to put nothing in <code>S</code></li><li><code>ainvtype</code> - the type of approximation used for the inverse of the (0,0) block used in forming <code>Sp</code>:</li></ul><p><code>MAT_SCHUR_COMPLEMENT_AINV_DIAG</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_LUMP</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_BLOCK_DIAG</code>, or <code>MAT_SCHUR_COMPLEMENT_AINV_FULL</code></p><ul><li><code>preuse</code>   - <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code>, use <code>MAT_IGNORE_MATRIX</code> to put nothing in <code>Sp</code></li></ul><p>Output Parameters:</p><ul><li><code>S</code>  - exact Schur complement, often of type <code>MATSCHURCOMPLEMENT</code> which is difficult to use for preconditioning</li><li><code>Sp</code> - approximate Schur complement from which a preconditioner can be built A11 - A10 inv(DIAGFORM(A00)) A01</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateSubMatrix()</code>, <code>PCFIELDSPLIT</code>, <code>MatCreateSchurComplement()</code>, <code>MatSchurComplementAinvType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatGetSchurComplement.html"><code>Ksp/MatGetSchurComplement</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22466-L22493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetSeqNonzeroStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetSeqNonzeroStructure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetSeqNonzeroStructure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetSeqNonzeroStructure(petsclib::PetscLibType,mat::PetscMat, matstruct::PetscMat)</code></pre><p>Extracts the nonzero structure from a matrix and stores it, in its entirety, on each process</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>matstruct</code> - the sequential matrix with the nonzero structure of <code>mat</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDestroySeqNonzeroStructure()</code>, <code>MatCreateSubMatrices()</code>, <code>MatDestroyMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetSeqNonzeroStructure.html"><code>Mat/MatGetSeqNonzeroStructure</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5665-L5683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><code>PETSc.LibPETSc.MatGetSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt = MatGetSize(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the numbers of rows and columns in a matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of global rows</li><li><code>n</code> - the number of global columns</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetSizes()</code>, <code>MatGetLocalSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetSize.html"><code>Mat/MatGetSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5174-L5193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetState-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetState-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatGetState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetState(petsclib::PetscLibType,A::PetscMat, state::PetscObjectState)</code></pre><p>Gets the state of a <code>Mat</code>. Same value as returned by <code>PetscObjectStateGet()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>state</code> - the object state</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>PetscObjectStateGet()</code>, <code>MatGetNonzeroState()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetState.html"><code>Mat/MatGetState</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1565-L1583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetTrace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetTrace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetTrace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trace::PetscScalar = MatGetTrace(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets the trace of a matrix. The sum of the diagonal entries.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>trace</code> - the sum of the diagonal entries</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetTrace.html"><code>Mat/MatGetTrace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1039-L1057">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetTransposeNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetTransposeNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatGetTransposeNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetTransposeNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>retrieves the null space of the transpose of a matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>nullsp</code> - the null space object</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatSetTransposeNullSpace()</code>, <code>MatSetNullSpace()</code>, <code>MatGetNullSpace()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetTransposeNullSpace.html"><code>Mat/MatGetTransposeNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6897-L6913">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><code>PETSc.LibPETSc.MatGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type::MatType = MatGetType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets the matrix type as a string from the matrix object.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>type</code> - name of matrix type</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MatSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetType.html"><code>Mat/MatGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L52-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetValue-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetValue-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatGetValue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">va::PetscScalar = MatGetValue(petsclib::PetscLibType,mat::PetscMat, row::PetscInt, col::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetValue.html"><code>Mat/MatGetValue</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23129-L23134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetValues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetValues(petsclib::PetscLibType,mat::PetscMat, m::PetscInt, idxm::Vector{PetscInt}, n::PetscInt, idxn::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Gets a block of local values from a matrix.</p><p>Not Collective; can only return values that are owned by the give process</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>v</code>    - a logically two-dimensional array for storing the values</li><li><code>m</code>    - the number of rows</li><li><code>idxm</code> - the  global indices of the rows</li><li><code>n</code>    - the number of columns</li><li><code>idxn</code> - the global indices of the columns</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRow()</code>, <code>MatCreateSubMatrices()</code>, <code>MatSetValues()</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetValuesLocal()</code>, <code>MatGetValue()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetValues.html"><code>Mat/MatGetValues</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2154-L2174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetValuesLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetValuesLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatGetValuesLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatGetValuesLocal(petsclib::PetscLibType,mat::PetscMat, nrow::PetscInt, irow::Vector{PetscInt}, ncol::PetscInt, icol::Vector{PetscInt}, y::Vector{PetscScalar})</code></pre><p>retrieves values from certain locations in a matrix using the local numbering of the indices defined previously by <code>MatSetLocalToGlobalMapping()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>nrow</code> - number of rows</li><li><code>irow</code> - the row local indices</li><li><code>ncol</code> - number of columns</li><li><code>icol</code> - the column local indices</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatSetValuesLocal()</code>, <code>MatGetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetValuesLocal.html"><code>Mat/MatGetValuesLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2190-L2215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetVariableBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nblocks::PetscInt,bsizes::Vector{PetscInt} = MatGetVariableBlockSizes(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets a diagonal blocks of the matrix that need not be of the same size</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>nblocks</code> - the number of blocks on this process</li><li><code>bsizes</code>  - the block sizes</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSizes()</code>, <code>MatGetBlockSizes()</code>, <code>MatSetVariableBlockSizes()</code>, <code>MatComputeVariableBlockEnvelope()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetVariableBlockSizes.html"><code>Mat/MatGetVariableBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6022-L6041">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatGetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatGetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatGetVecType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtype::VecType = MatGetVecType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets the vector type the matrix will return with <code>MatCreateVecs()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>vtype</code> - name of vector type</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MatSetVecType()</code>, <code>VecType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatGetVecType.html"><code>Mat/MatGetVecType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L92-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHYPREGetParCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_hypre_ParCSRMatrix}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHYPREGetParCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_hypre_ParCSRMatrix}}"><code>PETSc.LibPETSc.MatHYPREGetParCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHYPREGetParCSR(petsclib::PetscLibType,A::PetscMat, parcsr::hypre_ParCSRMatrix)</code></pre><p>Gets the pointer to the ParCSR matrix</p><p>Not Collective, No Fortran Support</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATHYPRE</code> object</li></ul><p>Output Parameter:</p><ul><li><code>parcsr</code> - the pointer to the <code>hypre_ParCSRMatrix</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATHYPRE</code>, <code>PetscCopyMode</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHYPREGetParCSR.html"><code>Mat/MatHYPREGetParCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14982-L15000">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHYPRESetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHYPRESetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatHYPRESetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHYPRESetPreallocation(petsclib::PetscLibType,A::PetscMat, dnz::PetscInt, dnnz::Vector{PetscInt}, onz::PetscInt, onnz::Vector{PetscInt})</code></pre><p>Preallocates memory for a sparse parallel matrix in HYPRE IJ format</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>dnz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>dnnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code> (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>. For matrices that will be factored, you must leave room for (and set) the diagonal entry even if it is zero.</p><ul><li><code>onz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>onnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code> (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MATHYPRE</code>, <code>MATAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHYPRESetPreallocation.html"><code>Mat/MatHYPRESetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14936-L14966">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHasCongruentLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHasCongruentLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatHasCongruentLayouts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cong::PetscBool = MatHasCongruentLayouts(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Determines whether the rows and columns layouts of the matrix are congruent</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>cong</code> - either <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatSetSizes()</code>, <code>PetscLayout</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHasCongruentLayouts.html"><code>Mat/MatHasCongruentLayouts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8666-L8684">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHasOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOperation}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHasOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOperation}"><code>PETSc.LibPETSc.MatHasOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has::PetscBool = MatHasOperation(petsclib::PetscLibType,mat::PetscMat, op::MatOperation)</code></pre><p>Determines whether the given matrix supports the particular operation.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>op</code>  - the operation, for example, <code>MATOP_GET_DIAGONAL</code></li></ul><p>Output Parameter:</p><ul><li><code>has</code> - either <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateShell()</code>, <code>MatGetOperation()</code>, <code>MatSetOperation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHasOperation.html"><code>Mat/MatHasOperation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8629-L8648">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHeaderMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHeaderMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatHeaderMerge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHeaderMerge(petsclib::PetscLibType,A::PetscMat, C::PetscMat)</code></pre><p>Merges some information from the header of <code>C</code> to <code>A</code>; the <code>C</code> object is then destroyed</p><p>Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>A</code> - a <code>Mat</code> being merged into</li><li><code>C</code> - the <code>Mat</code> providing the merge information</li></ul><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>MatHeaderReplace()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHeaderMerge.html"><code>Mat/MatHeaderMerge</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19429-L19445">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHeaderReplace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHeaderReplace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatHeaderReplace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHeaderReplace(petsclib::PetscLibType,A::PetscMat, C::PetscMat)</code></pre><p>Replaces the internal data of matrix <code>A</code> by the internal data of matrix <code>C</code> while deleting the outer wrapper of <code>C</code></p><p>Input Parameters:</p><ul><li><code>A</code> - a <code>Mat</code> whose internal data is to be replaced</li><li><code>C</code> - the <code>Mat</code> providing new internal data for <code>A</code></li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MatHeaderMerge()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHeaderReplace.html"><code>Mat/MatHeaderReplace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19463-L19477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatHermitianTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHermitianTranspose(petsclib::PetscLibType,mat::PetscMat, reuse::MatReuse, B::PetscMat)</code></pre><p>Computes an in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix to transpose and complex conjugate</li><li><code>reuse</code> - either <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, or <code>MAT_INPLACE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the Hermitian transpose</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTranspose()</code>, <code>MatMultTranspose()</code>, <code>MatMultTransposeAdd()</code>, <code>MatIsTranspose()</code>, <code>MatReuse</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHermitianTranspose.html"><code>Mat/MatHermitianTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4286-L4305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHermitianTransposeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHermitianTransposeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatHermitianTransposeGetMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHermitianTransposeGetMat(petsclib::PetscLibType,A::PetscMat, M::PetscMat)</code></pre><p>Gets the <code>Mat</code> object stored inside a <code>MATHERMITIANTRANSPOSEVIRTUAL</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATHERMITIANTRANSPOSEVIRTUAL</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>M</code> - the matrix object stored inside A</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATHERMITIANTRANSPOSEVIRTUAL</code>, <code>MatCreateHermitianTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHermitianTransposeGetMat.html"><code>Mat/MatHermitianTransposeGetMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11125-L11143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHtoolGetPermutationSource-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHtoolGetPermutationSource-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatHtoolGetPermutationSource</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHtoolGetPermutationSource(petsclib::PetscLibType,A::PetscMat, is::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHtoolGetPermutationSource.html"><code>Mat/MatHtoolGetPermutationSource</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14825-L14830">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHtoolGetPermutationTarget-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHtoolGetPermutationTarget-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatHtoolGetPermutationTarget</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHtoolGetPermutationTarget(petsclib::PetscLibType,A::PetscMat, is::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHtoolGetPermutationTarget.html"><code>Mat/MatHtoolGetPermutationTarget</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14846-L14851">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHtoolSetKernel-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatHtoolKernelFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHtoolSetKernel-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatHtoolKernelFn, Nothing}"><code>PETSc.LibPETSc.MatHtoolSetKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHtoolSetKernel(petsclib::PetscLibType,A::PetscMat, kernel::MatHtoolKernelFn, kernelctx::Cvoid)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHtoolSetKernel.html"><code>Mat/MatHtoolSetKernel</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14804-L14809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHtoolUsePermutation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHtoolUsePermutation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatHtoolUsePermutation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHtoolUsePermutation(petsclib::PetscLibType,A::PetscMat, use::PetscBool)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHtoolUsePermutation.html"><code>Mat/MatHtoolUsePermutation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14867-L14872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatHtoolUseRecompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatHtoolUseRecompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatHtoolUseRecompression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatHtoolUseRecompression(petsclib::PetscLibType,A::PetscMat, use::PetscBool)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatHtoolUseRecompression.html"><code>Mat/MatHtoolUseRecompression</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14888-L14893">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatICCFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatICCFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatICCFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatICCFactor(petsclib::PetscLibType,mat::PetscMat, row::IS, info::MatFactorInfo)</code></pre><p>Performs in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>row</code>  - row/column permutation</li><li><code>info</code> - information on desired factorization process</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code>, <code>MatICCFactorSymbolic()</code>, <code>MatLUFactorNumeric()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatICCFactor.html"><code>Mat/MatICCFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7028-L7045">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatICCFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatICCFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatICCFactorSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatICCFactorSymbolic(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, perm::IS, info::MatFactorInfo)</code></pre><p>Performs symbolic incomplete Cholesky factorization for a symmetric matrix.  Use <code>MatCholeskyFactorNumeric()</code> to complete the factorization.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factorized matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix to be factored</li><li><code>perm</code> - row and column permutation</li><li><code>info</code> - structure containing</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatCholeskyFactorNumeric()</code>, <code>MatCholeskyFactor()</code>, <code>MatFactorInfo</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatICCFactorSymbolic.html"><code>Mat/MatICCFactorSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5484-L5501">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatILUFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatILUFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatILUFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatILUFactor(petsclib::PetscLibType,mat::PetscMat, row::IS, col::IS, info::MatFactorInfo)</code></pre><p>Performs in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>row</code>  - row permutation</li><li><code>col</code>  - column permutation</li><li><code>info</code> - structure containing</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatILUFactorSymbolic()</code>, <code>MatLUFactorNumeric()</code>, <code>MatCholeskyFactor()</code>, <code>MatFactorInfo</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatILUFactor.html"><code>Mat/MatILUFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2875-L2890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatILUFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatILUFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatILUFactorSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatILUFactorSymbolic(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, row::IS, col::IS, info::MatFactorInfo)</code></pre><p>Performs symbolic ILU factorization of a matrix obtained with <code>MatGetFactor()</code> Uses levels of fill only, not drop tolerance. Use <code>MatLUFactorNumeric()</code> to complete the factorization.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factorized matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>row</code>  - row permutation</li><li><code>col</code>  - column permutation</li><li><code>info</code> - structure containing</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatLUFactorSymbolic()</code>, <code>MatLUFactorNumeric()</code>, <code>MatCholeskyFactor()</code> <code>MatGetOrdering()</code>, <code>MatFactorInfo</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatILUFactorSymbolic.html"><code>Mat/MatILUFactorSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5449-L5468">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISFixLocalEmpty-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISFixLocalEmpty-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatISFixLocalEmpty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISFixLocalEmpty(petsclib::PetscLibType,A::PetscMat, fix::PetscBool)</code></pre><p>Compress out zero local rows from the local matrices</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>fix</code> - the boolean flag</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatCreate()</code>, <code>MatCreateIS()</code>, <code>MatISSetPreallocation()</code>, <code>MatAssemblyEnd()</code>, <code>MAT_FINAL_ASSEMBLY</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISFixLocalEmpty.html"><code>Mat/MatISFixLocalEmpty</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10833-L10849">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISGetAllowRepeated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISGetAllowRepeated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatISGetAllowRepeated</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatISGetAllowRepeated(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get the flag to allow repeated entries in the local to global map</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the boolean flag</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateIS()</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatISSetAllowRepeated()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISGetAllowRepeated.html"><code>Mat/MatISGetAllowRepeated</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10733-L10751">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatISGetLocalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISGetLocalMat(petsclib::PetscLibType,mat::PetscMat, loc::PetscMat)</code></pre><p>Gets the local matrix stored inside a <code>MATIS</code> matrix.</p><p>Not Collective.</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>local</code> - the local matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatISRestoreLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISGetLocalMat.html"><code>Mat/MatISGetLocalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10913-L10931">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISGetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISGetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><code>PETSc.LibPETSc.MatISGetLocalToGlobalMapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISGetLocalToGlobalMapping(petsclib::PetscLibType,A::PetscMat, rmapping::ISLocalToGlobalMapping, cmapping::ISLocalToGlobalMapping)</code></pre><p>Gets the local</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>rmapping</code> - row mapping</li><li><code>cmapping</code> - column mapping</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatSetLocalToGlobalMapping()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISGetLocalToGlobalMapping.html"><code>Mat/MatISGetLocalToGlobalMapping</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11090-L11109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISRestoreLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISRestoreLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatISRestoreLocalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISRestoreLocalMat(petsclib::PetscLibType,mat::PetscMat, loc::PetscMat)</code></pre><p>Restores the local matrix obtained with <code>MatISGetLocalMat()</code></p><p>Not Collective.</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>local</code> - the local matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatISGetLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISRestoreLocalMat.html"><code>Mat/MatISRestoreLocalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10949-L10965">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISSetAllowRepeated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISSetAllowRepeated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatISSetAllowRepeated</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISSetAllowRepeated(petsclib::PetscLibType,A::PetscMat, flg::PetscBool)</code></pre><p>Set the flag to allow repeated entries in the local to global map</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>flg</code> - the boolean flag</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateIS()</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatISGetAllowRepeated()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISSetAllowRepeated.html"><code>Mat/MatISSetAllowRepeated</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10769-L10785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISSetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISSetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatISSetLocalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISSetLocalMat(petsclib::PetscLibType,mat::PetscMat, loc::PetscMat)</code></pre><p>Replace the local matrix stored inside a <code>MATIS</code> object.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>local</code> - the local matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatISSetLocalMatType</code>, <code>MatISGetLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISSetLocalMat.html"><code>Mat/MatISSetLocalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11015-L11031">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISSetLocalMatType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISSetLocalMatType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatISSetLocalMatType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISSetLocalMatType(petsclib::PetscLibType,mat::PetscMat, mtype::MatType)</code></pre><p>Specifies the type of local matrix inside the <code>MATIS</code></p><p>Logically Collective.</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>mtype</code> - the local matrix type</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATIS</code>, <code>MatSetType()</code>, <code>MatType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISSetLocalMatType.html"><code>Mat/MatISSetLocalMatType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10983-L10999">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatISSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISSetPreallocation(petsclib::PetscLibType,B::PetscMat, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Preallocates memory for a <code>MATIS</code> parallel matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>     - the matrix</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>. For matrices that will be factored, you must leave room for (and set) the diagonal entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code>, if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e <code>m</code>.</p><p>If the *<em>nnz parameter is given then the *</em>nz parameter is ignored</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateIS()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatISGetLocalMat()</code>, <code>MATIS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISSetPreallocation.html"><code>Mat/MatISSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10865-L10897">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatISStoreL2L-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatISStoreL2L-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatISStoreL2L</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatISStoreL2L(petsclib::PetscLibType,A::PetscMat, store::PetscBool)</code></pre><p>Store local</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>store</code> - the boolean flag</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateIS()</code>, <code>MatISSetPreallocation()</code>, <code>MatPtAP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatISStoreL2L.html"><code>Mat/MatISStoreL2L</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10801-L10817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatImaginaryPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatImaginaryPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatImaginaryPart(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Moves the imaginary part of the matrix to the real part and zeros the imaginary part</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRealPart()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatImaginaryPart.html"><code>Mat/MatImaginaryPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1145-L1160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIncreaseOverlap-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIncreaseOverlap-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64}"><code>PETSc.LibPETSc.MatIncreaseOverlap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatIncreaseOverlap(petsclib::PetscLibType,mat::PetscMat, n::PetscInt, is::Vector{IS}, ov::PetscInt)</code></pre><p>Given a set of submatrices indicated by index sets, replaces the index sets by larger ones that represent submatrices with additional overlap.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>n</code>   - the number of index sets</li><li><code>is</code>  - the array of index sets (these index sets will changed during the call)</li><li><code>ov</code>  - the additional overlap requested</li></ul><p>Options Database Key:</p><ul><li><code>-mat_increase_overlap_scalable</code> - use a scalable algorithm to compute the overlap (supported by MPIAIJ matrix)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCASM</code>, <code>MatSetBlockSize()</code>, <code>MatIncreaseOverlapSplit()</code>, <code>MatCreateSubMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIncreaseOverlap.html"><code>Mat/MatIncreaseOverlap</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5734-L5757">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIncreaseOverlapSplit-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIncreaseOverlapSplit-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64}"><code>PETSc.LibPETSc.MatIncreaseOverlapSplit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatIncreaseOverlapSplit(petsclib::PetscLibType,mat::PetscMat, n::PetscInt, is::Vector{IS}, ov::PetscInt)</code></pre><p>Given a set of submatrices indicated by index sets across a sub communicator, replaces the index sets by larger ones that represent submatrices with additional overlap.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>n</code>   - the number of index sets</li><li><code>is</code>  - the array of index sets (these index sets will changed during the call)</li><li><code>ov</code>  - the additional overlap requested</li></ul><p>`   Options Database Key:</p><ul><li><code>-mat_increase_overlap_scalable</code> - use a scalable algorithm to compute the overlap (supported by MPIAIJ matrix)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSubMatrices()</code>, <code>MatIncreaseOverlap()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIncreaseOverlapSplit.html"><code>Mat/MatIncreaseOverlapSplit</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5773-L5796">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInitializePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInitializePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><code>PETSc.LibPETSc.MatInitializePackage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInitializePackage(petsclib::PetscLibType)</code></pre><p>This function initializes everything in the <code>Mat</code> package. It is called from <code>PetscDLLibraryRegister_petscmat()</code> when using dynamic libraries, and on the first call to <code>MatCreate()</code> when using shared or static libraries.</p><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscInitialize()</code>, <code>MatFinalizePackage()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInitializePackage.html"><code>Mat/MatInitializePackage</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L738-L750">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInodeAdjustForInodes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInodeAdjustForInodes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatInodeAdjustForInodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInodeAdjustForInodes(petsclib::PetscLibType,A::PetscMat, rperm::IS, cperm::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInodeAdjustForInodes.html"><code>Mat/MatInodeAdjustForInodes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18480-L18485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInodeGetInodeSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInodeGetInodeSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatInodeGetInodeSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">node_count::PetscInt,sizes::Vector{PetscInt},limit::PetscInt = MatInodeGetInodeSizes(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Returns the inode information of a matrix with inodes</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the Inode matrix or matrix derived from the Inode class – e.g., <code>MATSEQAIJ</code></li></ul><p>Output Parameters:</p><ul><li><code>node_count</code> - no of inodes present in the matrix.</li><li><code>sizes</code>      - an array of size <code>node_count</code>, with the sizes of each inode.</li><li><code>limit</code>      - the max size used to generate the inodes.</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetInfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInodeGetInodeSizes.html"><code>Mat/MatInodeGetInodeSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18501-L18521">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInterpolate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInterpolate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatInterpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInterpolate(petsclib::PetscLibType,A::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>y = A<em>x or A^T</em>x depending on the shape of the matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the vector to be interpolated</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the resulting vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code>, <code>MatRestrict()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInterpolate.html"><code>Mat/MatInterpolate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6577-L6597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInterpolateAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInterpolateAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatInterpolateAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInterpolateAdd(petsclib::PetscLibType,A::PetscMat, x::PetscVec, y::PetscVec, w::PetscVec)</code></pre><p>w = y + A<em>x or A^T</em>x depending on the shape of the matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the vector to be multiplied by the interpolation operator</li><li><code>y</code> - the vector to be added to the result</li></ul><p>Output Parameter:</p><ul><li><code>w</code> - the resulting vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code>, <code>MatRestrict()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInterpolateAdd.html"><code>Mat/MatInterpolateAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6540-L6561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInvertBlockDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInvertBlockDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatInvertBlockDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">values::Vector{PetscScalar} = MatInvertBlockDiagonal(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Inverts the block diagonal entries.</p><p>Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>values</code> - the block inverses in column major order (FORTRAN-like)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInvertVariableBlockEnvelope()</code>, <code>MatInvertBlockDiagonalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInvertBlockDiagonal.html"><code>Mat/MatInvertBlockDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8287-L8305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInvertBlockDiagonalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInvertBlockDiagonalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatInvertBlockDiagonalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInvertBlockDiagonalMat(petsclib::PetscLibType,A::PetscMat, C::PetscMat)</code></pre><p>set the values of matrix C to be the inverted block diagonal of matrix A</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>C</code> - matrix with inverted block diagonal of <code>A</code>.  This matrix should be created and may have its type set.</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInvertBlockDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInvertBlockDiagonalMat.html"><code>Mat/MatInvertBlockDiagonalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8359-L8375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInvertVariableBlockDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInvertVariableBlockDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatInvertVariableBlockDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInvertVariableBlockDiagonal(petsclib::PetscLibType,mat::PetscMat, nblocks::PetscInt, bsizes::Vector{PetscInt}, values::Vector{PetscScalar})</code></pre><p>Inverts the point block diagonal entries.</p><p>Collective; No Fortran Support</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>nblocks</code> - the number of blocks on the process, set with <code>MatSetVariableBlockSizes()</code></li><li><code>bsizes</code>  - the size of each block on the process, set with <code>MatSetVariableBlockSizes()</code></li></ul><p>Output Parameter:</p><ul><li><code>values</code> - the block inverses in column major order (FORTRAN-like)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInvertBlockDiagonal()</code>, <code>MatSetVariableBlockSizes()</code>, <code>MatInvertVariableBlockEnvelope()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInvertVariableBlockDiagonal.html"><code>Mat/MatInvertVariableBlockDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8323-L8343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatInvertVariableBlockEnvelope-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatInvertVariableBlockEnvelope-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatInvertVariableBlockEnvelope</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatInvertVariableBlockEnvelope(petsclib::PetscLibType,A::PetscMat, reuse::MatReuse, C::PetscMat)</code></pre><p>set matrix C to be the inverted block diagonal of matrix A</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>reuse</code> - indicates if the <code>C</code> matrix was obtained from a previous call to this routine</li></ul><p>Output Parameter:</p><ul><li><code>C</code> - matrix with inverted block diagonal of <code>A</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInvertBlockDiagonal()</code>, <code>MatComputeBlockDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatInvertVariableBlockEnvelope.html"><code>Mat/MatInvertVariableBlockEnvelope</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5951-L5970">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsHermitian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsHermitian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatIsHermitian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsHermitian(petsclib::PetscLibType,A::PetscMat, tol::PetscReal)</code></pre><p>Test whether a matrix is Hermitian</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix to test</li><li><code>tol</code> - difference between value and its transpose less than this amount counts as equal (use 0.0 for exact Hermitian)</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the result</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitianKnown()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetricKnown()</code>, <code>MatIsSymmetric()</code>, <code>MAT_HERMITIAN</code>, <code>MAT_SYMMETRY_ETERNAL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsHermitian.html"><code>Mat/MatIsHermitian</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7209-L7229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsHermitianKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsHermitianKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsHermitianKnown</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set::PetscBool,flg::PetscBool = MatIsHermitianKnown(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Checks if a matrix knows if it is Hermitian or not and its Hermitian state</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to check</li></ul><p>Output Parameters:</p><ul><li><code>set</code> - <code>PETSC_TRUE</code> if the matrix knows its Hermitian state (this tells you if the next flag is valid)</li><li><code>flg</code> - the result (only valid if set is <code>PETSC_TRUE</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_SYMMETRY_ETERNAL</code>, <code>MAT_HERMITIAN</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetric()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsHermitianKnown.html"><code>Mat/MatIsHermitianKnown</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7325-L7344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatIsHermitianTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsHermitianTranspose(petsclib::PetscLibType,A::PetscMat, B::PetscMat, tol::PetscReal)</code></pre><p>Test whether a matrix is another one&#39;s Hermitian transpose,</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix to test</li><li><code>B</code>   - the matrix to test against, this can equal the first parameter</li><li><code>tol</code> - tolerance, differences between entries smaller than this are counted as zero</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the result</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTranspose()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitian()</code>, <code>MatIsTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsHermitianTranspose.html"><code>Mat/MatIsHermitianTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4323-L4343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsLinear-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsLinear-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatIsLinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsLinear(petsclib::PetscLibType,A::PetscMat, n::PetscInt)</code></pre><p>Check if a shell matrix <code>A</code> is a linear operator.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the shell matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the shell matrix is linear; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsLinear.html"><code>Mat/MatIsLinear</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20432-L20451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsSPDKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsSPDKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsSPDKnown</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set::PetscBool,flg::PetscBool = MatIsSPDKnown(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Checks if a matrix knows if it is symmetric positive definite or not and its symmetric positive definite state</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to check</li></ul><p>Output Parameters:</p><ul><li><code>set</code> - <code>PETSC_TRUE</code> if the matrix knows its symmetric positive definite state (this tells you if the next flag is valid)</li><li><code>flg</code> - the result (only valid if set is <code>PETSC_TRUE</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_SPD_ETERNAL</code>, <code>MAT_SPD</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitianKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsSPDKnown.html"><code>Mat/MatIsSPDKnown</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7286-L7305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsShell-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsShell-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsShell</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsShell(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Inquires if a matrix is derived from <code>MATSHELL</code></p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the Boolean value</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MATMFFD</code>, <code>MatCreateShell()</code>, <code>MATTRANSPOSEVIRTUAL</code>, <code>MATSCHURCOMPLEMENT</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsShell.html"><code>Mat/MatIsShell</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10586-L10602">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsStructurallySymmetric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsStructurallySymmetric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsStructurallySymmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsStructurallySymmetric(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Test whether a matrix is structurally symmetric</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to test</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the result</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_STRUCTURALLY_SYMMETRIC</code>, <code>MAT_STRUCTURAL_SYMMETRY_ETERNAL</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsSymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsStructurallySymmetricKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsStructurallySymmetric.html"><code>Mat/MatIsStructurallySymmetric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7364-L7382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsStructurallySymmetricKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsStructurallySymmetricKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsStructurallySymmetricKnown</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set::PetscBool,flg::PetscBool = MatIsStructurallySymmetricKnown(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Checks if a matrix knows if it is structurally symmetric or not and its structurally symmetric state</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to check</li></ul><p>Output Parameters:</p><ul><li><code>set</code> - PETSC_TRUE if the matrix knows its structurally symmetric state (this tells you if the next flag is valid)</li><li><code>flg</code> - the result (only valid if set is PETSC_TRUE)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_STRUCTURALLY_SYMMETRIC</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitianKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsStructurallySymmetricKnown.html"><code>Mat/MatIsStructurallySymmetricKnown</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7400-L7419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsSymmetric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsSymmetric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatIsSymmetric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsSymmetric(petsclib::PetscLibType,A::PetscMat, tol::PetscReal)</code></pre><p>Test whether a matrix is symmetric</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix to test</li><li><code>tol</code> - difference between value and its transpose less than this amount counts as equal (use 0.0 for exact transpose)</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the result</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetricKnown()</code>, <code>MAT_SYMMETRIC</code>, <code>MAT_SYMMETRY_ETERNAL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsSymmetric.html"><code>Mat/MatIsSymmetric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7171-L7191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsSymmetricKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsSymmetricKnown-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatIsSymmetricKnown</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set::PetscBool,flg::PetscBool = MatIsSymmetricKnown(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Checks if a matrix knows if it is symmetric or not and its symmetric state</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to check</li></ul><p>Output Parameters:</p><ul><li><code>set</code> - <code>PETSC_TRUE</code> if the matrix knows its symmetry state (this tells you if the next flag is valid)</li><li><code>flg</code> - the result (only valid if set is <code>PETSC_TRUE</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MAT_SYMMETRY_ETERNAL</code>, <code>MatTranspose()</code>, <code>MatIsTranspose()</code>, <code>MatIsHermitian()</code>, <code>MatIsStructurallySymmetric()</code>, <code>MatSetOption()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitianKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsSymmetricKnown.html"><code>Mat/MatIsSymmetricKnown</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7247-L7266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatIsTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatIsTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatIsTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatIsTranspose(petsclib::PetscLibType,A::PetscMat, B::PetscMat, tol::PetscReal)</code></pre><p>Test whether a matrix is another one&#39;s transpose, or its own, in which case it tests symmetry.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix to test</li><li><code>B</code>   - the matrix to test against, this can equal the first parameter</li><li><code>tol</code> - tolerance, differences between entries smaller than this are counted as zero</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - the result</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTranspose()</code>, <code>MatIsSymmetric()</code>, <code>MatIsHermitian()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatIsTranspose.html"><code>Mat/MatIsTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4247-L4268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatKAIJGetAIJ(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Get the <code>MATAIJ</code> matrix describing the blockwise action of the <code>MATKAIJ</code> matrix</p><p>Not Collective, but if the <code>MATKAIJ</code> matrix is parallel, the <code>MATAIJ</code> matrix is also parallel</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the <code>MATAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateKAIJ()</code>, <code>MATKAIJ</code>, <code>MATAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetAIJ.html"><code>Mat/MatKAIJGetAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13477-L13495">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt,S::Vector{PetscScalar} = MatKAIJGetS(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get the <code>S</code> matrix describing the shift action of the <code>MATKAIJ</code> matrix</p><p>Not Collective; the entire <code>S</code> is stored and returned independently on all processes.</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of rows in <code>S</code></li><li><code>n</code> - the number of columns in <code>S</code></li><li><code>S</code> - the S matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatCreateKAIJ()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetS.html"><code>Mat/MatKAIJGetS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13513-L13533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetSRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetSRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetSRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt,S::Vector{PetscScalar} = MatKAIJGetSRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get a read</p><p>Not Collective; the entire <code>S</code> is stored and returned independently on all processes.</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of rows in <code>S</code></li><li><code>n</code> - the number of columns in <code>S</code></li><li><code>S</code> - the S matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatCreateKAIJ()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetSRead.html"><code>Mat/MatKAIJGetSRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13555-L13575">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetScaledIdentity-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetScaledIdentity-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetScaledIdentity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identity::PetscBool = MatKAIJGetScaledIdentity(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Check if both <code>S</code> and <code>T</code> are scaled identities.</p><p>Logically Collective.</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>identity</code> - the Boolean value</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetS()</code>, <code>MatKAIJGetT()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetScaledIdentity.html"><code>Mat/MatKAIJGetScaledIdentity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13883-L13901">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetT</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt,T::Vector{PetscScalar} = MatKAIJGetT(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get the transformation matrix <code>T</code> associated with the <code>MATKAIJ</code> matrix</p><p>Not Collective; the entire <code>T</code> is stored and returned independently on all processes</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of rows in <code>T</code></li><li><code>n</code> - the number of columns in <code>T</code></li><li><code>T</code> - the T matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatCreateKAIJ()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetT.html"><code>Mat/MatKAIJGetT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13665-L13685">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJGetTRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJGetTRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJGetTRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m::PetscInt,n::PetscInt,T::Vector{PetscScalar} = MatKAIJGetTRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Get a read</p><p>Not Collective; the entire <code>T</code> is stored and returned independently on all processes</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>m</code> - the number of rows in <code>T</code></li><li><code>n</code> - the number of columns in <code>T</code></li><li><code>T</code> - the T matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatCreateKAIJ()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJGetTRead.html"><code>Mat/MatKAIJGetTRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13707-L13727">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJRestoreS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJRestoreS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJRestoreS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S::Vector{PetscScalar} = MatKAIJRestoreS(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Restore array obtained with <code>MatKAIJGetS()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>S</code> - location of pointer to array obtained with <code>MatKAIJGetS()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetS()</code>, <code>MatKAIJGetSRead()</code>, <code>MatKAIJRestoreSRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJRestoreS.html"><code>Mat/MatKAIJRestoreS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13597-L13613">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJRestoreSRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJRestoreSRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJRestoreSRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S::Vector{PetscScalar} = MatKAIJRestoreSRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Restore array obtained with <code>MatKAIJGetSRead()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>S</code> - location of pointer to array obtained with <code>MatKAIJGetS()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetS()</code>, <code>MatKAIJGetSRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJRestoreSRead.html"><code>Mat/MatKAIJRestoreSRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13631-L13647">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJRestoreT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJRestoreT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJRestoreT</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T::Vector{PetscScalar} = MatKAIJRestoreT(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Restore array obtained with <code>MatKAIJGetT()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>T</code> - location of pointer to array obtained with <code>MatKAIJGetS()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetT()</code>, <code>MatKAIJGetTRead()</code>, <code>MatKAIJRestoreTRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJRestoreT.html"><code>Mat/MatKAIJRestoreT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13749-L13765">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJRestoreTRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJRestoreTRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJRestoreTRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T::Vector{PetscScalar} = MatKAIJRestoreTRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Restore array obtained with <code>MatKAIJGetTRead()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>T</code> - location of pointer to array obtained with <code>MatKAIJGetS()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetT()</code>, <code>MatKAIJGetTRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJRestoreTRead.html"><code>Mat/MatKAIJRestoreTRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13783-L13799">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJSetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJSetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatKAIJSetAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatKAIJSetAIJ(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Set the <code>MATAIJ</code> matrix describing the blockwise action of the <code>MATKAIJ</code> matrix</p><p>Logically Collective; if the <code>MATAIJ</code> matrix is parallel, the <code>MATKAIJ</code> matrix is also parallel</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>B</code> - the <code>MATAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetAIJ()</code>, <code>MatKAIJSetS()</code>, <code>MatKAIJSetT()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJSetAIJ.html"><code>Mat/MatKAIJSetAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13817-L13833">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJSetS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJSetS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Float64}}"><code>PETSc.LibPETSc.MatKAIJSetS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatKAIJSetS(petsclib::PetscLibType,A::PetscMat, p::PetscInt, q::PetscInt, S::Vector{PetscScalar})</code></pre><p>Set the <code>S</code> matrix describing the shift action of the <code>MATKAIJ</code> matrix</p><p>Logically Collective; the entire <code>S</code> is stored independently on all processes.</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>p</code> - the number of rows in <code>S</code></li><li><code>q</code> - the number of columns in <code>S</code></li><li><code>S</code> - the S matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetS()</code>, <code>MatKAIJSetT()</code>, <code>MatKAIJSetAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJSetS.html"><code>Mat/MatKAIJSetS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13849-L13867">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatKAIJSetT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatKAIJSetT-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Float64}}"><code>PETSc.LibPETSc.MatKAIJSetT</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatKAIJSetT(petsclib::PetscLibType,A::PetscMat, p::PetscInt, q::PetscInt, T::Vector{PetscScalar})</code></pre><p>Set the transformation matrix <code>T</code> associated with the <code>MATKAIJ</code> matrix</p><p>Logically Collective; the entire <code>T</code> is stored independently on all processes.</p><p>Input Parameters:</p><ul><li><code>A</code> - the <code>MATKAIJ</code> matrix</li><li><code>p</code> - the number of rows in <code>S</code></li><li><code>q</code> - the number of columns in <code>S</code></li><li><code>T</code> - the <code>T</code> matrix, in form of a scalar array in column-major format</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATKAIJ</code>, <code>MatKAIJGetT()</code>, <code>MatKAIJSetS()</code>, <code>MatKAIJSetAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatKAIJSetT.html"><code>Mat/MatKAIJSetT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13919-L13937">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMAllocate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMAllocate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMAllocate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMAllocate(petsclib::PetscLibType,B::PetscMat, X::PetscVec, F::PetscVec)</code></pre><p>Produces all necessary common memory for LMVM approximations based on the solution and function vectors provided.</p><p>Input Parameters:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li><li><code>X</code> - Solution vector</li><li><code>F</code> - Function vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMReset()</code>, <code>MatLMVMUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMAllocate.html"><code>Ksp/MatLMVMAllocate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21185-L21202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMApplyJ0Fwd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMApplyJ0Fwd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMApplyJ0Fwd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMApplyJ0Fwd(petsclib::PetscLibType,B::PetscMat, X::PetscVec, Y::PetscVec)</code></pre><p>Applies an approximation of the forward matrix-vector product with the initial Jacobian.</p><p>Input Parameters:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li><li><code>X</code> - vector to multiply with J0</li></ul><p>Output Parameter:</p><ul><li><code>Y</code> - resulting vector for the operation</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0()</code>, <code>MatLMVMSetJ0Scale()</code>, <code>MatLMVMSetJ0ScaleDiag()</code>, <code>MatLMVMSetJ0PC()</code>, <code>MatLMVMSetJ0KSP()</code>, <code>MatLMVMApplyJ0Inv()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMApplyJ0Fwd.html"><code>Ksp/MatLMVMApplyJ0Fwd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21080-L21099">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMApplyJ0Inv-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMApplyJ0Inv-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMApplyJ0Inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMApplyJ0Inv(petsclib::PetscLibType,B::PetscMat, X::PetscVec, Y::PetscVec)</code></pre><p>Applies some estimation of the initial Jacobian inverse to the given vector.</p><p>Input Parameters:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li><li><code>X</code> - vector to &quot;multiply&quot; with J0^{-1}</li></ul><p>Output Parameter:</p><ul><li><code>Y</code> - resulting vector for the operation</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0()</code>, <code>MatLMVMSetJ0Scale()</code>, <code>MatLMVMSetJ0ScaleDiag()</code>, <code>MatLMVMSetJ0PC()</code>, <code>MatLMVMSetJ0KSP()</code>, <code>MatLMVMApplyJ0Fwd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMApplyJ0Inv.html"><code>Ksp/MatLMVMApplyJ0Inv</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21115-L21134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMClearJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMClearJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMClearJ0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMClearJ0(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Removes all definitions of J0 and reverts to an identity matrix (scale = 1.0).</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMClearJ0.html"><code>Ksp/MatLMVMClearJ0</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20794-L20808">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMDenseSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMDenseType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMDenseSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMDenseType}"><code>PETSc.LibPETSc.MatLMVMDenseSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMDenseSetType(petsclib::PetscLibType,B::PetscMat, type::MatLMVMDenseType)</code></pre><p>Sets the memory storage type for dense <code>MATLMVM</code></p><p>Input Parameters:</p><ul><li><code>B</code>    - the <code>MATLMVM</code> matrix</li><li><code>type</code> - scale type, see <code>MatLMVMDenseSetType</code></li></ul><p>Options Database Keys:</p><ul><li><code>-mat_lqn_type   &lt;reorder,inplace&gt;</code> - set the strategy</li><li><code>-mat_lbfgs_type &lt;reorder,inplace&gt;</code> - set the strategy</li><li><code>-mat_ldfp_type  &lt;reorder,inplace&gt;</code> - set the strategy</li></ul><p>Level: intermediate</p><p>MatLMVMDenseTypes:</p><ul><li><code>MAT_LMVM_DENSE_REORDER</code>   - reorders memory to minimize kernel launch</li><li><code>MAT_LMVM_DENSE_INPLACE</code>   - launches kernel inplace to minimize memory movement</li></ul><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMDQN</code>, <code>MATLMVMDBFGS</code>, <code>MATLMVMDDFP</code>, <code>MatLMVMDenseType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMDenseSetType.html"><code>Ksp/MatLMVMDenseSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21674-L21697">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetHistorySize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetHistorySize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMGetHistorySize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hist_size::PetscInt = MatLMVMGetHistorySize(petsclib::PetscLibType,B::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetHistorySize.html"><code>Ksp/MatLMVMGetHistorySize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21312-L21317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMGetJ0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMGetJ0(petsclib::PetscLibType,B::PetscMat, J0::PetscMat)</code></pre><p>Returns a pointer to the internal <code>J0</code> matrix.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>J0</code> - <code>Mat</code> object for defining the initial Jacobian</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetJ0.html"><code>Ksp/MatLMVMGetJ0</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20978-L20994">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetJ0KSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetJ0KSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><code>PETSc.LibPETSc.MatLMVMGetJ0KSP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMGetJ0KSP(petsclib::PetscLibType,B::PetscMat, J0ksp::PetscKSP)</code></pre><p>Returns a pointer to the internal <code>KSP</code> solver associated with the initial Jacobian.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>J0ksp</code> - <code>KSP</code> solver for defining the initial inverse-Jacobian</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0KSP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetJ0KSP.html"><code>Ksp/MatLMVMGetJ0KSP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21045-L21062">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetJ0PC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PC}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetJ0PC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PC}}"><code>PETSc.LibPETSc.MatLMVMGetJ0PC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMGetJ0PC(petsclib::PetscLibType,B::PetscMat, J0pc::PC)</code></pre><p>Returns a pointer to the internal <code>PC</code> object associated with the initial Jacobian.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>J0pc</code> - <code>PC</code> object for defining the initial inverse-Jacobian</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0PC()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetJ0PC.html"><code>Ksp/MatLMVMGetJ0PC</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21012-L21029">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetLastUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetLastUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMGetLastUpdate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMGetLastUpdate(petsclib::PetscLibType,B::PetscMat, x_prev::PetscVec, f_prev::PetscVec)</code></pre><p>Get the last vectors passed to <code>MatLMVMUpdate()</code></p><p>Not collective</p><p>Input Parameter:</p><ul><li><code>B</code> - a <code>MatLMVM</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>x_prev</code> - the last solution vector</li><li><code>f_prev</code> - the last function vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatLMVM</code>, <code>MatLMVMUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetLastUpdate.html"><code>Ksp/MatLMVMGetLastUpdate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20724-L20743">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetMultAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMMultAlgorithm}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetMultAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMMultAlgorithm}"><code>PETSc.LibPETSc.MatLMVMGetMultAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMGetMultAlgorithm(petsclib::PetscLibType,B::PetscMat, alg::MatLMVMMultAlgorithm)</code></pre><p>Get the algorithm used by a <code>MatLMVM</code> for products</p><p>Not collective</p><p>Input Parameter:</p><ul><li><code>B</code> - a <code>MatLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>alg</code> - one of the algorithm classes (<code>MAT_LMVM_MULT_RECURSIVE</code>, <code>MAT_LMVM_MULT_DENSE</code>, <code>MAT_LMVM_MULT_COMPACT_DENSE</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatLMVM</code>, <code>MatLMVMMultAlgorithm</code>, <code>MatLMVMSetMultAlgorithm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetMultAlgorithm.html"><code>Ksp/MatLMVMGetMultAlgorithm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20690-L20708">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetRejectCount-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetRejectCount-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMGetRejectCount</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nrejects::PetscInt = MatLMVMGetRejectCount(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Returns the number of rejected updates. The counters are reset when <code>MatLMVMReset()</code> is called.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>nrejects</code> - number of rejected updates</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMReset()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetRejectCount.html"><code>Ksp/MatLMVMGetRejectCount</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21369-L21386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMGetUpdateCount-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMGetUpdateCount-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMGetUpdateCount</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nupdates::PetscInt = MatLMVMGetUpdateCount(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Returns the number of accepted updates.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>nupdates</code> - number of accepted updates</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMGetRejectCount()</code>, <code>MatLMVMReset()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMGetUpdateCount.html"><code>Ksp/MatLMVMGetUpdateCount</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21335-L21351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMIsAllocated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMIsAllocated-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMIsAllocated</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatLMVMIsAllocated(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Returns a boolean flag that shows whether the necessary data structures for the underlying matrix is allocated.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if allocated, <code>PETSC_FALSE</code> otherwise</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMAllocate()</code>, <code>MatLMVMReset()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMIsAllocated.html"><code>Ksp/MatLMVMIsAllocated</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21150-L21167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMReset-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMReset-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatLMVMReset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMReset(petsclib::PetscLibType,B::PetscMat, destructive::PetscBool)</code></pre><p>Flushes all of the accumulated updates out of the <code>MATLMVM</code> approximation.</p><p>Input Parameters:</p><ul><li><code>B</code>           - A <code>MATLMVM</code> matrix</li><li><code>destructive</code> - flag for enabling destruction of data structures</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMAllocate()</code>, <code>MatLMVMUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMReset.html"><code>Ksp/MatLMVMReset</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21247-L21262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMResetShift-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMResetShift-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMResetShift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMResetShift(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Zero the shift factor for a <code>MATLMVM</code>.</p><p>Input Parameter:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMAllocate()</code>, <code>MatLMVMUpdate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMResetShift.html"><code>Ksp/MatLMVMResetShift</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21218-L21231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetHistorySize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetHistorySize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatLMVMSetHistorySize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetHistorySize(petsclib::PetscLibType,B::PetscMat, hist_size::PetscInt)</code></pre><p>Set the number of past iterates to be stored for the construction of the limited-memory quasi-Newton update.</p><p>Input Parameters:</p><ul><li><code>B</code>         - A <code>MATLMVM</code> matrix</li><li><code>hist_size</code> - number of past iterates (default 5)</li></ul><p>Options Database Key:</p><ul><li><code>-mat_lmvm_hist_size &lt;m&gt;</code> - set number of past iterates</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMGetUpdateCount()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetHistorySize.html"><code>Ksp/MatLMVMSetHistorySize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21278-L21296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetJ0-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMSetJ0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetJ0(petsclib::PetscLibType,B::PetscMat, J0::PetscMat)</code></pre><p>Allows the user to define the initial Jacobian matrix from which the LMVM up.</p><p>Input Parameters:</p><ul><li><code>B</code>  - An LMVM-type matrix</li><li><code>J0</code> - The initial Jacobian matrix, will be referenced by B.</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetJ0PC()</code>, <code>MatLMVMSetJ0KSP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetJ0.html"><code>Ksp/MatLMVMSetJ0</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20886-L20901">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetJ0Diag-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetJ0Diag-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMSetJ0Diag</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetJ0Diag(petsclib::PetscLibType,B::PetscMat, V::PetscVec)</code></pre><p>Allows the user to define a vector V such that J0 = diag(V).</p><p>Input Parameters:</p><ul><li><code>B</code> - An LMVM-type matrix</li><li><code>V</code> - Vector that defines the diagonal of the initial Jacobian: values are copied, V is not referenced</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetScale()</code>, <code>MatLMVMSetJ0()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetJ0Diag.html"><code>Ksp/MatLMVMSetJ0Diag</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20855-L20870">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetJ0KSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetJ0KSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><code>PETSc.LibPETSc.MatLMVMSetJ0KSP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetJ0KSP(petsclib::PetscLibType,B::PetscMat, J0ksp::PetscKSP)</code></pre><p>Allows the user to provide a pre approximation.</p><p>Input Parameters:</p><ul><li><code>B</code>     - A <code>MATLMVM</code> matrix</li><li><code>J0ksp</code> - <code>KSP</code> solver for the initial inverse-Jacobian application</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMGetJ0KSP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetJ0KSP.html"><code>Ksp/MatLMVMSetJ0KSP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20947-L20962">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetJ0PC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PC}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetJ0PC-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PC}}"><code>PETSc.LibPETSc.MatLMVMSetJ0PC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetJ0PC(petsclib::PetscLibType,B::PetscMat, J0pc::PC)</code></pre><p>Allows the user to define a <code>PC</code> object that acts as the initial inverse</p><p>Input Parameters:</p><ul><li><code>B</code>    - A <code>MATLMVM</code> matrix</li><li><code>J0pc</code> - <code>PC</code> object where <code>PCApply()</code> defines an inverse application for J0</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMGetJ0PC()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetJ0PC.html"><code>Ksp/MatLMVMSetJ0PC</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20917-L20931">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetJ0Scale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetJ0Scale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatLMVMSetJ0Scale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetJ0Scale(petsclib::PetscLibType,B::PetscMat, scale::PetscReal)</code></pre><p>Allows the user to define a scalar value mu such that J0 = mu*I.</p><p>Input Parameters:</p><ul><li><code>B</code>     - A <code>MATLMVM</code> matrix</li><li><code>scale</code> - Scalar value mu that defines the initial Jacobian</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMSetDiagScale()</code>, <code>MatLMVMSetJ0()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetJ0Scale.html"><code>Ksp/MatLMVMSetJ0Scale</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20824-L20839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSetMultAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMMultAlgorithm}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSetMultAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMMultAlgorithm}"><code>PETSc.LibPETSc.MatLMVMSetMultAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSetMultAlgorithm(petsclib::PetscLibType,B::PetscMat, alg::MatLMVMMultAlgorithm)</code></pre><p>Set the algorithm used by a <code>MatLMVM</code> for products</p><p>Logically collective</p><p>Input Parameters:</p><ul><li><code>B</code>   - a <code>MatLMVM</code> matrix</li><li><code>alg</code> - one of the algorithm classes (<code>MAT_LMVM_MULT_RECURSIVE</code>, <code>MAT_LMVM_MULT_DENSE</code>, <code>MAT_LMVM_MULT_COMPACT_DENSE</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatLMVM</code>, <code>MatLMVMMultAlgorithm</code>, <code>MatLMVMGetMultAlgorithm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSetMultAlgorithm.html"><code>Ksp/MatLMVMSetMultAlgorithm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20658-L20674">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBadBroydenGetPsi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBadBroydenGetPsi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMSymBadBroydenGetPsi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">psi::PetscReal = MatLMVMSymBadBroydenGetPsi(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Get the psi parameter for a Broyden class quasi</p><p>Input Parameter:</p><ul><li><code>B</code> - The matrix</li></ul><p>Output Parameter:</p><ul><li><code>psi</code> - a number defining an update that is an affine combination of the BFGS update (psi = 1) and DFP update (psi = 0)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code>, <code>MATLMVMSYMBADBROYDEN</code>, <code>MATLMVMDFP</code>, <code>MATLMVMBFGS</code>, <code>MatLMVMSymBadBroydenSetPsi()</code>, <code>MatLMVMSymBroydenGetPhi()</code>, <code>MatLMVMSymBroydenSetPhi()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBadBroydenGetPsi.html"><code>Ksp/MatLMVMSymBadBroydenGetPsi</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21893-L21913">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBadBroydenSetPsi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBadBroydenSetPsi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatLMVMSymBadBroydenSetPsi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSymBadBroydenSetPsi(petsclib::PetscLibType,B::PetscMat, psi::PetscReal)</code></pre><p>Get the psi parameter for a Broyden class quasi</p><p>Input Parameters:</p><ul><li><code>B</code>   - The matrix</li><li><code>psi</code> - a number defining an update that is a convex combination of the BFGS update (psi = 1) and DFP update (psi = 0)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code>, <code>MATLMVMSYMBADBROYDEN</code>, <code>MATLMVMDFP</code>, <code>MATLMVMBFGS</code>, <code>MatLMVMSymBadBroydenGetPsi()</code>, <code>MatLMVMSymBroydenGetPhi()</code>, <code>MatLMVMSymBroydenSetPhi()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBadBroydenSetPsi.html"><code>Ksp/MatLMVMSymBadBroydenSetPsi</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21931-L21949">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBroydenGetPhi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBroydenGetPhi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLMVMSymBroydenGetPhi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phi::PetscReal = MatLMVMSymBroydenGetPhi(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Get the phi parameter for a Broyden class quasi</p><p>Input Parameter:</p><ul><li><code>B</code> - The matrix</li></ul><p>Output Parameter:</p><ul><li><code>phi</code> - a number defining an update that is an affine combination of the BFGS update (phi = 0) and DFP update (phi = 1)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code>, <code>MATLMVMSYMBADBROYDEN</code>, <code>MATLMVMDFP</code>, <code>MATLMVMBFGS</code>, <code>MatLMVMSymBroydenSetPhi()</code>, <code>MatLMVMSymBadBroydenGetPsi()</code>, <code>MatLMVMSymBadBroydenSetPsi()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBroydenGetPhi.html"><code>Ksp/MatLMVMSymBroydenGetPhi</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21821-L21841">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBroydenSetDelta-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBroydenSetDelta-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatLMVMSymBroydenSetDelta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSymBroydenSetDelta(petsclib::PetscLibType,B::PetscMat, delta::PetscScalar)</code></pre><p>Sets the starting value for the diagonal scaling vector computed in the SymBrdn approximations (also works for BFGS and DFP).</p><p>Input Parameters:</p><ul><li><code>B</code>     - <code>MATLMVM</code> matrix</li><li><code>delta</code> - initial value for diagonal scaling</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBroydenSetDelta.html"><code>Ksp/MatLMVMSymBroydenSetDelta</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21965-L21980">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBroydenSetPhi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBroydenSetPhi-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatLMVMSymBroydenSetPhi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSymBroydenSetPhi(petsclib::PetscLibType,B::PetscMat, phi::PetscReal)</code></pre><p>Get the phi parameter for a Broyden class quasi</p><p>Input Parameters:</p><ul><li><code>B</code>   - The matrix</li><li><code>phi</code> - a number defining an update that is a convex combination of the BFGS update (phi = 0) and DFP update (phi = 1)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code>, <code>MATLMVMSYMBADBROYDEN</code>, <code>MATLMVMDFP</code>, <code>MATLMVMBFGS</code>, <code>MatLMVMSymBroydenGetPhi()</code>, <code>MatLMVMSymBadBroydenGetPsi()</code>, <code>MatLMVMSymBadBroydenSetPsi()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBroydenSetPhi.html"><code>Ksp/MatLMVMSymBroydenSetPhi</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21859-L21877">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMSymBroydenSetScaleType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMSymBroydenScaleType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMSymBroydenSetScaleType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatLMVMSymBroydenScaleType}"><code>PETSc.LibPETSc.MatLMVMSymBroydenSetScaleType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMSymBroydenSetScaleType(petsclib::PetscLibType,B::PetscMat, stype::MatLMVMSymBroydenScaleType)</code></pre><p>Sets the scale type for symmetric Broyden</p><p>Input Parameters:</p><ul><li><code>B</code>     - the <code>MATLMVM</code> matrix</li><li><code>stype</code> - scale type, see <code>MatLMVMSymBroydenScaleType</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_lmvm_scale_type &lt;none,scalar,diagonal&gt;</code> - set the scaling type</li></ul><p>Level: intermediate</p><p>MatLMVMSymBrdnScaleTypes:</p><ul><li><code>MAT_LMVM_SYMBROYDEN_SCALE_NONE</code>       - use whatever initial Hessian is already there (will be the identity if the user does nothing)</li><li><code>MAT_LMVM_SYMBROYDEN_SCALE_SCALAR</code>     - use the Shanno scalar as the initial Hessian</li><li><code>MAT_LMVM_SYMBROYDEN_SCALE_DIAGONAL</code>   - use a diagonalized BFGS update as the initial Hessian</li><li><code>MAT_LMVM_SYMBROYDEN_SCALE_USER</code>       - same as <code>MAT_LMVM_SYMBROYDEN_NONE</code></li><li><code>MAT_LMVM_SYMBROYDEN_SCALE_DECIDE</code>     - let PETSc decide</li></ul><p>-seealso: <a href="ch_ksp"></a>, <code>MATLMVMSYMBROYDEN</code>, <code>MatCreateLMVMSymBroyden()</code>, <code>MatLMVMSymBroydenScaleType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMSymBroydenSetScaleType.html"><code>Ksp/MatLMVMSymBroydenSetScaleType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L21996-L22020">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLMVMUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLMVMUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatLMVMUpdate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLMVMUpdate(petsclib::PetscLibType,B::PetscMat, X::PetscVec, F::PetscVec)</code></pre><p>Adds (X</p><p>Input Parameters:</p><ul><li><code>B</code> - A <code>MATLMVM</code> matrix</li><li><code>X</code> - Solution vector</li><li><code>F</code> - Function vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <a href="sec_matlmvm">LMVM Matrices</a>, <code>MATLMVM</code>, <code>MatLMVMReset()</code>, <code>MatLMVMAllocate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatLMVMUpdate.html"><code>Ksp/MatLMVMUpdate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20763-L20778">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLRCGetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLRCGetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLRCGetMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLRCGetMats(petsclib::PetscLibType,N::PetscMat, A::PetscMat, U::PetscMat, c::PetscVec, V::PetscMat)</code></pre><p>Returns the constituents of an LRC matrix</p><p>Not collective</p><p>Input Parameter:</p><ul><li><code>N</code> - matrix of type <code>MATLRC</code></li></ul><p>Output Parameters:</p><ul><li><code>A</code> - the (sparse) matrix</li><li><code>U</code> - first dense rectangular (tall and skinny) matrix</li><li><code>c</code> - a sequential vector containing the diagonal of C</li><li><code>V</code> - second dense rectangular (tall and skinny) matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatLRCSetMats()</code>, <code>Mat</code>, <code>MATLRC</code>, <code>MatCreateLRC()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLRCGetMats.html"><code>Mat/MatLRCGetMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12826-L12847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLRCSetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLRCSetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatLRCSetMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLRCSetMats(petsclib::PetscLibType,N::PetscMat, A::PetscMat, U::PetscMat, c::PetscVec, V::PetscMat)</code></pre><p>Sets the constituents of an LRC matrix</p><p>Logically collective</p><p>Input Parameters:</p><ul><li><code>N</code> - matrix of type <code>MATLRC</code></li><li><code>A</code> - the (sparse) matrix</li><li><code>U</code> - first dense rectangular (tall and skinny) matrix</li><li><code>c</code> - a sequential vector containing the diagonal of C</li><li><code>V</code> - second dense rectangular (tall and skinny) matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatLRCGetMats()</code>, <code>Mat</code>, <code>MATLRC</code>, <code>MatCreateLRC()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLRCSetMats.html"><code>Mat/MatLRCSetMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12871-L12890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLUFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLUFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatLUFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLUFactor(petsclib::PetscLibType,mat::PetscMat, row::IS, col::IS, info::MatFactorInfo)</code></pre><p>Performs in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>row</code>  - row permutation</li><li><code>col</code>  - column permutation</li><li><code>info</code> - options for factorization, includes</li></ul><p>-seealso: <a href="ch_matrices"></a>, <a href="sec_matfactor">Matrix Factorization</a>, <code>Mat</code>, <code>MatFactorType</code>, <code>MatLUFactorSymbolic()</code>, <code>MatLUFactorNumeric()</code>, <code>MatCholeskyFactor()</code>, <code>MatGetOrdering()</code>, <code>MatSetUnfactored()</code>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLUFactor.html"><code>Mat/MatLUFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2843-L2859">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLUFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLUFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatLUFactorNumeric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLUFactorNumeric(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, info::MatFactorInfo)</code></pre><p>Performs numeric LU factorization of a matrix. Call this routine after first calling <code>MatLUFactorSymbolic()</code> and <code>MatGetFactor()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>info</code> - options for factorization</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatFactorInfo</code>, <code>MatLUFactorSymbolic()</code>, <code>MatLUFactor()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLUFactorNumeric.html"><code>Mat/MatLUFactorNumeric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2939-L2957">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLUFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLUFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatLUFactorSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLUFactorSymbolic(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, row::IS, col::IS, info::MatFactorInfo)</code></pre><p>Performs symbolic LU factorization of matrix. Call this routine before calling <code>MatLUFactorNumeric()</code> and after <code>MatGetFactor()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>row</code>  - the row permutation</li><li><code>col</code>  - the column permutation</li><li><code>info</code> - options for factorization, includes</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatLUFactor()</code>, <code>MatLUFactorNumeric()</code>, <code>MatCholeskyFactor()</code>, <code>MatFactorInfo</code>, <code>MatFactorInfoInitialize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLUFactorSymbolic.html"><code>Mat/MatLUFactorSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2906-L2923">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatLoad-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatLoad-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatLoad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatLoad(petsclib::PetscLibType,mat::PetscMat, viewer::PetscViewer)</code></pre><p>Loads a matrix that has been stored in binary/HDF5 format with <code>MatView()</code>.  The matrix format is determined from the options database. Generates a parallel MPI matrix if the communicator has more than one processor.  The default matrix type is <code>MATAIJ</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the newly loaded matrix, this needs to have been created with <code>MatCreate()</code></li></ul><p>or some related function before a call to <code>MatLoad()</code></p><ul><li><code>viewer</code> - <code>PETSCVIEWERBINARY</code>/<code>PETSCVIEWERHDF5</code> file viewer</li></ul><p>Options Database Key:</p><ul><li><code>-matload_block_size &lt;bs&gt;</code> - set block size</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscViewerBinaryOpen()</code>, <code>PetscViewerSetType()</code>, <code>MatView()</code>, <code>VecLoad()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatLoad.html"><code>Mat/MatLoad</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1775-L1798">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMAIJGetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMAIJGetAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMAIJGetAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMAIJGetAIJ(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Get the <code>MATAIJ</code> matrix describing the blockwise action of the <code>MATMAIJ</code> matrix</p><p>Not Collective, but if the <code>MATMAIJ</code> matrix is parallel, the <code>MATAIJ</code> matrix is also parallel</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATMAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the <code>MATAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMAIJ</code>, <code>MATAIJ</code>, <code>MatCreateMAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMAIJGetAIJ.html"><code>Mat/MatMAIJGetAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10620-L10638">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMAIJRedimension-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMAIJRedimension-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMAIJRedimension</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMAIJRedimension(petsclib::PetscLibType,A::PetscMat, dof::PetscInt, B::PetscMat)</code></pre><p>Get a new <code>MATMAIJ</code> matrix with the same action, but for a different block size</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>   - the <code>MATMAIJ</code> matrix</li><li><code>dof</code> - the block size for the new matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the new <code>MATMAIJ</code> matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMAIJ</code>, <code>MatCreateMAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMAIJRedimension.html"><code>Mat/MatMAIJRedimension</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10656-L10675">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJGetLocalMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAIJGetLocalMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJGetLocalMat(petsclib::PetscLibType,A::PetscMat, scall::MatReuse, A_loc::PetscMat)</code></pre><p>Creates a <code>MATSEQAIJ</code> from a <code>MATMPIAIJ</code> matrix.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>A_loc</code> - the local sequential matrix generated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatGetOwnershipRange()</code>, <code>MatMPIAIJGetLocalMatCondensed()</code>, <code>MatMPIAIJGetLocalMatMerge()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJGetLocalMat.html"><code>Mat/MatMPIAIJGetLocalMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15964-L15983">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJGetLocalMatCondensed-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJGetLocalMatCondensed-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAIJGetLocalMatCondensed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJGetLocalMatCondensed(petsclib::PetscLibType,A::PetscMat, scall::MatReuse, row::IS, col::IS, A_loc::PetscMat)</code></pre><p>Creates a <code>MATSEQAIJ</code> matrix from an <code>MATMPIAIJ</code> matrix by taking all its local rows and NON</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>row</code>   - index set of rows to extract (or <code>NULL</code>)</li><li><code>col</code>   - index set of columns to extract (or <code>NULL</code>)</li></ul><p>Output Parameter:</p><ul><li><code>A_loc</code> - the local sequential matrix generated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatGetOwnershipRange()</code>, <code>MatMPIAIJGetLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJGetLocalMatCondensed.html"><code>Mat/MatMPIAIJGetLocalMatCondensed</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16040-L16061">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJGetLocalMatMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJGetLocalMatMerge-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAIJGetLocalMatMerge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJGetLocalMatMerge(petsclib::PetscLibType,A::PetscMat, scall::MatReuse, glob::IS, A_loc::PetscMat)</code></pre><p>Creates a <code>MATSEQAIJ</code> from a <code>MATMPIAIJ</code> matrix by taking all its local rows and putting them into a sequential matrix with mlocal rows and n columns. Where n is the sum of the number of columns of the diagonal and off-diagonal part</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameters:</p><ul><li><code>glob</code>  - sequential <code>IS</code> with global indices associated with the columns of the local sequential matrix generated (can be <code>NULL</code>)</li><li><code>A_loc</code> - the local sequential matrix generated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatGetOwnershipRange()</code>, <code>MatMPIAIJGetLocalMat()</code>, <code>MatMPIAIJGetLocalMatCondensed()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJGetLocalMatMerge.html"><code>Mat/MatMPIAIJGetLocalMatMerge</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16001-L16022">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJGetNumberNonzeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJGetNumberNonzeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMPIAIJGetNumberNonzeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJGetNumberNonzeros(petsclib::PetscLibType,A::PetscMat, nz::PetscCount)</code></pre><p>gets the number of nonzeros in the matrix on this MPI rank</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>nz</code> - the number of nonzeros</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJGetNumberNonzeros.html"><code>Mat/MatMPIAIJGetNumberNonzeros</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15426-L15444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJGetSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJGetSeqAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAIJGetSeqAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">colmap::Vector{PetscInt} = MatMPIAIJGetSeqAIJ(petsclib::PetscLibType,A::PetscMat, Ad::PetscMat, Ao::PetscMat)</code></pre><p>Returns the local pieces of this distributed matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - The <code>MATMPIAIJ</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>Ad</code>     - The local diagonal block as a <code>MATSEQAIJ</code> matrix</li><li><code>Ao</code>     - The local off-diagonal block as a <code>MATSEQAIJ</code> matrix</li><li><code>colmap</code> - An array mapping local column numbers of <code>Ao</code> to global column numbers of the parallel matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatMPIAIJGetLocalMat()</code>, <code>MatMPIAIJGetLocalMatCondensed()</code>, <code>MatCreateAIJ()</code>, <code>MATSEQAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJGetSeqAIJ.html"><code>Mat/MatMPIAIJGetSeqAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15801-L15821">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatMPIAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Preallocates memory for a sparse parallel matrix in <code>MATMPIAIJ</code> format (the default parallel PETSc format).  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameters <code>d_nz</code> (or <code>d_nnz</code>) and <code>o_nz</code> (or <code>o_nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>     - the matrix</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code> (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;. For matrices that will be factored, you must leave room for (and set) the diagonal entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or <code>NULL</code> (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;.</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrices</a>, <code>MATMPIAIJ</code>, <code>MATAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateAIJ()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MatGetInfo()</code>, <code>PetscSplitOwnership()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJSetPreallocation.html"><code>Mat/MatMPIAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15572-L15604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatMPIAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Allocates memory for a sparse parallel matrix in <code>MATAIJ</code> format (the default parallel PETSc format).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code> - the matrix</li><li><code>i</code> - the indices into <code>j</code> for the start of each local row (indices start with zero)</li><li><code>j</code> - the column indices for each local row (indices start with zero)</li><li><code>v</code> - optional values in the matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqAIJWithArrays()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code>, <code>MatCreateMPIAIJWithArrays()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJSetPreallocationCSR.html"><code>Mat/MatMPIAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15536-L15556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAIJSetUseScalableIncreaseOverlap-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAIJSetUseScalableIncreaseOverlap-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatMPIAIJSetUseScalableIncreaseOverlap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAIJSetUseScalableIncreaseOverlap(petsclib::PetscLibType,A::PetscMat, sc::PetscBool)</code></pre><p>Determine if the matrix uses a scalable algorithm to compute the overlap</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>  - the matrix</li><li><code>sc</code> - <code>PETSC_TRUE</code> indicates use the scalable algorithm (default is not to use the scalable algorithm)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAIJSetUseScalableIncreaseOverlap.html"><code>Mat/MatMPIAIJSetUseScalableIncreaseOverlap</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15460-L15476">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAdjCreateNonemptySubcommMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAdjCreateNonemptySubcommMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAdjCreateNonemptySubcommMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">B::PetscMat = MatMPIAdjCreateNonemptySubcommMat(petsclib::PetscLibType,A::PetscMat)</code></pre><p>create the same <code>MATMPIADJ</code> matrix on a subcommunicator containing only processes owning a positive number of rows</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - original <code>MATMPIADJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - matrix on subcommunicator, <code>NULL</code> on MPI processes that own zero rows of <code>A</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIADJ</code>, <code>MatCreateMPIAdj()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAdjCreateNonemptySubcommMat.html"><code>Mat/MatMPIAdjCreateNonemptySubcommMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13993-L14011">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAdjSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAdjSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAdjSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">i::PetscInt,j::PetscInt,values::PetscInt = MatMPIAdjSetPreallocation(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Sets the array used for storing the matrix elements</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>B</code>      - the matrix</li><li><code>i</code>      - the indices into <code>j</code> for the start of each row</li><li><code>j</code>      - the column indices for each row (sorted for each row).</li></ul><p>The indices in <code>i</code> and <code>j</code> start with zero (NOT with one).</p><ul><li><code>values</code> - [use <code>NULL</code> if not provided] edge weights</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateMPIAdj()</code>, <code>MatSetValues()</code>, <code>MATMPIADJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAdjSetPreallocation.html"><code>Mat/MatMPIAdjSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14101-L14120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAdjToSeq-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAdjToSeq-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAdjToSeq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAdjToSeq(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Converts an parallel <code>MATMPIADJ</code> matrix to complete <code>MATMPIADJ</code> on each process (needed by sequential partitioners)</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the same matrix on all processes</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIADJ</code>, <code>MatCreate()</code>, <code>MatCreateMPIAdj()</code>, <code>MatSetValues()</code>, <code>MatMPIAdjToSeqRankZero()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAdjToSeq.html"><code>Mat/MatMPIAdjToSeq</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14029-L14047">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIAdjToSeqRankZero-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIAdjToSeqRankZero-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIAdjToSeqRankZero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIAdjToSeqRankZero(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Converts an parallel <code>MATMPIADJ</code> matrix to complete <code>MATMPIADJ</code> on rank zero (needed by sequential partitioners)</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the same matrix on rank zero, not set on other ranks</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIADJ</code>, <code>MatCreate()</code>, <code>MatCreateMPIAdj()</code>, <code>MatSetValues()</code>, <code>MatMPIAdjToSeq()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIAdjToSeqRankZero.html"><code>Mat/MatMPIAdjToSeqRankZero</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14065-L14083">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIBAIJGetSeqBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIBAIJGetSeqBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIBAIJGetSeqBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">colmap::Vector{PetscInt} = MatMPIBAIJGetSeqBAIJ(petsclib::PetscLibType,A::PetscMat, Ad::PetscMat, Ao::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIBAIJGetSeqBAIJ.html"><code>Mat/MatMPIBAIJGetSeqBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9667-L9672">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIBAIJSetHashTableFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIBAIJSetHashTableFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatMPIBAIJSetHashTableFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIBAIJSetHashTableFactor(petsclib::PetscLibType,mat::PetscMat, fact::PetscReal)</code></pre><p>Sets the factor required to compute the size of the matrices hash table</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>fact</code> - factor</li></ul><p>Options Database Key:</p><ul><li><code>-mat_use_hash_table &lt;fact&gt;</code> - provide the factor</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MATMPIBAIJ</code>, <code>MatSetOption()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIBAIJSetHashTableFactor.html"><code>Mat/MatMPIBAIJSetHashTableFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9634-L9651">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Int64}}, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatMPIBAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIBAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Allocates memory for a sparse parallel matrix in <code>MATMPIBAIJ</code> format (block compressed row).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>     - the matrix</li><li><code>bs</code>    - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row</li></ul><p>blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></p><ul><li><code>d_nz</code>  - number of block nonzeros per block row in diagonal portion of local</li></ul><p>submatrix  (same for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of block nonzeros in the various block rows</li></ul><p>of the in diagonal portion of the local (possibly different for each block row) or <code>NULL</code>.  If you plan to factor the matrix you must leave room for the diagonal entry and set it even if it is zero.</p><ul><li><code>o_nz</code>  - number of block nonzeros per block row in the off-diagonal portion of local</li></ul><p>submatrix (same for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various block rows of the</li></ul><p>off-diagonal portion of the local submatrix (possibly different for each block row) or <code>NULL</code>.</p><p>If the *<em>nnz parameter is given then the *</em>nz parameter is ignored</p><p>Options Database Keys:</p><ul><li><code>-mat_block_size</code>            - size of the blocks to use</li><li><code>-mat_use_hash_table &lt;fact&gt;</code> - set hash table factor</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MATMPIBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code>, <code>MatMPIBAIJSetPreallocationCSR()</code>, <code>PetscSplitOwnership()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIBAIJSetPreallocation.html"><code>Mat/MatMPIBAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9532-L9567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Float64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Float64}}}"><code>PETSc.LibPETSc.MatMPIBAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIBAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Creates a sparse parallel matrix in <code>MATBAIJ</code> format using the given nonzero structure and (optional) numerical values</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>  - the matrix</li><li><code>bs</code> - the block size</li><li><code>i</code>  - the indices into <code>j</code> for the start of each local row (starts with zero)</li><li><code>j</code>  - the column indices for each local row (starts with zero) these must be sorted for each row</li><li><code>v</code>  - optional values in the matrix, use <code>NULL</code> if not provided</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatCreateAIJ()</code>, <code>MATMPIAIJ</code>, <code>MatCreateMPIBAIJWithArrays()</code>, <code>MATMPIBAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIBAIJSetPreallocationCSR.html"><code>Mat/MatMPIBAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9497-L9516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPIDenseSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPIDenseSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPIDenseSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPIDenseSetPreallocation(petsclib::PetscLibType,B::PetscMat, data::PetscScalar)</code></pre><p>Sets the array used to store the matrix entries</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>    - the matrix</li><li><code>data</code> - optional location of matrix data.  Set to <code>NULL</code> for PETSc</li></ul><p>to control all matrix memory allocation.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIDENSE</code>, <code>MatCreate()</code>, <code>MatCreateSeqDense()</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPIDenseSetPreallocation.html"><code>Mat/MatMPIDenseSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11306-L11323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPISBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPISBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatMPISBAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPISBAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>For good matrix assembly performance the user should preallocate the matrix storage by setting the parameters d<em>nz (or d</em>nnz) and o<em>nz (or o</em>nnz).  By setting these parameters accurately, performance can be increased by more than a factor of 50.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>     - the matrix</li><li><code>bs</code>    - size of block, the blocks are ALWAYS square. One can use MatSetBlockSizes() to set a different row and column blocksize but the row</li></ul><p>blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with MatCreateVecs()</p><ul><li><code>d_nz</code>  - number of block nonzeros per block row in diagonal portion of local</li></ul><p>submatrix  (same for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of block nonzeros in the various block rows</li></ul><p>in the upper triangular and diagonal part of the in diagonal portion of the local (possibly different for each block row) or <code>NULL</code>.  If you plan to factor the matrix you must leave room for the diagonal entry and set a value even if it is zero.</p><ul><li><code>o_nz</code>  - number of block nonzeros per block row in the off-diagonal portion of local</li></ul><p>submatrix (same for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various block rows of the</li></ul><p>off-diagonal portion of the local submatrix that is right of the diagonal (possibly different for each block row) or <code>NULL</code>.</p><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the</li></ul><p>block calculations (much slower)</p><ul><li><code>-mat_block_size</code> - size of the blocks to use</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPISBAIJ</code>, <code>MATSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code>, <code>PetscSplitOwnership()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPISBAIJSetPreallocation.html"><code>Mat/MatMPISBAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12999-L13035">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPISBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPISBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatMPISBAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPISBAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Creates a sparse parallel matrix in <code>MATMPISBAIJ</code> format using the given nonzero structure and (optional) numerical values</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>  - the matrix</li><li><code>bs</code> - the block size</li><li><code>i</code>  - the indices into <code>j</code> for the start of each local row (indices start with zero)</li><li><code>j</code>  - the column indices for each local row (indices start with zero) these must be sorted for each row</li><li><code>v</code>  - optional values in the matrix, pass <code>NULL</code> if not provided</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPISBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatCreateAIJ()</code>, <code>MATMPIAIJ</code>, <code>MatCreateMPISBAIJWithArrays()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPISBAIJSetPreallocationCSR.html"><code>Mat/MatMPISBAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13150-L13170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPISELLGetLocalMatCondensed-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Union{Ptr, PETSc.LibPETSc.IS}, Union{Ptr, PETSc.LibPETSc.IS}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPISELLGetLocalMatCondensed-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Union{Ptr, PETSc.LibPETSc.IS}, Union{Ptr, PETSc.LibPETSc.IS}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPISELLGetLocalMatCondensed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPISELLGetLocalMatCondensed(petsclib::PetscLibType,A::PetscMat, scall::MatReuse, row::IS, col::IS, A_loc::PetscMat)</code></pre><p>Creates a <code>MATSEQSELL</code> matrix from an <code>MATMPISELL</code> matrix by taking all its local rows and NON-ZERO columns</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>row</code>   - index sets of rows to extract (or <code>NULL</code>)</li><li><code>col</code>   - index sets of columns to extract (or <code>NULL</code>)</li></ul><p>Output Parameter:</p><ul><li><code>A_loc</code> - the local sequential matrix generated</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MATSEQSELL</code>, <code>MATMPISELL</code>, <code>MatGetOwnershipRange()</code>, <code>MatMPISELLGetLocalMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPISELLGetLocalMatCondensed.html"><code>Mat/MatMPISELLGetLocalMatCondensed</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9102-L9124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPISELLGetSeqSELL-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPISELLGetSeqSELL-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMPISELLGetSeqSELL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">colmap::Vector{PetscInt} = MatMPISELLGetSeqSELL(petsclib::PetscLibType,A::PetscMat, Ad::PetscMat, Ao::PetscMat)</code></pre><p>Returns the local pieces of this distributed matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATMPISELL</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>Ad</code>     - The diagonal portion of <code>A</code></li><li><code>Ao</code>     - The off-diagonal portion of <code>A</code></li><li><code>colmap</code> - An array mapping local column numbers of <code>Ao</code> to global column numbers of the parallel matrix</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MATSEQSELL</code>, <code>MATMPISELL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPISELLGetSeqSELL.html"><code>Mat/MatMPISELLGetSeqSELL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9060-L9080">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMPISELLSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMPISELLSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatMPISELLSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMPISELLSetPreallocation(petsclib::PetscLibType,B::PetscMat, d_nz::PetscInt, d_nnz::Vector{PetscInt}, o_nz::PetscInt, o_nnz::Vector{PetscInt})</code></pre><p>Preallocates memory for a <code>MATMPISELL</code> sparse parallel matrix in sell format. For good matrix assembly performance the user should preallocate the matrix storage by setting the parameters <code>d_nz</code> (or <code>d_nnz</code>) and <code>o_nz</code> (or <code>o_nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>     - the matrix</li><li><code>d_nz</code>  - number of nonzeros per row in DIAGONAL portion of local submatrix</li></ul><p>(same value is used for all local rows)</p><ul><li><code>d_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>DIAGONAL portion of the local submatrix (possibly different for each row) or NULL (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>d_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;. For matrices that will be factored, you must leave room for (and set) the diagonal entry even if it is zero.</p><ul><li><code>o_nz</code>  - number of nonzeros per row in the OFF-DIAGONAL portion of local</li></ul><p>submatrix (same value is used for all local rows).</p><ul><li><code>o_nnz</code> - array containing the number of nonzeros in the various rows of the</li></ul><p>OFF-DIAGONAL portion of the local submatrix (possibly different for each row) or NULL (<code>PETSC_NULL_INTEGER</code> in Fortran), if <code>o_nz</code> is used to specify the nonzero structure. The size of this array is equal to the number of local rows, i.e &#39;m&#39;.</p><p>Example usage: Consider the following 8x8 matrix with 34 non-zero values, that is assembled across 3 processors. Lets assume that proc0 owns 3 rows, proc1 owns 3 rows, proc2 owns 2 rows. This division can be shown as follows</p><p>-seealso: <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqSELL()</code>, <code>MatSetValues()</code>, <code>MatCreateSELL()</code>, <code>MATMPISELL</code>, <code>MatGetInfo()</code>, <code>PetscSplitOwnership()</code>, <code>MATSELL</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMPISELLSetPreallocation.html"><code>Mat/MatMPISELLSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8954-L8991">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatInterpolate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatInterpolate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatInterpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatInterpolate(petsclib::PetscLibType,A::PetscMat, x::PetscMat, y::PetscMat)</code></pre><p>Y = A<em>X or A^T</em>X depending on the shape of <code>A</code></p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the input dense matrix</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the output dense matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInterpolate()</code>, <code>MatRestrict()</code>, <code>MatMatRestrict()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatInterpolate.html"><code>Mat/MatMatInterpolate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6686-L6705">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatInterpolateAdd-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatInterpolateAdd-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 4}}"><code>PETSc.LibPETSc.MatMatInterpolateAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatInterpolateAdd(petsclib::PetscLibType,A::PetscMat, x::PetscMat, w::PetscMat, y::PetscMat)</code></pre><p>Y = W + A<em>X or W + A^T</em>X depending on the shape of <code>A</code></p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the input dense matrix to be multiplied</li><li><code>w</code> - the input dense matrix to be added to the result</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the output dense matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatInterpolateAdd()</code>, <code>MatMatInterpolate()</code>, <code>MatMatRestrict()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatInterpolateAdd.html"><code>Mat/MatMatInterpolateAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6648-L6668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatMatMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatMatMult(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, scall::MatReuse, fill::PetscReal, D::PetscMat)</code></pre><p>Performs matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the left matrix</li><li><code>B</code>     - the middle matrix</li><li><code>C</code>     - the right matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(D)/(nnz(A) + nnz(B)+nnz(C)), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if you do not have a good estimate</li></ul><p>if the result is a dense matrix this is irrelevant</p><p>Output Parameter:</p><ul><li><code>D</code> - the product matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MATPRODUCT_ABC</code>, <code>MatMatMult</code>, <code>MatPtAP()</code>, <code>MatMatTransposeMult()</code>, <code>MatTransposeMatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatMatMult.html"><code>Mat/MatMatMatMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8026-L8049">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatMult(petsclib::PetscLibType,A::PetscMat, B::PetscMat, scall::MatReuse, fill::PetscReal, C::PetscMat)</code></pre><p>Performs matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the left matrix</li><li><code>B</code>     - the right matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(C)/(nnz(A) + nnz(B)), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if you do not have a good estimate</li></ul><p>if the result is a dense matrix this is irrelevant</p><p>Output Parameter:</p><ul><li><code>C</code> - the product matrix</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductType</code>, <code>MATPRODUCT_AB</code>, <code>MatTransposeMatMult()</code>, <code>MatMatTransposeMult()</code>, <code>MatPtAP()</code>, <code>MatProductCreate()</code>, <code>MatProductSymbolic()</code>, <code>MatProductReplaceMats()</code>, <code>MatProductNumeric()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatMult.html"><code>Mat/MatMatMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7905-L7925">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMatMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMatMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, n::PetscInt)</code></pre><p>Test A<em>B</em>x = C*x for n random vector x</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatMultEqual.html"><code>Mat/MatMatMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20237-L20258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatRestrict-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatRestrict-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatRestrict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatRestrict(petsclib::PetscLibType,A::PetscMat, x::PetscMat, y::PetscMat)</code></pre><p>Y = A<em>X or A^T</em>X depending on the shape of <code>A</code></p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the input dense matrix</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the output dense matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRestrict()</code>, <code>MatInterpolate()</code>, <code>MatMatInterpolate()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatRestrict.html"><code>Mat/MatMatRestrict</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6723-L6742">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatSolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatSolve(petsclib::PetscLibType,A::PetscMat, B::PetscMat, X::PetscMat)</code></pre><p>Solves A X = B, given a factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the factored matrix</li><li><code>B</code> - the right-hand-side matrix <code>MATDENSE</code> (or sparse <code>MATAIJ</code>– when using MUMPS)</li></ul><p>Output Parameter:</p><ul><li><code>X</code> - the result matrix (dense matrix)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatSolve()</code>, <code>MatMatSolveTranspose()</code>, <code>MatLUFactor()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatSolve.html"><code>Mat/MatMatSolve</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3208-L3227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatSolveTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatSolveTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatSolveTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatSolveTranspose(petsclib::PetscLibType,A::PetscMat, B::PetscMat, X::PetscMat)</code></pre><p>Solves A^T X = B , given a factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the factored matrix</li><li><code>B</code> - the right-hand-side matrix  (<code>MATDENSE</code> matrix)</li></ul><p>Output Parameter:</p><ul><li><code>X</code> - the result matrix (dense matrix)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatSolveTranspose()</code>, <code>MatMatSolve()</code>, <code>MatLUFactor()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatSolveTranspose.html"><code>Mat/MatMatSolveTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3243-L3262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatTransposeMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatTransposeMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatTransposeMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatTransposeMult(petsclib::PetscLibType,A::PetscMat, B::PetscMat, scall::MatReuse, fill::PetscReal, C::PetscMat)</code></pre><p>Performs matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the left matrix</li><li><code>B</code>     - the right matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(C)/(nnz(A) + nnz(B)), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if not known</li></ul><p>Output Parameter:</p><ul><li><code>C</code> - the product matrix</li></ul><p>Options Database Key:</p><ul><li><code>-matmattransmult_mpidense_mpidense_via {allgatherv,cyclic}</code> - Choose between algorithms for <code>MATMPIDENSE</code> matrices: the</li></ul><p>first redundantly copies the transposed <code>B</code> matrix on each process and requires O(log P) communication complexity; the second never stores more than one portion of the <code>B</code> matrix at a time but requires O(P) communication complexity.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MATPRODUCT_ABt</code>, <code>MatMatMult()</code>, <code>MatTransposeMatMult()</code> <code>MatPtAP()</code>, <code>MatProductAlgorithm</code>, <code>MatProductType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatTransposeMult.html"><code>Mat/MatMatTransposeMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7943-L7969">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatTransposeMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatTransposeMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMatTransposeMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMatTransposeMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, n::PetscInt)</code></pre><p>Test A<em>B^T</em>x = C*x for n random vector x</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatTransposeMultEqual.html"><code>Mat/MatMatTransposeMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20315-L20336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMatTransposeSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMatTransposeSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMatTransposeSolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMatTransposeSolve(petsclib::PetscLibType,A::PetscMat, Bt::PetscMat, X::PetscMat)</code></pre><p>Solves A X = B^T, given a factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>  - the factored matrix</li><li><code>Bt</code> - the transpose of right-hand-side matrix as a <code>MATDENSE</code></li></ul><p>Output Parameter:</p><ul><li><code>X</code> - the result matrix (dense matrix)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatMatSolve()</code>, <code>MatMatSolveTranspose()</code>, <code>MatLUFactor()</code>, <code>MatCholeskyFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMatTransposeSolve.html"><code>Mat/MatMatTransposeSolve</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3278-L3297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMeshToCellGraph-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMeshToCellGraph-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMeshToCellGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMeshToCellGraph(petsclib::PetscLibType,mesh::PetscMat, ncommonnodes::PetscInt, dual::PetscMat)</code></pre><p>Convert a mesh to a cell graph.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mesh</code>         - the graph that represents the coupling of the vertices of the mesh</li><li><code>ncommonnodes</code> - mesh elements that share this number of common nodes are considered neighbors, use 2 for triangles and</li></ul><p>quadrilaterials, 3 for tetrahedrals and 4 for hexahedrals</p><p>Output Parameter:</p><ul><li><code>dual</code> - the dual graph</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCreateMPIAdj()</code>, <code>MatPartitioningCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMeshToCellGraph.html"><code>Mat/MatMeshToCellGraph</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20620-L20640">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMissingDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMissingDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMissingDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">missing::PetscBool,dd::PetscInt = MatMissingDiagonal(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Determine if sparse matrix is missing a diagonal entry (or block entry for <code>MATBAIJ</code> and <code>MATSBAIJ</code> matrices) in the nonzero structure</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>missing</code> - is any diagonal entry missing</li><li><code>dd</code>      - first diagonal entry that is missing (optional) on this process</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMissingDiagonal.html"><code>Mat/MatMissingDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1176-L1195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMult(petsclib::PetscLibType,mat::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>Computes the matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>x</code>   - the vector to be multiplied</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMult.html"><code>Mat/MatMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2521-L2540">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultAdd(petsclib::PetscLibType,mat::PetscMat, v1::PetscVec, v2::PetscVec, v3::PetscVec)</code></pre><p>Computes v3 = v2 + A * v1.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>v1</code>  - the vector to be multiplied by <code>mat</code></li><li><code>v2</code>  - the vector to be added to the result</li></ul><p>Output Parameter:</p><ul><li><code>v3</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultTranspose()</code>, <code>MatMult()</code>, <code>MatMultTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultAdd.html"><code>Mat/MatMultAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2626-L2646">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultAddEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultAddEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMultEqual()</code>, <code>MatMultTransposeEqual()</code>, <code>MatMultTransposeAddEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultAddEqual.html"><code>Mat/MatMultAddEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20047-L20067">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultDiagonalBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultDiagonalBlock-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultDiagonalBlock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultDiagonalBlock(petsclib::PetscLibType,mat::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>Computes the matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>x</code>   - the vector to be multiplied</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the result</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultDiagonalBlock.html"><code>Mat/MatMultDiagonalBlock</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2486-L2505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code>, <code>MatMultTransposeAddEqual()</code>, <code>MatIsLinear()</code>, <code>MatEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultEqual.html"><code>Mat/MatMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20009-L20029">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultHermitianTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultHermitianTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultHermitianTranspose(petsclib::PetscLibType,mat::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>Computes matrix Hermitian</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>x</code>   - the vector to be multiplied</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>MatMultAdd()</code>, <code>MatMultHermitianTransposeAdd()</code>, <code>MatMultTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultHermitianTranspose.html"><code>Mat/MatMultHermitianTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2591-L2610">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultHermitianTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultHermitianTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultHermitianTransposeAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultHermitianTransposeAdd(petsclib::PetscLibType,mat::PetscMat, v1::PetscVec, v2::PetscVec, v3::PetscVec)</code></pre><p>Computes v3 = v2 + A^H * v1.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>v1</code>  - the vector to be multiplied by the Hermitian transpose</li><li><code>v2</code>  - the vector to be added to the result</li></ul><p>Output Parameter:</p><ul><li><code>v3</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultHermitianTranspose()</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultHermitianTransposeAdd.html"><code>Mat/MatMultHermitianTransposeAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2698-L2718">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultHermitianTransposeAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultHermitianTransposeAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultHermitianTransposeAddEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultHermitianTransposeAddEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultHermitianTransposeAddEqual.html"><code>Mat/MatMultHermitianTransposeAddEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20199-L20219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultHermitianTransposeEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultHermitianTransposeEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultHermitianTransposeEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultHermitianTransposeEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultHermitianTransposeEqual.html"><code>Mat/MatMultHermitianTransposeEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20161-L20181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultTranspose(petsclib::PetscLibType,mat::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>Computes matrix transpose times a vector y = A^T * x.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>x</code>   - the vector to be multiplied</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code>, <code>MatMultHermitianTranspose()</code>, <code>MatTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultTranspose.html"><code>Mat/MatMultTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2556-L2575">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMultTransposeAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMultTransposeAdd(petsclib::PetscLibType,mat::PetscMat, v1::PetscVec, v2::PetscVec, v3::PetscVec)</code></pre><p>Computes v3 = v2 + A^T * v1.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>v1</code>  - the vector to be multiplied by the transpose of the matrix</li><li><code>v2</code>  - the vector to be added to the result</li></ul><p>Output Parameter:</p><ul><li><code>v3</code> - the result</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultTranspose()</code>, <code>MatMultAdd()</code>, <code>MatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultTransposeAdd.html"><code>Mat/MatMultTransposeAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2662-L2682">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultTransposeAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultTransposeAddEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultTransposeAddEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultTransposeAddEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultTransposeAddEqual.html"><code>Mat/MatMultTransposeAddEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20123-L20143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMultTransposeEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMultTransposeEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMultTransposeEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatMultTransposeEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeAddEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMultTransposeEqual.html"><code>Mat/MatMultTransposeEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20085-L20105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetCntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetCntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetCntl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">val::PetscReal = MatMumpsGetCntl(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter CNTL() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array CNTL()</li></ul><p>Output Parameter:</p><ul><li><code>val</code> - value of MUMPS CNTL(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetCntl.html"><code>Mat/MatMumpsGetCntl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17400-L17419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetIcntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetIcntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetIcntl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ival::PetscInt = MatMumpsGetIcntl(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter ICNTL() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array ICNTL()</li></ul><p>Output Parameter:</p><ul><li><code>ival</code> - value of MUMPS ICNTL(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetIcntl.html"><code>Mat/MatMumpsGetIcntl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17327-L17346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ival::PetscInt = MatMumpsGetInfo(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter INFO() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array INFO()</li></ul><p>Output Parameter:</p><ul><li><code>ival</code> - value of MUMPS INFO(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetInfo.html"><code>Mat/MatMumpsGetInfo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17539-L17558">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetInfog-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetInfog-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetInfog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ival::PetscInt = MatMumpsGetInfog(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter INFOG() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array INFOG()</li></ul><p>Output Parameter:</p><ul><li><code>ival</code> - value of MUMPS INFOG(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetInfog.html"><code>Mat/MatMumpsGetInfog</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17576-L17595">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetInverse-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetInverse-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMumpsGetInverse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMumpsGetInverse(petsclib::PetscLibType,F::PetscMat, spRHS::PetscMat)</code></pre><p>Get user</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li></ul><p>Output Parameter:</p><ul><li><code>spRHS</code> - sequential sparse matrix in <code>MATTRANSPOSEVIRTUAL</code> format with requested entries of inverse of <code>A</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatCreateTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetInverse.html"><code>Mat/MatMumpsGetInverse</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17437-L17455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetInverseTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetInverseTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMumpsGetInverseTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMumpsGetInverseTranspose(petsclib::PetscLibType,F::PetscMat, spRHST::PetscMat)</code></pre><p>Get user</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>F</code> - the factored matrix of A obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li></ul><p>Output Parameter:</p><ul><li><code>spRHST</code> - sequential sparse matrix in <code>MATAIJ</code> format containing the requested entries of inverse of <code>A</code>^T</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatCreateTranspose()</code>, <code>MatMumpsGetInverse()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetInverseTranspose.html"><code>Mat/MatMumpsGetInverseTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17471-L17489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetNullPivots-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetNullPivots-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetNullPivots</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size::PetscInt = MatMumpsGetNullPivots(petsclib::PetscLibType,F::PetscMat, array::PetscInt)</code></pre><p>Get MUMPS parameter PIVNUL_LIST() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li></ul><p>Output Parameters:</p><ul><li><code>size</code>  - local size of the array. The size of the array is non-zero only on MPI rank 0</li><li><code>array</code> - array of rows with null pivot, these rows follow 0-based indexing. The array gets allocated within the function and the user is responsible</li></ul><p>for freeing this array.</p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetNullPivots.html"><code>Mat/MatMumpsGetNullPivots</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17687-L17707">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetRinfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetRinfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetRinfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">val::PetscReal = MatMumpsGetRinfo(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter RINFO() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array RINFO()</li></ul><p>Output Parameter:</p><ul><li><code>val</code> - value of MUMPS RINFO(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetRinfo.html"><code>Mat/MatMumpsGetRinfo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17613-L17632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsGetRinfog-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsGetRinfog-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMumpsGetRinfog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">val::PetscReal = MatMumpsGetRinfog(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt)</code></pre><p>Get MUMPS parameter RINFOG() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array RINFOG()</li></ul><p>Output Parameter:</p><ul><li><code>val</code> - value of MUMPS RINFOG(icntl)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsGetRinfog.html"><code>Mat/MatMumpsGetRinfog</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17650-L17669">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsSetBlk-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsSetBlk-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><code>PETSc.LibPETSc.MatMumpsSetBlk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMumpsSetBlk(petsclib::PetscLibType,F::PetscMat, nblk::PetscInt, blkvar::Vector{PetscInt}, blkptr::Vector{PetscInt})</code></pre><p>Set user</p><p>Not collective, only relevant on the first process of the MPI communicator</p><p>Input Parameters:</p><ul><li><code>F</code>      - the factored matrix of A obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>nblk</code>   - the number of blocks</li><li><code>blkvar</code> - see MUMPS documentation, <code>blkvar(blkptr(iblk):blkptr(iblk+1)-1)</code>, (<code>iblk=1, nblk</code>) holds the variables associated to block <code>iblk</code></li><li><code>blkptr</code> - array starting at 1 and of size <code>nblk + 1</code> storing the prefix sum of all blocks</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>MATSOLVERMUMPS</code>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatSetVariableBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsSetBlk.html"><code>Mat/MatMumpsSetBlk</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17505-L17523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsSetCntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsSetCntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Float64}"><code>PETSc.LibPETSc.MatMumpsSetCntl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMumpsSetCntl(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt, val::PetscReal)</code></pre><p>Set MUMPS parameter CNTL() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array <code>CNTL()</code></li><li><code>val</code>   - value of MUMPS <code>CNTL(icntl)</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_mumps_cntl_&lt;icntl&gt; &lt;val&gt;</code> - change the option numbered icntl to ival</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsSetIcntl()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsSetCntl.html"><code>Mat/MatMumpsSetCntl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17364-L17384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMumpsSetIcntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMumpsSetIcntl-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatMumpsSetIcntl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMumpsSetIcntl(petsclib::PetscLibType,F::PetscMat, icntl::PetscInt, ival::PetscInt)</code></pre><p>Set MUMPS parameter ICNTL() &lt;https://mumps</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code> with a <code>MatSolverType</code> of <code>MATSOLVERMUMPS</code> and a <code>MatFactorType</code> of <code>MAT_FACTOR_LU</code> or <code>MAT_FACTOR_CHOLESKY</code></li><li><code>icntl</code> - index of MUMPS parameter array <code>ICNTL()</code></li><li><code>ival</code>  - value of MUMPS <code>ICNTL(icntl)</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_mumps_icntl_&lt;icntl&gt; &lt;ival&gt;</code> - change the option numbered <code>icntl</code> to <code>ival</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatMumpsGetIcntl()</code>, <code>MatMumpsSetCntl()</code>, <code>MatMumpsGetCntl()</code>, <code>MatMumpsGetInfo()</code>, <code>MatMumpsGetInfog()</code>, <code>MatMumpsGetRinfo()</code>, <code>MatMumpsGetRinfog()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMumpsSetIcntl.html"><code>Mat/MatMumpsSetIcntl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17291-L17311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestGetISs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestGetISs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}}"><code>PETSc.LibPETSc.MatNestGetISs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestGetISs(petsclib::PetscLibType,A::PetscMat, rows::Vector{IS}, cols::Vector{IS})</code></pre><p>Returns the index sets partitioning the row and column spaces of a <code>MATNEST</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - <code>MATNEST</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>rows</code> - array of row index sets (pass <code>NULL</code> to ignore)</li><li><code>cols</code> - array of column index sets (pass <code>NULL</code> to ignore)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetSubMats()</code>, <code>MatNestGetSize()</code>, <code>MatNestGetLocalISs()</code>, <code>MatCreateNest()</code>, <code>MatNestSetSubMats()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestGetISs.html"><code>Mat/MatNestGetISs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15243-L15263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestGetLocalISs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestGetLocalISs-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.IS}}"><code>PETSc.LibPETSc.MatNestGetLocalISs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestGetLocalISs(petsclib::PetscLibType,A::PetscMat, rows::Vector{IS}, cols::Vector{IS})</code></pre><p>Returns the index sets partitioning the row and column spaces of a <code>MATNEST</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - <code>MATNEST</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>rows</code> - array of row index sets (pass <code>NULL</code> to ignore)</li><li><code>cols</code> - array of column index sets (pass <code>NULL</code> to ignore)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetSubMats()</code>, <code>MatNestGetSize()</code>, <code>MatNestGetISs()</code>, <code>MatCreateNest()</code>, <code>MatNestSetSubMats()</code>, <code>MatNestSetSubMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestGetLocalISs.html"><code>Mat/MatNestGetLocalISs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15279-L15299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestGetSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestGetSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNestGetSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">M::PetscInt,N::PetscInt = MatNestGetSize(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Returns the size of the <code>MATNEST</code> matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - <code>MATNEST</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>M</code> - number of rows in the nested mat</li><li><code>N</code> - number of cols in the nested mat</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetSubMats()</code>, <code>MatCreateNest()</code>, <code>MatNestGetLocalISs()</code>, <code>MatNestGetISs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestGetSize.html"><code>Mat/MatNestGetSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15203-L15223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestGetSubMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestGetSubMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNestGetSubMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestGetSubMat(petsclib::PetscLibType,A::PetscMat, idxm::PetscInt, jdxm::PetscInt, sub::PetscMat)</code></pre><p>Returns a single, sub</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - <code>MATNEST</code> matrix</li><li><code>idxm</code> - index of the matrix within the nest matrix</li><li><code>jdxm</code> - index of the matrix within the nest matrix</li></ul><p>Output Parameter:</p><ul><li><code>sub</code> - matrix at index <code>idxm</code>, <code>jdxm</code> within the nest matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestGetSize()</code>, <code>MatNestGetSubMats()</code>, <code>MatCreateNest()</code>, <code>MatNestSetSubMat()</code>, <code>MatNestGetLocalISs()</code>, <code>MatNestGetISs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestGetSubMat.html"><code>Mat/MatNestGetSubMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15088-L15109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestGetSubMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestGetSubMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNestGetSubMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">M::PetscInt,N::PetscInt = MatNestGetSubMats(petsclib::PetscLibType,A::PetscMat, mat::PetscMat)</code></pre><p>Returns the entire two dimensional array of matrices defining a <code>MATNEST</code> matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - nest matrix</li></ul><p>Output Parameters:</p><ul><li><code>M</code>   - number of submatrix rows in the nest matrix</li><li><code>N</code>   - number of submatrix columns in the nest matrix</li><li><code>mat</code> - array of matrices</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestGetSize()</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetLocalISs()</code>, <code>MatCreateNest()</code>, <code>MatNestSetSubMats()</code>, <code>MatNestGetISs()</code>, <code>MatNestSetSubMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestGetSubMats.html"><code>Mat/MatNestGetSubMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15162-L15183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestSetSubMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestSetSubMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNestSetSubMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestSetSubMat(petsclib::PetscLibType,A::PetscMat, idxm::PetscInt, jdxm::PetscInt, sub::PetscMat)</code></pre><p>Set a single submatrix in the <code>MATNEST</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - <code>MATNEST</code> matrix</li><li><code>idxm</code> - index of the matrix within the nest matrix</li><li><code>jdxm</code> - index of the matrix within the nest matrix</li><li><code>sub</code>  - matrix at index <code>idxm</code>, <code>jdxm</code> within the nest matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatNestSetSubMats()</code>, <code>MatNestGetSubMats()</code>, <code>MatNestGetLocalISs()</code>, <code>MatCreateNest()</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetISs()</code>, <code>MatNestGetSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestSetSubMat.html"><code>Mat/MatNestSetSubMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15127-L15146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestSetSubMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestSetSubMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.IS}, Int64, Vector{PETSc.LibPETSc.IS}, Vector{PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatNestSetSubMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestSetSubMats(petsclib::PetscLibType,A::PetscMat, nr::PetscInt, is_row::Vector{IS}, nc::PetscInt, is_col::Vector{IS}, a::Vector{PetscMat})</code></pre><p>Sets the nested submatrices in a <code>MATNEST</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - <code>MATNEST</code> matrix</li><li><code>nr</code>     - number of nested row blocks</li><li><code>is_row</code> - index sets for each nested row block, or <code>NULL</code> to make contiguous</li><li><code>nc</code>     - number of nested column blocks</li><li><code>is_col</code> - index sets for each nested column block, or <code>NULL</code> to make contiguous</li><li><code>a</code>      - array of  nr 	imes nc submatrices, or <code>NULL</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatCreateNest()</code>, <code>MatNestSetSubMat()</code>, <code>MatNestGetSubMat()</code>, <code>MatNestGetSubMats()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestSetSubMats.html"><code>Mat/MatNestSetSubMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15347-L15367">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNestSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNestSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatNestSetVecType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNestSetVecType(petsclib::PetscLibType,A::PetscMat, vtype::VecType)</code></pre><p>Sets the type of <code>Vec</code> returned by <code>MatCreateVecs()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - <code>MATNEST</code> matrix</li><li><code>vtype</code> - <code>VecType</code> to use for creating vectors</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNEST</code>, <code>MatCreateVecs()</code>, <code>MatCreateNest()</code>, <code>VecType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNestSetVecType.html"><code>Mat/MatNestSetVecType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15315-L15331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNorm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.NormType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNorm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.NormType}"><code>PETSc.LibPETSc.MatNorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nrm::PetscReal = MatNorm(petsclib::PetscLibType,mat::PetscMat, type::NormType)</code></pre><p>Calculates various norms of a matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>type</code> - the type of norm, <code>NORM_1</code>, <code>NORM_FROBENIUS</code>, <code>NORM_INFINITY</code></li></ul><p>Output Parameter:</p><ul><li><code>nrm</code> - the resulting norm</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNorm.html"><code>Mat/MatNorm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4504-L4523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNormalGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNormalGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNormalGetMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNormalGetMat(petsclib::PetscLibType,A::PetscMat, M::PetscMat)</code></pre><p>Gets the <code>Mat</code> object stored inside a <code>MATNORMAL</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATNORMAL</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>M</code> - the matrix object stored inside <code>A</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNORMAL</code>, <code>MATNORMALHERMITIAN</code>, <code>MatCreateNormal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNormalGetMat.html"><code>Mat/MatNormalGetMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14493-L14511">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNormalHermitianGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNormalHermitianGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNormalHermitianGetMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNormalHermitianGetMat(petsclib::PetscLibType,A::PetscMat, M::PetscMat)</code></pre><p>Gets the <code>Mat</code> object stored inside a <code>MATNORMALHERMITIAN</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATNORMALHERMITIAN</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>M</code> - the matrix object stored inside <code>A</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATNORMALHERMITIAN</code>, <code>MatCreateNormalHermitian()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNormalHermitianGetMat.html"><code>Mat/MatNormalHermitianGetMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14565-L14583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatOrderingRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatOrderingRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatOrderingRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatOrderingRegister(petsclib::PetscLibType,sname::Vector{Cchar}, fnc::external)</code></pre><p>Adds a new sparse matrix ordering to the matrix package.</p><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of ordering (for example <code>MATORDERINGND</code>)</li><li><code>function</code> - function pointer that creates the ordering</li></ul><p>Level: developer</p><p>-seealso: <code>Mat</code>, <code>MatOrderingType</code>, <code>MatOrderingRegisterAll()</code>, <code>MatGetOrdering()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatOrderingRegister.html"><code>Mat/MatOrderingRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20537-L20553">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPermute-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPermute-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPermute</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPermute(petsclib::PetscLibType,mat::PetscMat, row::IS, col::IS, B::PetscMat)</code></pre><p>Creates a new matrix with rows and columns permuted from the original.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix to permute</li><li><code>row</code> - row permutation, each processor supplies only the permutation for its rows</li><li><code>col</code> - column permutation, each processor supplies only the permutation for its columns</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the permuted matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetOrdering()</code>, <code>ISAllGather()</code>, <code>MatCreateSubMatrix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPermute.html"><code>Mat/MatPermute</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4361-L4382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPreallocatorPreallocate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPreallocatorPreallocate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPreallocatorPreallocate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPreallocatorPreallocate(petsclib::PetscLibType,mat::PetscMat, fill::PetscBool, A::PetscMat)</code></pre><p>Preallocates the A matrix, using information from a <code>MATPREALLOCATOR</code> mat, optionally filling A with zeros</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the <code>MATPREALLOCATOR</code> preallocator matrix</li><li><code>fill</code> - fill the matrix with zeros</li><li><code>A</code>    - the matrix to be preallocated</li></ul><p>-seealso: <code>MATPREALLOCATOR</code>, <code>MatXAIJSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPreallocatorPreallocate.html"><code>Mat/MatPreallocatorPreallocate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9391-L9404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductClear-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductClear-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductClear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductClear(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Clears from the matrix any internal data structures related to the computation of the values of the matrix from matrix</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Options Database Key:</p><ul><li><code>-mat_product_clear</code> - Clear intermediate data structures after <code>MatProductNumeric()</code> has been called</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductClear.html"><code>Mat/MatProductClear</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L526-L544">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatProductCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">D::PetscMat = MatProductCreate(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat)</code></pre><p>create a matrix to hold the result of a matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix (or <code>NULL</code>)</li></ul><p>Output Parameter:</p><ul><li><code>D</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Level: intermediate</p><p>Example: -seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreateWithMat()</code>, <code>MatProductSetType()</code>, <code>MatProductSetAlgorithm()</code>, <code>MatProductClear()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductCreate.html"><code>Mat/MatProductCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L595-L616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductCreateWithMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductCreateWithMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductCreateWithMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductCreateWithMat(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, D::PetscMat)</code></pre><p>Set a given matrix to have its values computed via matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix (optional, use <code>NULL</code> if not needed)</li><li><code>D</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductType</code>, <code>MatProductSetType()</code>, <code>MatProductAlgorithm</code>, <code>MatProductSetAlgorithm</code>, <code>MatProductCreate()</code>, <code>MatProductClear()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductCreateWithMat.html"><code>Mat/MatProductCreateWithMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L560-L579">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductGetAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductGetAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatProductGetAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductGetAlgorithm(petsclib::PetscLibType,mat::PetscMat, alg::MatProductAlgorithm)</code></pre><p>Returns the selected algorithm for a matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix whose values are computed via a matrix-matrix product operation</li></ul><p>Output Parameter:</p><ul><li><code>alg</code> - the selected algorithm of the matrix product, e.g., <code>MATPRODUCTALGORITHMDEFAULT</code>.</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductSetAlgorithm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductGetAlgorithm.html"><code>Mat/MatProductGetAlgorithm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L458-L476">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductGetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductGetMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.PetscMat}}"><code>PETSc.LibPETSc.MatProductGetMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductGetMats(petsclib::PetscLibType,mat::PetscMat, A::PetscMat, B::PetscMat, C::PetscMat)</code></pre><p>Returns the matrices associated with the matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Output Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix (may be <code>NULL</code> for some <code>MatProductType</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreateWithMat()</code>, <code>MatProductSetType()</code>, <code>MatProductSetAlgorithm()</code>, <code>MatProductCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductGetMats.html"><code>Mat/MatProductGetMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L670-L690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mtype::MatProductType = MatProductGetType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Returns the type of matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Output Parameter:</p><ul><li><code>mtype</code> - the <code>MatProductType</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreateWithMat()</code>, <code>MatProductSetType()</code>, <code>MatProductCreate()</code>, <code>MatProductType</code>, <code>MatProductAlgorithm</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductGetType.html"><code>Mat/MatProductGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L634-L652">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductNumeric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductNumeric(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Compute a matrix</p><p>Collective</p><p>Input/Output Parameter:</p><ul><li><code>mat</code> - the matrix whose values are computed via a matrix-matrix product operation</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductSetAlgorithm()</code>, <code>MatProductSetType()</code>, <code>MatProductCreate()</code>, <code>MatSetType()</code>, <code>MatProductSymbolic()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductNumeric.html"><code>Mat/MatProductNumeric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L327-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductReplaceMats-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{Union{Ptr, PETSc.LibPETSc.PetscMat}, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductReplaceMats-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{Union{Ptr, PETSc.LibPETSc.PetscMat}, 4}}"><code>PETSc.LibPETSc.MatProductReplaceMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductReplaceMats(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, D::PetscMat)</code></pre><p>Replace the input matrices for the matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix or <code>NULL</code> if not being replaced</li><li><code>B</code> - the matrix or <code>NULL</code> if not being replaced</li><li><code>C</code> - the matrix or <code>NULL</code> if not being replaced</li><li><code>D</code> - the matrix whose values are computed via a matrix-matrix product operation</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MatProductSetFromOptions()</code>, <code>MatProductSymbolic()</code>, <code>MatProductClear()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductReplaceMats.html"><code>Mat/MatProductReplaceMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L223-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductSetAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductSetAlgorithm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatProductSetAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductSetAlgorithm(petsclib::PetscLibType,mat::PetscMat, alg::MatProductAlgorithm)</code></pre><p>Requests a particular algorithm for a matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix whose values are computed via a matrix-matrix product operation</li><li><code>alg</code> - particular implementation algorithm of the matrix product, e.g., <code>MATPRODUCTALGORITHMDEFAULT</code>.</li></ul><p>Options Database Key:</p><ul><li><code>-mat_product_algorithm &lt;algorithm&gt;</code> - Sets the algorithm, see <code>MatProductAlgorithm</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductClear()</code>, <code>MatProductSetType()</code>, <code>MatProductSetFill()</code>, <code>MatProductCreate()</code>, <code>MatProductAlgorithm</code>, <code>MatProductType</code>, <code>MatProductGetAlgorithm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductSetAlgorithm.html"><code>Mat/MatProductSetAlgorithm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L423-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductSetFill-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductSetFill-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatProductSetFill</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductSetFill(petsclib::PetscLibType,mat::PetscMat, fill::PetscReal)</code></pre><p>Set an expected fill of the matrix whose values are computed via a matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix whose values are to be computed via a matrix-matrix product operation</li><li><code>fill</code> - expected fill as ratio of nnz(mat)/(nnz(A) + nnz(B) + nnz(C)); use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if you do not have a good estimate.</li></ul><p>If the product is a dense matrix, this value is not used.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>PETSC_DETERMINE</code>, <code>Mat</code>, <code>MatProductSetFromOptions()</code>, <code>MatProductSetType()</code>, <code>MatProductSetAlgorithm()</code>, <code>MatProductCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductSetFill.html"><code>Mat/MatProductSetFill</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L390-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductSetFromOptions(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Sets the options for the computation of a matrix the algorithm etc are determined from the options database.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix whose values are computed via a matrix-matrix product operation</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_product_clear</code>                 - Clear intermediate data structures after <code>MatProductNumeric()</code> has been called</li><li><code>-mat_product_algorithm &lt;algorithm&gt;</code> - Sets the algorithm, see <code>MatProductAlgorithm</code> for possible values</li><li><code>-mat_product_algorithm_backend_cpu</code> - Use the CPU to perform the computation even if the matrix is a GPU matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatSetFromOptions()</code>, <code>MatProductCreate()</code>, <code>MatProductCreateWithMat()</code>, <code>MatProductNumeric()</code>, <code>MatProductSetType()</code>, <code>MatProductSetAlgorithm()</code>, <code>MatProductAlgorithm</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductSetFromOptions.html"><code>Mat/MatProductSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L257-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatProductType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatProductType}"><code>PETSc.LibPETSc.MatProductSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductSetType(petsclib::PetscLibType,mat::PetscMat, productype::MatProductType)</code></pre><p>Sets a particular matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>        - the matrix whose values are computed via a matrix-matrix product operation</li><li><code>productype</code> - matrix product type, e.g., <code>MATPRODUCT_AB</code>,<code>MATPRODUCT_AtB</code>,<code>MATPRODUCT_ABt</code>,<code>MATPRODUCT_PtAP</code>,<code>MATPRODUCT_RARt</code>,<code>MATPRODUCT_ABC</code>,</li></ul><p>see <code>MatProductType</code></p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MatProductType</code>, <code>MATPRODUCT_AB</code>, <code>MATPRODUCT_AtB</code>, <code>MATPRODUCT_ABt</code>, <code>MATPRODUCT_PtAP</code>, <code>MATPRODUCT_RARt</code>, <code>MATPRODUCT_ABC</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductSetType.html"><code>Mat/MatProductSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L492-L510">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatProductSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductSymbolic(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Perform the symbolic portion of a matrix product to be done with <code>MatProductNumeric()</code></p><p>Collective</p><p>Input/Output Parameter:</p><ul><li><code>mat</code> - the matrix whose values are to be computed via a matrix-matrix product operation</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProduct</code>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MatProductCreateWithMat()</code>, <code>MatProductSetFromOptions()</code>, <code>MatProductNumeric()</code>, <code>MatProductSetType()</code>, <code>MatProductSetAlgorithm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductSymbolic.html"><code>Mat/MatProductSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L358-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatProductView-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatProductView-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatProductView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatProductView(petsclib::PetscLibType,mat::PetscMat, viewer::PetscViewer)</code></pre><p>View the private matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix obtained with <code>MatProductCreate()</code> or <code>MatProductCreateWithMat()</code></li><li><code>viewer</code> - where the information on the matrix-matrix algorithm of <code>mat</code> should be reviewed</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatProductType</code>, <code>Mat</code>, <code>MatProductSetFromOptions()</code>, <code>MatView()</code>, <code>MatProductCreate()</code>, <code>MatProductCreateWithMat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatProductView.html"><code>Mat/MatProductView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L295-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPropagateSymmetryOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPropagateSymmetryOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPropagateSymmetryOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPropagateSymmetryOptions(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Propagates symmetry options set on a matrix to another matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix we wish to propagate options from</li><li><code>B</code> - the matrix we wish to propagate options to</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MatIsSymmetricKnown()</code>, <code>MatIsSPDKnown()</code>, <code>MatIsHermitianKnown()</code>, <code>MatIsStructurallySymmetricKnown()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPropagateSymmetryOptions.html"><code>Mat/MatPropagateSymmetryOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6469-L6485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPtAP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPtAP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPtAP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPtAP(petsclib::PetscLibType,A::PetscMat, P::PetscMat, scall::MatReuse, fill::PetscReal, C::PetscMat)</code></pre><p>Creates the matrix product C = P^T * A * P</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>P</code>     - the projection matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(C)/(nnz(A) + nnz(P)), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if you do not have a good estimate</li></ul><p>if the result is a dense matrix this is irrelevant</p><p>Output Parameter:</p><ul><li><code>C</code> - the product matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MatMatMult()</code>, <code>MatRARt()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPtAP.html"><code>Mat/MatPtAP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7825-L7847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPtAPMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPtAPMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatPtAPMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatPtAPMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPtAPMultEqual.html"><code>Mat/MatPtAPMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20354-L20375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPythonCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPythonCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, Int64, Int64, Int64, Int64, Vector{Int8}}"><code>PETSc.LibPETSc.MatPythonCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">A::PetscMat = MatPythonCreate(petsclib::PetscLibType,comm::MPI_Comm, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, pyname::Vector{Cchar})</code></pre><p>Create a <code>Mat</code> object implemented in Python.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>  - MPI communicator</li><li><code>m</code>  - number of local rows (or <code>PETSC_DECIDE</code> to have calculated if <code>M</code> is given)</li><li><code>n</code>  - number of local columns (or <code>PETSC_DECIDE</code> to have calculated if <code>N</code> is given)</li><li><code>M</code>  - number of global rows (or <code>PETSC_DECIDE</code> to have calculated if <code>m</code> is given)</li><li><code>N</code>  - number of global columns (or <code>PETSC_DECIDE</code> to have calculated if <code>n</code> is given)</li><li><code>pyname</code>  - full dotted Python name [package].module[.{class|function}]</li></ul><p>Output Parameter:</p><ul><li><code>A</code>  - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MATPYTHON</code>, <code>MatPythonSetType()</code>, <code>PetscPythonInitialize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPythonCreate.html"><code>Mat/MatPythonCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10180-L10203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPythonGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPythonGetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPythonGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pyname::Vector{Cchar} = MatPythonGetType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Get the Python name of a <code>Mat</code> object implemented in Python.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code>  - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>pyname</code>  - full dotted Python name [package].module[.{class|function}]</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MatCreate()</code>, <code>MatSetType()</code>, <code>MATPYTHON</code>, <code>PetscPythonInitialize()</code>, <code>MatPythonSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPythonGetType.html"><code>Mat/MatPythonGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10144-L10162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPythonSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPythonSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatPythonSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPythonSetType(petsclib::PetscLibType,mat::PetscMat, pyname::Vector{Cchar})</code></pre><p>Initialize a <code>Mat</code> object implemented in Python.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix object.</li><li><code>pyname</code>  - full dotted Python name [package].module[.{class|function}]</li></ul><p>Options Database Key:</p><ul><li><code>-mat_python_type &lt;pyname&gt;</code>  - python class</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MatCreate()</code>, <code>MatSetType()</code>, <code>MATPYTHON</code>, <code>PetscPythonInitialize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPythonSetType.html"><code>Mat/MatPythonSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10109-L10128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatQRFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatQRFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatQRFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatQRFactor(petsclib::PetscLibType,mat::PetscMat, col::IS, info::MatFactorInfo)</code></pre><p>Performs in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>col</code>  - column permutation</li><li><code>info</code> - options for factorization, includes</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code>, <code>MatQRFactorSymbolic()</code>, <code>MatQRFactorNumeric()</code>, <code>MatLUFactor()</code>, <code>MatSetUnfactored()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatQRFactor.html"><code>Mat/MatQRFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3076-L3091">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatQRFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatQRFactorNumeric-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatQRFactorNumeric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatQRFactorNumeric(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, info::MatFactorInfo)</code></pre><p>Performs numeric QR factorization of a matrix. Call this routine after first calling <code>MatGetFactor()</code>, and <code>MatQRFactorSymbolic()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>info</code> - options for factorization</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorInfo</code>, <code>MatGetFactor()</code>, <code>MatQRFactor()</code>, <code>MatQRFactorSymbolic()</code>, <code>MatLUFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatQRFactorNumeric.html"><code>Mat/MatQRFactorNumeric</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3139-L3157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatQRFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatQRFactorSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.MatFactorInfo}"><code>PETSc.LibPETSc.MatQRFactorSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatQRFactorSymbolic(petsclib::PetscLibType,fact::PetscMat, mat::PetscMat, col::IS, info::MatFactorInfo)</code></pre><p>Performs symbolic QR factorization of matrix. Call this routine after <code>MatGetFactor()</code> but before calling <code>MatQRFactorNumeric()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>fact</code> - the factor matrix obtained with <code>MatGetFactor()</code></li><li><code>mat</code>  - the matrix</li><li><code>col</code>  - column permutation</li><li><code>info</code> - options for factorization, includes</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatFactorInfo</code>, <code>MatQRFactor()</code>, <code>MatQRFactorNumeric()</code>, <code>MatLUFactor()</code>, <code>MatFactorInfoInitialize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatQRFactorSymbolic.html"><code>Mat/MatQRFactorSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3107-L3123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRARt-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRARt-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatRARt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRARt(petsclib::PetscLibType,A::PetscMat, R::PetscMat, scall::MatReuse, fill::PetscReal, C::PetscMat)</code></pre><p>Creates the matrix product C = R * A * R^T</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>R</code>     - the projection matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(C)/nnz(A), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if you do not have a good estimate</li></ul><p>if the result is a dense matrix this is irrelevant</p><p>Output Parameter:</p><ul><li><code>C</code> - the product matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MatMatMult()</code>, <code>MatPtAP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRARt.html"><code>Mat/MatRARt</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7865-L7887">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRARtMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRARtMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatRARtMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatRARtMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, n::PetscInt)</code></pre><p>Compares matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRARtMultEqual.html"><code>Mat/MatRARtMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20393-L20414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRealPart-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatRealPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRealPart(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Zeros out the imaginary part of the matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatImaginaryPart()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRealPart.html"><code>Mat/MatRealPart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1075-L1090">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRegister(petsclib::PetscLibType,sname::Vector{Cchar}, fnc::external)</code></pre><p>Adds a new matrix type implementation that is usable as a <code>Mat</code> in PETSc</p><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of a new user-defined matrix type</li><li><code>function</code> - routine to create method context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>MatSetType()</code>, <code>MatRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRegister.html"><code>Mat/MatRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L160-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRegisterRootName-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Vector{Int8}, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRegisterRootName-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Vector{Int8}, Vector{Int8}}"><code>PETSc.LibPETSc.MatRegisterRootName</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRegisterRootName(petsclib::PetscLibType,rname::Vector{Cchar}, sname::Vector{Cchar}, mname::Vector{Cchar})</code></pre><p>Registers a name that can be used for either a sequential or its corresponding parallel matrix type.</p><p>Input Parameters:</p><ul><li><code>rname</code> - the rootname, for example, <code>MATAIJ</code></li><li><code>sname</code> - the name of the sequential matrix type, for example, <code>MATSEQAIJ</code></li><li><code>mname</code> - the name of the parallel matrix type, for example, <code>MATMPIAIJ</code></li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatType</code>, <code>PetscObjectBaseTypeCompare()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRegisterRootName.html"><code>Mat/MatRegisterRootName</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L192-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatReorderForNonzeroDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatReorderForNonzeroDiagonal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatReorderForNonzeroDiagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatReorderForNonzeroDiagonal(petsclib::PetscLibType,mat::PetscMat, abstol::PetscReal, ris::IS, cis::IS)</code></pre><p>Changes matrix ordering to remove zeros from diagonal. This may help in the <code>PCLU</code> factorization to prevent a zero pivot.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - matrix to reorder</li><li><code>abstol</code> - absolute tolerance, it attempts to move all values smaller off the diagonal</li><li><code>ris</code>    - the row reordering</li><li><code>cis</code>    - the column reordering; this may be changed</li></ul><p>Level: intermediate</p><p>Options Database Key:</p><ul><li><code>-pc_factor_nonzeros_along_diagonal</code> - Reorder to remove zeros from diagonal</li></ul><p>-seealso: <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatGetOrdering()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatReorderForNonzeroDiagonal.html"><code>Mat/MatReorderForNonzeroDiagonal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19135-L19158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatReorderingSeqSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatReorderingSeqSBAIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatReorderingSeqSBAIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatReorderingSeqSBAIJ(petsclib::PetscLibType,A::PetscMat, perm::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatReorderingSeqSBAIJ.html"><code>Mat/MatReorderingSeqSBAIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13456-L13461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatResetHash-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatResetHash-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat}"><code>PETSc.LibPETSc.MatResetHash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatResetHash(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Reset the matrix so that it will use a hash table for the next round of <code>MatSetValues()</code> and <code>MatAssemblyBegin()</code>/<code>MatAssemblyEnd()</code>.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatResetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatResetHash.html"><code>Mat/MatResetHash</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1630-L1645">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatResetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatResetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatResetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatResetPreallocation(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Reset matrix to use the original preallocation values provided by the user, for example with <code>MatXAIJSetPreallocation()</code></p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatXAIJSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatResetPreallocation.html"><code>Mat/MatResetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1599-L1614">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatResidual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatResidual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatResidual(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, x::PetscVec, r::PetscVec)</code></pre><p>Default routine to calculate the residual r = b</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>b</code>   - the right-hand-side</li><li><code>x</code>   - the approximate solution</li></ul><p>Output Parameter:</p><ul><li><code>r</code> - location to store the residual</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>MatMultAdd()</code>, <code>PCMGSetResidual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatResidual.html"><code>Mat/MatResidual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6160-L6180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreColumnIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreColumnIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatRestoreColumnIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,ia::Vector{PetscInt},ja::Vector{PetscInt},done::PetscBool = MatRestoreColumnIJ(petsclib::PetscLibType,mat::PetscMat, shift::PetscInt, symmetric::PetscBool, inodecompressed::PetscBool)</code></pre><p>Call after you are completed with the ia,ja indices obtained with <code>MatGetColumnIJ()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>             - the matrix</li><li><code>shift</code>           - 1 or zero indicating we want the indices starting at 0 or 1</li><li><code>symmetric</code>       - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating the matrix data structure should be symmetrized</li><li><code>inodecompressed</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating if the nonzero structure of the</li></ul><p>inodes or the nonzero elements is wanted. For <code>MATBAIJ</code> matrices the compressed version is always used.</p><p>Output Parameters:</p><ul><li><code>n</code>    - size of (possibly compressed) matrix</li><li><code>ia</code>   - the column pointers</li><li><code>ja</code>   - the row indices</li><li><code>done</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicated that the values have been returned</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetColumnIJ()</code>, <code>MatRestoreRowIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreColumnIJ.html"><code>Mat/MatRestoreColumnIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6348-L6374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreLocalSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreLocalSubMatrix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatRestoreLocalSubMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRestoreLocalSubMatrix(petsclib::PetscLibType,mat::PetscMat, isrow::IS, iscol::IS, submat::PetscMat)</code></pre><p>Restores a reference to a submatrix specified in local numbering obtained with <code>MatGetLocalSubMatrix()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - matrix to extract local submatrix from</li><li><code>isrow</code>  - local row indices for submatrix</li><li><code>iscol</code>  - local column indices for submatrix</li><li><code>submat</code> - the submatrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetLocalSubMatrix()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreLocalSubMatrix.html"><code>Mat/MatRestoreLocalSubMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8183-L8201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreNullSpaces-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}, Vector{Ptr{PETSc.LibPETSc._n_MatNullSpace}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreNullSpaces-Tuple{PETSc.LibPETSc.PetscLibType, Int64, Vector{PETSc.LibPETSc.PetscMat}, Vector{Ptr{PETSc.LibPETSc._n_MatNullSpace}}}"><code>PETSc.LibPETSc.MatRestoreNullSpaces</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRestoreNullSpaces(petsclib::PetscLibType,n::PetscInt, mat::Vector{PetscMat}, nullsp::Vector{MatNullSpace})</code></pre><p>sets the null spaces, transpose null spaces, and near null spaces obtained with <code>MatGetNullSpaces()</code> for an array of matrices</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>n</code>      - the number of matrices</li><li><code>mat</code>    - the array of matrices</li><li><code>nullsp</code> - an array of null spaces</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatGetNullSpace()</code>, <code>MatSetTransposeNullSpace()</code>, <code>MatGetTransposeNullSpace()</code>, <code>MatNullSpaceRemove()</code>, <code>MatGetNullSpaces()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreNullSpaces.html"><code>Mat/MatRestoreNullSpaces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6829-L6847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatRestoreRow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ncols::PetscInt,cols::Vector{PetscInt},vals::Vector{PetscScalar} = MatRestoreRow(petsclib::PetscLibType,mat::PetscMat, row::PetscInt)</code></pre><p>Frees any temporary space allocated by <code>MatGetRow()</code>.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>row</code>   - the row to get</li><li><code>ncols</code> - the number of nonzeros</li><li><code>cols</code>  - the columns of the nonzeros</li><li><code>vals</code>  - if nonzero the column values</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRow()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreRow.html"><code>Mat/MatRestoreRow</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1291-L1310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreRowIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreRowIJ-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, PETSc.LibPETSc.PetscBool, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatRestoreRowIJ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,ia::Vector{PetscInt},ja::Vector{PetscInt},done::PetscBool = MatRestoreRowIJ(petsclib::PetscLibType,mat::PetscMat, shift::PetscInt, symmetric::PetscBool, inodecompressed::PetscBool)</code></pre><p>Call after you are completed with the ia,ja indices obtained with <code>MatGetRowIJ()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>             - the matrix</li><li><code>shift</code>           - 1 or zero indicating we want the indices starting at 0 or 1</li><li><code>symmetric</code>       - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating the matrix data structure should be symmetrized</li><li><code>inodecompressed</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicating if the nonzero structure of the</li></ul><p>inodes or the nonzero elements is wanted. For <code>MATBAIJ</code> matrices the compressed version is always used.</p><ul><li><code>n</code>               - size of (possibly compressed) matrix</li><li><code>ia</code>              - the row pointers</li><li><code>ja</code>              - the column indices</li></ul><p>Output Parameter:</p><ul><li><code>done</code> - <code>PETSC_TRUE</code> or <code>PETSC_FALSE</code> indicated that the values have been returned</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRowIJ()</code>, <code>MatRestoreColumnIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreRowIJ.html"><code>Mat/MatRestoreRowIJ</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6298-L6324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestoreRowUpperTriangular-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestoreRowUpperTriangular-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatRestoreRowUpperTriangular</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRestoreRowUpperTriangular(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Disable calls to <code>MatGetRow()</code> for matrix in <code>MATSBAIJ</code> format.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSBAIJ</code>, <code>MatGetRowUpperTriangular()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestoreRowUpperTriangular.html"><code>Mat/MatRestoreRowUpperTriangular</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1364-L1379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRestrict-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRestrict-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatRestrict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRestrict(petsclib::PetscLibType,A::PetscMat, x::PetscVec, y::PetscVec)</code></pre><p>y = A<em>x or A^T</em>x</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>x</code> - the vector to be restricted</li></ul><p>Output Parameter:</p><ul><li><code>y</code> - the resulting vector</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMultAdd()</code>, <code>MatMultTransposeAdd()</code>, <code>MatInterpolate()</code>, <code>PCMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRestrict.html"><code>Mat/MatRestrict</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6613-L6632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatRetrieveValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatRetrieveValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatRetrieveValues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatRetrieveValues(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Retrieves the copy of the matrix values that was stored with <code>MatStoreValues()</code></p><p>Logically Collect</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix (currently only <code>MATAIJ</code> matrices support this option)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatStoreValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatRetrieveValues.html"><code>Mat/MatRetrieveValues</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17841-L17856">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSNESMFGetReuseBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSNESMFGetReuseBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSNESMFGetReuseBase</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">use::PetscBool = MatSNESMFGetReuseBase(petsclib::PetscLibType,J::PetscMat)</code></pre><p>Determines if the base vector is to be used for differencing even if the function provided to <code>SNESSetFunction()</code> is not the same as that provided to <code>MatMFFDSetFunction()</code>.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>J</code> - the <code>MATMFFD</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>use</code> - if true always reuse the base vector instead of recomputing f(u) even if the function in the <code>MATMFFD</code> is</li></ul><p>not <code>SNESComputeFunction()</code></p><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>Mat</code>, <code>SNES</code>, <code>MatSNESMFSetReuseBase()</code>, <code>MatCreateSNESMF()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatSNESMFGetReuseBase.html"><code>Snes/MatSNESMFGetReuseBase</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22819-L22839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSNESMFGetSNES-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscSNES}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSNESMFGetSNES-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscSNES}"><code>PETSc.LibPETSc.MatSNESMFGetSNES</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSNESMFGetSNES(petsclib::PetscLibType,J::PetscMat, snes::PetscSNES)</code></pre><p>returns the <code>SNES</code> associated with a matrix created with <code>MatCreateSNESMF()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>J</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>snes</code> - the <code>SNES</code> object</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>Mat</code>, <code>SNES</code>, <code>MatCreateSNESMF()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatSNESMFGetSNES.html"><code>Snes/MatSNESMFGetSNES</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22749-L22767">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSNESMFMoreSetParameters-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, Float64, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSNESMFMoreSetParameters-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64, Float64, Float64}"><code>PETSc.LibPETSc.MatSNESMFMoreSetParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSNESMFMoreSetParameters(petsclib::PetscLibType,mat::PetscMat, error::PetscReal, umin::PetscReal, h::PetscReal)</code></pre><p>Sets the parameters for the approximation of matrix-vector products using finite differences, see  <code>MatCreateSNESMFMore()</code></p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>error</code> - relative error (should be set to the square root of the relative error in the function evaluations)</li><li><code>umin</code>  - minimum allowable u-value</li><li><code>h</code>     - differencing parameter</li></ul><p>Options Database Keys:</p><ul><li><code>-snes_mf_err &lt;error_rel&gt;</code> - see <code>MatCreateSNESMF()</code></li><li><code>-snes_mf_umin &lt;umin&gt;</code>     - see <code>MatCreateSNESMF()</code></li><li><code>-snes_mf_compute_err</code>     - compute the square root or relative error in function</li><li><code>-snes_mf_freq_err &lt;freq&gt;</code> - set the frequency to recompute the parameters</li><li><code>-snes_mf_jorge</code>           - use the method of Jorge More</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>SNES</code>, <code>MatCreateSNESMF()</code>, <code>MatCreateSNESMFMore()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatSNESMFMoreSetParameters.html"><code>Snes/MatSNESMFMoreSetParameters</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22709-L22733">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSNESMFSetReuseBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSNESMFSetReuseBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSNESMFSetReuseBase</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSNESMFSetReuseBase(petsclib::PetscLibType,J::PetscMat, use::PetscBool)</code></pre><p>Causes the base vector to be used for differencing even if the function provided to <code>SNESSetFunction()</code> is not the same as that provided to <code>MatMFFDSetFunction()</code>.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>J</code>   - the <code>MATMFFD</code> matrix</li><li><code>use</code> - if true always reuse the base vector instead of recomputing f(u) even if the function in the <code>MATMFFD</code> is</li></ul><p>not <code>SNESComputeFunction()</code></p><p>Level: advanced</p><p>-seealso: <a href="ch_snes"></a>, <code>SNES</code>, <code>MATMFFD</code>, <code>MatMFFDSetFunction()</code>, <code>SNESSetFunction()</code>, <code>MatCreateSNESMF()</code>, <code>MatSNESMFGetReuseBase()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatSNESMFSetReuseBase.html"><code>Snes/MatSNESMFSetReuseBase</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22785-L22803">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSOR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Float64, PETSc.LibPETSc.MatSORType, Float64, Int64, Int64, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSOR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, Float64, PETSc.LibPETSc.MatSORType, Float64, Int64, Int64, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatSOR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSOR(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, omega::PetscReal, flag::MatSORType, shift::PetscReal, its::PetscInt, lits::PetscInt, x::PetscVec)</code></pre><p>Computes relaxation (SOR, Gauss</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>b</code>     - the right-hand side</li><li><code>omega</code> - the relaxation factor</li><li><code>flag</code>  - flag indicating the type of SOR (see below)</li><li><code>shift</code> - diagonal shift</li><li><code>its</code>   - the number of iterations</li><li><code>lits</code>  - the number of local iterations</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the solution (can contain an initial guess, use option <code>SOR_ZERO_INITIAL_GUESS</code> to indicate no guess)</li></ul><p>SOR Flags:</p><ul><li><code>SOR_FORWARD_SWEEP</code>     - forward SOR</li><li><code>SOR_BACKWARD_SWEEP</code>     - backward SOR</li><li><code>SOR_SYMMETRIC_SWEEP</code>     - SSOR (symmetric SOR)</li><li><code>SOR_LOCAL_FORWARD_SWEEP</code>     - local forward SOR</li><li><code>SOR_LOCAL_BACKWARD_SWEEP</code>     - local forward SOR</li><li><code>SOR_LOCAL_SYMMETRIC_SWEEP</code>     - local SSOR</li><li><code>SOR_EISENSTAT</code>     - SOR with Eisenstat trick</li><li><code>SOR_APPLY_UPPER</code>, <code>SOR_APPLY_LOWER</code>     - applies</li></ul><p>upper/lower triangular part of matrix to vector (with omega)</p><ul><li><code>SOR_ZERO_INITIAL_GUESS</code>     - zero initial guess</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>KSP</code>, <code>PC</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSOR.html"><code>Mat/MatSOR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3493-L3530">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetColPerm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetColPerm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetColPerm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cperm::PetscBool = MatSTRUMPACKGetColPerm(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get whether STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> will try to permute the columns of the matrix in order to get a nonzero diagonal</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code></li></ul><p>Output Parameter:</p><ul><li><code>cperm</code> - Indicates whether STRUMPACK will permute columns</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>MatSTRUMPACKSetReordering()</code>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetColPerm.html"><code>Mat/MatSTRUMPACKGetColPerm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16405-L16424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompAbsTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompAbsTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompAbsTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">atol::PetscReal = MatSTRUMPACKGetCompAbsTol(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> absolute tolerance for compression</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code></li></ul><p>Output Parameter:</p><ul><li><code>atol</code> - absolute compression tolerance</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompAbsTol()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompAbsTol.html"><code>Mat/MatSTRUMPACKGetCompAbsTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16686-L16704">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompButterflyLevels-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompButterflyLevels-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompButterflyLevels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bfly_lvls::PetscInt = MatSTRUMPACKGetCompButterflyLevels(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> number of butterfly levels in HODLR compression (requires ButterflyPACK support)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>bfly_lvls</code> - Number of levels of butterfly compression in HODLR compression</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompButterflyLevels()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompButterflyLevels.html"><code>Mat/MatSTRUMPACKGetCompButterflyLevels</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17077-L17096">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompLeafSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompLeafSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompLeafSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leaf_size::PetscInt = MatSTRUMPACKGetCompLeafSize(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> leaf size for HSS, BLR, HODLR...</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>leaf_size</code> - Size of diagonal blocks in rank-structured approximation</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompLeafSize()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompLeafSize.html"><code>Mat/MatSTRUMPACKGetCompLeafSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16757-L16775">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompLossyPrecision-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompLossyPrecision-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompLossyPrecision</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lossy_prec::PetscInt = MatSTRUMPACKGetCompLossyPrecision(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> precision for lossy compression (requires ZFP support)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>lossy_prec</code> - Number of bitplanes to use in lossy compression</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompLossyPrecision()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompLossyPrecision.html"><code>Mat/MatSTRUMPACKGetCompLossyPrecision</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17004-L17022">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompMinSepSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompMinSepSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompMinSepSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">min_sep_size::PetscInt = MatSTRUMPACKGetCompMinSepSize(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> minimum separator size for low</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>min_sep_size</code> - minimum dense matrix size for low-rank approximation</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompMinSepSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompMinSepSize.html"><code>Mat/MatSTRUMPACKGetCompMinSepSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16933-L16951">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompRelTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompRelTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompRelTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rtol::PetscReal = MatSTRUMPACKGetCompRelTol(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> relative tolerance for compression</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code></li></ul><p>Output Parameter:</p><ul><li><code>rtol</code> - relative compression tolerance</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetCompRelTol()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompRelTol.html"><code>Mat/MatSTRUMPACKGetCompRelTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16615-L16633">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetCompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKCompressionType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetCompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKCompressionType}"><code>PETSc.LibPETSc.MatSTRUMPACKGetCompression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKGetCompression(petsclib::PetscLibType,F::PetscMat, comp::MatSTRUMPACKCompressionType)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> compression type</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>comp</code> - Type of compression to be used in the approximate sparse factorization</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKCompressionType</code>, <code>MatSTRUMPACKSetCompression()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetCompression.html"><code>Mat/MatSTRUMPACKGetCompression</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16548-L16564">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetGPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetGPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSTRUMPACKGetGPU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gpu::PetscBool = MatSTRUMPACKGetGPU(petsclib::PetscLibType,F::PetscMat)</code></pre><p>Get whether STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> will try to use GPU acceleration (not supported for all compression types)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>gpu</code> - whether or not STRUMPACK will try to use GPU acceleration</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetGPU()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetGPU.html"><code>Mat/MatSTRUMPACKGetGPU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16478-L16497">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKGetReordering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKReordering}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKGetReordering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKReordering}"><code>PETSc.LibPETSc.MatSTRUMPACKGetReordering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKGetReordering(petsclib::PetscLibType,F::PetscMat, reordering::MatSTRUMPACKReordering)</code></pre><p>Get STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> fill</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li></ul><p>Output Parameter:</p><ul><li><code>reordering</code> - the code to be used to find the fill-reducing reordering</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSTRUMPACKReordering</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKGetReordering.html"><code>Mat/MatSTRUMPACKGetReordering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16335-L16353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetColPerm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetColPerm-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSTRUMPACKSetColPerm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetColPerm(petsclib::PetscLibType,F::PetscMat, cperm::PetscBool)</code></pre><p>Set whether STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> should try to permute the columns of the matrix in order to get a nonzero diagonal</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>     - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>cperm</code> - <code>PETSC_TRUE</code> to permute (internally) the columns of the matrix</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_colperm &lt;cperm&gt;</code> - true to use the permutation</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>MatSTRUMPACKSetReordering()</code>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetColPerm.html"><code>Mat/MatSTRUMPACKSetColPerm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16369-L16389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompAbsTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompAbsTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompAbsTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompAbsTol(petsclib::PetscLibType,F::PetscMat, atol::PetscReal)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> absolute tolerance for compression</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>    - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>atol</code> - absolute compression tolerance</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_abs_tol &lt;1e-10&gt;</code> - Absolute compression tolerance, when using <code>-pctype ilu</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompAbsTol()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompAbsTol.html"><code>Mat/MatSTRUMPACKSetCompAbsTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16651-L16670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompButterflyLevels-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompButterflyLevels-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompButterflyLevels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompButterflyLevels(petsclib::PetscLibType,F::PetscMat, bfly_lvls::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> number of butterfly levels in HODLR compression (requires ButterflyPACK support)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>         - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>bfly_lvls</code> - Number of levels of butterfly compression in HODLR compression</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_butterfly_levels &lt;bfly_lvls&gt;</code> - Number of levels in the hierarchically off-diagonal matrix for which to use butterfly,</li></ul><p>when using <code>-pctype ilu</code>, (BLR_)HODLR compression</p><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompButterflyLevels()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompButterflyLevels.html"><code>Mat/MatSTRUMPACKSetCompButterflyLevels</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17040-L17061">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompLeafSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompLeafSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompLeafSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompLeafSize(petsclib::PetscLibType,F::PetscMat, leaf_size::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> leaf size for HSS, BLR, HODLR...</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>         - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>leaf_size</code> - Size of diagonal blocks in rank-structured approximation</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_leaf_size</code> - Size of diagonal blocks in rank-structured approximation, when using <code>-pctype ilu</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompLeafSize()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompLeafSize.html"><code>Mat/MatSTRUMPACKSetCompLeafSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16722-L16741">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompLossyPrecision-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompLossyPrecision-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompLossyPrecision</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompLossyPrecision(petsclib::PetscLibType,F::PetscMat, lossy_prec::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> precision for lossy compression (requires ZFP support)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>          - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>lossy_prec</code> - Number of bitplanes to use in lossy compression</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_lossy_precision &lt;lossy_prec&gt;</code> - Precision when using lossy compression [1-64], when using <code>-pctype ilu -mat_strumpack_compression MAT_STRUMPACK_COMPRESSION_TYPE_LOSSY</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompLossyPrecision()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompLossyPrecision.html"><code>Mat/MatSTRUMPACKSetCompLossyPrecision</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16969-L16988">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompMinSepSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompMinSepSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompMinSepSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompMinSepSize(petsclib::PetscLibType,F::PetscMat, min_sep_size::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> minimum separator size for low</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>            - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>min_sep_size</code> - minimum dense matrix size for low-rank approximation</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_min_sep_size &lt;min_sep_size&gt;</code> - Minimum size of dense sub-block for low-rank compression</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompMinSepSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompMinSepSize.html"><code>Mat/MatSTRUMPACKSetCompMinSepSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16898-L16917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompRelTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompRelTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompRelTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompRelTol(petsclib::PetscLibType,F::PetscMat, rtol::PetscReal)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> relative tolerance for compression</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>    - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>rtol</code> - relative compression tolerance</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression_rel_tol &lt;1e-4&gt;</code> - Relative compression tolerance, when using <code>-pctype ilu</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetCompRelTol()</code>, <code>MatSTRUMPACKSetReordering()</code>, <code>MatSTRUMPACKSetColPerm()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompRelTol.html"><code>Mat/MatSTRUMPACKSetCompRelTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16580-L16599">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetCompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKCompressionType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetCompression-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKCompressionType}"><code>PETSc.LibPETSc.MatSTRUMPACKSetCompression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetCompression(petsclib::PetscLibType,F::PetscMat, comp::MatSTRUMPACKCompressionType)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> compression type</p><p>Input Parameters:</p><ul><li><code>F</code>    - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>comp</code> - Type of compression to be used in the approximate sparse factorization</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_compression &lt;NONE&gt;</code> - Type of rank-structured compression in sparse LU factors (choose one of) NONE HSS BLR HODLR BLR<em>HODLR ZFP</em>BLR_HODLR LOSSLESS LOSSY</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKCompressionType</code>, <code>MatSTRUMPACKGetCompression()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetCompression.html"><code>Mat/MatSTRUMPACKSetCompression</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16515-L16532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetGPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetGPU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSTRUMPACKSetGPU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetGPU(petsclib::PetscLibType,F::PetscMat, gpu::PetscBool)</code></pre><p>Set whether STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> should enable GPU acceleration (not supported for all compression types)</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>   - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>gpu</code> - whether or not to use GPU acceleration</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_gpu &lt;gpu&gt;</code> - true to use gpu offload</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKGetGPU()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetGPU.html"><code>Mat/MatSTRUMPACKSetGPU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16442-L16462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetGeometricComponents-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetGeometricComponents-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetGeometricComponents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetGeometricComponents(petsclib::PetscLibType,F::PetscMat, nc::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> number of degrees of freedom per mesh point, for use with GEOMETRIC ordering.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>  - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>nc</code> - Number of components/dof&#39;s per grid point</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_geometric_components &lt;1&gt;</code> - Number of components per mesh point, for geometric nested dissection ordering</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetGeometricComponents.html"><code>Mat/MatSTRUMPACKSetGeometricComponents</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16827-L16847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetGeometricNxyz-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetGeometricNxyz-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetGeometricNxyz</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetGeometricNxyz(petsclib::PetscLibType,F::PetscMat, nx::PetscInt, ny::PetscInt, nz::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> mesh x, y and z dimensions, for use with GEOMETRIC ordering.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>  - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>nx</code> - x dimension of the mesh</li><li><code>ny</code> - y dimension of the mesh</li><li><code>nz</code> - z dimension of the mesh</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetGeometricNxyz.html"><code>Mat/MatSTRUMPACKSetGeometricNxyz</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16793-L16811">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetGeometricWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetGeometricWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSTRUMPACKSetGeometricWidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetGeometricWidth(petsclib::PetscLibType,F::PetscMat, w::PetscInt)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> width of the separator, for use with GEOMETRIC ordering.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code> - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>w</code> - width of the separator</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_geometric_width &lt;1&gt;</code> - Width of the separator of the mesh, for geometric nested dissection ordering</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetGeometricWidth.html"><code>Mat/MatSTRUMPACKSetGeometricWidth</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16863-L16882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSTRUMPACKSetReordering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKReordering}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSTRUMPACKSetReordering-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSTRUMPACKReordering}"><code>PETSc.LibPETSc.MatSTRUMPACKSetReordering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSTRUMPACKSetReordering(petsclib::PetscLibType,F::PetscMat, reordering::MatSTRUMPACKReordering)</code></pre><p>Set STRUMPACK <a href="https://portal.nersc.gov/project/sparse/strumpack/master">https://portal.nersc.gov/project/sparse/strumpack/master</a> fill</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>          - the factored matrix obtained by calling <code>MatGetFactor()</code> from PETSc-STRUMPACK interface</li><li><code>reordering</code> - the code to be used to find the fill-reducing reordering</li></ul><p>Options Database Key:</p><ul><li><code>-mat_strumpack_reordering &lt;METIS&gt;</code> - Sparsity reducing matrix reordering, see <code>MatSTRUMPACKReordering</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSOLVERSTRUMPACK</code>, <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSTRUMPACKReordering</code>, <code>MatGetFactor()</code>, <code>MatSTRUMPACKSetColPerm()</code>, <code>MatSTRUMPACKGetReordering()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSTRUMPACKSetReordering.html"><code>Mat/MatSTRUMPACKSetReordering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L16300-L16319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatScaLAPACKGetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatScaLAPACKGetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatScaLAPACKGetBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mb::PetscInt,nb::PetscInt = MatScaLAPACKGetBlockSizes(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Gets the block sizes used in the distribution of the <code>MATSCALAPACK</code> matrix</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSCALAPACK</code> matrix</li></ul><p>Output Parameters:</p><ul><li><code>mb</code> - the row block size</li><li><code>nb</code> - the column block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSCALAPACK</code>, <code>MatCreateScaLAPACK()</code>, <code>MatScaLAPACKSetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatScaLAPACKGetBlockSizes.html"><code>Mat/MatScaLAPACKGetBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8868-L8888">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatScaLAPACKSetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatScaLAPACKSetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatScaLAPACKSetBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatScaLAPACKSetBlockSizes(petsclib::PetscLibType,A::PetscMat, mb::PetscInt, nb::PetscInt)</code></pre><p>Sets the block sizes to be used for the distribution of the <code>MATSCALAPACK</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>  - a <code>MATSCALAPACK</code> matrix</li><li><code>mb</code> - the row block size</li><li><code>nb</code> - the column block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSCALAPACK</code>, <code>MatCreateScaLAPACK()</code>, <code>MatScaLAPACKGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatScaLAPACKSetBlockSizes.html"><code>Mat/MatScaLAPACKSetBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8834-L8852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatScale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatScale-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatScale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatScale(petsclib::PetscLibType,mat::PetscMat, a::PetscScalar)</code></pre><p>Scales all elements of a matrix by a given number.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix to be scaled</li><li><code>a</code>   - the scaling value</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDiagonalScale()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatScale.html"><code>Mat/MatScale</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4472-L4488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatScatterGetVecScatter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_PetscSF}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatScatterGetVecScatter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_PetscSF}}"><code>PETSc.LibPETSc.MatScatterGetVecScatter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatScatterGetVecScatter(petsclib::PetscLibType,mat::PetscMat, scatter::VecScatter)</code></pre><p>Returns the user</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix, should have been created with MatCreateScatter() or have type <code>MATSCATTER</code></li></ul><p>Output Parameter:</p><ul><li><code>scatter</code> - the scatter context</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSCATTER</code>, <code>MatCreateScatter()</code>, <code>MatScatterSetVecScatter()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatScatterGetVecScatter.html"><code>Mat/MatScatterGetVecScatter</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14185-L14203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatScatterSetVecScatter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_PetscSF}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatScatterSetVecScatter-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_PetscSF}}"><code>PETSc.LibPETSc.MatScatterSetVecScatter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatScatterSetVecScatter(petsclib::PetscLibType,mat::PetscMat, scatter::VecScatter)</code></pre><p>sets the scatter that the matrix is to apply as its linear operator in a <code>MATSCATTER</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the <code>MATSCATTER</code> matrix</li><li><code>scatter</code> - the scatter context create with <code>VecScatterCreate()</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSCATTER</code>, <code>MatCreateScatter()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatScatterSetVecScatter.html"><code>Mat/MatScatterSetVecScatter</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L14256-L14272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementComputeExplicitOperator-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementComputeExplicitOperator-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSchurComplementComputeExplicitOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementComputeExplicitOperator(petsclib::PetscLibType,A::PetscMat, S::PetscMat)</code></pre><p>Compute the Schur complement matrix explicitly</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix obtained with <code>MatCreateSchurComplement()</code></li></ul><p>Output Parameter:</p><ul><li><code>S</code> - the Schur complement matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateSchurComplement()</code>, <code>MatSchurComplementUpdateSubMatrices()</code>, <code>MatSchurComplementGetPmat()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementComputeExplicitOperator.html"><code>Ksp/MatSchurComplementComputeExplicitOperator</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22430-L22448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementGetAinvType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementGetAinvType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSchurComplementGetAinvType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ainvtype::MatSchurComplementAinvType = MatSchurComplementGetAinvType(petsclib::PetscLibType,S::PetscMat)</code></pre><p>get the type of approximation for the inverse of the (0,0) block used in forming <code>Sp</code> in <code>MatSchurComplementGetPmat()</code></p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>S</code> - matrix obtained with <code>MatCreateSchurComplement()</code> (or equivalent) and implementing the action of A11 - A10 ksp(A00,Ap00) A01</li></ul><p>Output Parameter:</p><ul><li><code>ainvtype</code> - type of approximation used to form approximate Schur complement Sp = A11 - A10 inv(DIAGFORM(A00)) A01:</li></ul><p><code>MAT_SCHUR_COMPLEMENT_AINV_DIAG</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_LUMP</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_BLOCK_DIAG</code>, or <code>MAT_SCHUR_COMPLEMENT_AINV_FULL</code></p><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatSchurComplementAinvType</code>, <code>MatCreateSchurComplement()</code>, <code>MatGetSchurComplement()</code>, <code>MatSchurComplementGetPmat()</code>, <code>MatSchurComplementSetAinvType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementGetAinvType.html"><code>Ksp/MatSchurComplementGetAinvType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22549-L22568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementGetKSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementGetKSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><code>PETSc.LibPETSc.MatSchurComplementGetKSP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementGetKSP(petsclib::PetscLibType,S::PetscMat, ksp::PetscKSP)</code></pre><p>Gets the <code>KSP</code> object that is used to solve with <code>A00</code> in the Schur complement matrix S = A11</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>S</code> - matrix obtained with <code>MatCreateSchurComplement()</code> (or equivalent) and implementing the action of  A11 - A10 ksp(A00,Ap00) A01 </li></ul><p>Output Parameter:</p><ul><li><code>ksp</code> - the linear solver object</li></ul><p>Options Database Key:</p><ul><li><code>-fieldsplit_&lt;splitname_0&gt;_XXX</code> - sets <code>KSP</code> and <code>PC</code> options for the 0-split solver inside the Schur complement used in <code>PCFIELDSPLIT</code>; default &lt;splitname_0&gt; is 0.</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>Mat</code>, <code>MatSchurComplementSetKSP()</code>, <code>MatCreateSchurComplement()</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementGetKSP.html"><code>Ksp/MatSchurComplementGetKSP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22275-L22296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementGetPmat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementGetPmat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSchurComplementGetPmat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementGetPmat(petsclib::PetscLibType,S::PetscMat, preuse::MatReuse, Sp::PetscMat)</code></pre><p>Obtain a matrix for preconditioning the Schur complement by assembling Sp = A11</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>S</code>      - matrix obtained with MatCreateSchurComplement() (or equivalent) that implements the action of A11 - A10 ksp(A00,Ap00) A01</li><li><code>preuse</code> - <code>MAT_INITIAL_MATRIX</code> for a new <code>Sp</code>, or <code>MAT_REUSE_MATRIX</code> to reuse an existing <code>Sp</code>, or <code>MAT_IGNORE_MATRIX</code> to put nothing in <code>Sp</code></li></ul><p>Output Parameter:</p><ul><li><code>Sp</code> - approximate Schur complement suitable for preconditioning the exact Schur complement S = A11 - A10 inv(A00) A01</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateSubMatrix()</code>, <code>PCFIELDSPLIT</code>, <code>MatGetSchurComplement()</code>, <code>MatCreateSchurComplement()</code>, <code>MatSchurComplementSetAinvType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementGetPmat.html"><code>Ksp/MatSchurComplementGetPmat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22628-L22647">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementGetSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementGetSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><code>PETSc.LibPETSc.MatSchurComplementGetSubMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementGetSubMatrices(petsclib::PetscLibType,S::PetscMat, A00::PetscMat, Ap00::PetscMat, A01::PetscMat, A10::PetscMat, A11::PetscMat)</code></pre><p>Get the individual submatrices in the Schur complement</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>S</code> - matrix obtained with <code>MatCreateSchurComplement()</code> (or equivalent) and implementing the action of A11 - A10 ksp(A00,Ap00) A01</li></ul><p>Output Parameters:</p><ul><li><code>A00</code>  - the upper-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>Ap00</code> - matrix from which the preconditioner is constructed for use in ksp(A00,Ap00) to approximate the action of A^{-1}</li><li><code>A01</code>  - the upper-right block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A10</code>  - the lower-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A11</code>  - (optional) the lower-right block of the original matrix A = [A00 A01; A10 A11]</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MatSchurComplementGetKSP()</code>, <code>MatCreateSchurComplement()</code>, <code>MatSchurComplementUpdateSubMatrices()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementGetSubMatrices.html"><code>Ksp/MatSchurComplementGetSubMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22382-L22404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementSetAinvType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementSetAinvType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatSchurComplementAinvType}"><code>PETSc.LibPETSc.MatSchurComplementSetAinvType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementSetAinvType(petsclib::PetscLibType,S::PetscMat, ainvtype::MatSchurComplementAinvType)</code></pre><p>set the type of approximation used for the inverse of the (0,0) block used in forming <code>Sp</code> in <code>MatSchurComplementGetPmat()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>S</code>        - matrix obtained with <code>MatCreateSchurComplement()</code> (or equivalent) and implementing the action of A11 - A10 ksp(A00,Ap00) A01</li><li><code>ainvtype</code> - type of approximation to be used to form approximate Schur complement Sp = A11 - A10 inv(DIAGFORM(A00)) A01:</li></ul><p><code>MAT_SCHUR_COMPLEMENT_AINV_DIAG</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_LUMP</code>, <code>MAT_SCHUR_COMPLEMENT_AINV_BLOCK_DIAG</code>, or <code>MAT_SCHUR_COMPLEMENT_AINV_FULL</code></p><p>Options Database Key:</p><ul><li><code>-mat_schur_complement_ainv_type diag | lump | blockdiag | full</code> - set schur complement type</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_ksp"></a>, <code>MatSchurComplementAinvType</code>, <code>MatCreateSchurComplement()</code>, <code>MatGetSchurComplement()</code>, <code>MatSchurComplementGetPmat()</code>, <code>MatSchurComplementGetAinvType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementSetAinvType.html"><code>Ksp/MatSchurComplementSetAinvType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22513-L22533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementSetKSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementSetKSP-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscKSP}"><code>PETSc.LibPETSc.MatSchurComplementSetKSP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementSetKSP(petsclib::PetscLibType,S::PetscMat, ksp::PetscKSP)</code></pre><p>Sets the <code>KSP</code> object that is used to solve with <code>A00</code> in the Schur complement matrix  S = A11</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>S</code>   - matrix created with <code>MatCreateSchurComplement()</code></li><li><code>ksp</code> - the linear solver object</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_ksp"></a>, <code>Mat</code>, <code>MatSchurComplementGetKSP()</code>, <code>MatCreateSchurComplement()</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MATSCHURCOMPLEMENT</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementSetKSP.html"><code>Ksp/MatSchurComplementSetKSP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22314-L22330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementSetSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementSetSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><code>PETSc.LibPETSc.MatSchurComplementSetSubMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementSetSubMatrices(petsclib::PetscLibType,S::PetscMat, A00::PetscMat, Ap00::PetscMat, A01::PetscMat, A10::PetscMat, A11::PetscMat)</code></pre><p>Sets the matrices that define the Schur complement</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>S</code>    - matrix obtained with <code>MatSetType</code>(S,<code>MATSCHURCOMPLEMENT</code>)</li><li><code>A00</code>  - the upper-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>Ap00</code> - matrix from which the preconditioner is constructed for use in ksp(A00,Ap00) to approximate the action of A00^{-1}</li><li><code>A01</code>  - the upper-right block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A10</code>  - the lower-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A11</code>  - (optional) the lower-right block of the original matrix A = [A00 A01; A10 A11]</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>Mat</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MatSchurComplementGetKSP()</code>, <code>MatSchurComplementUpdateSubMatrices()</code>, <code>MatCreateTranspose()</code>, <code>MatCreateSchurComplement()</code>, <code>MatGetSchurComplement()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementSetSubMatrices.html"><code>Ksp/MatSchurComplementSetSubMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22239-L22259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSchurComplementUpdateSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSchurComplementUpdateSubMatrices-Tuple{PETSc.LibPETSc.PetscLibType, Vararg{PETSc.LibPETSc.PetscMat, 6}}"><code>PETSc.LibPETSc.MatSchurComplementUpdateSubMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSchurComplementUpdateSubMatrices(petsclib::PetscLibType,S::PetscMat, A00::PetscMat, Ap00::PetscMat, A01::PetscMat, A10::PetscMat, A11::PetscMat)</code></pre><p>Updates the Schur complement matrix object with new submatrices</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>S</code>    - matrix obtained with <code>MatCreateSchurComplement()</code> (or <code>MatSchurSetSubMatrices()</code>) and implementing the action of A11 - A10 ksp(A00,Ap00) A01</li><li><code>A00</code>  - the upper-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>Ap00</code> - matrix from which the preconditioner is constructed for use in ksp(A00,Ap00) to approximate the action of A00^{-1}</li><li><code>A01</code>  - the upper-right block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A10</code>  - the lower-left block of the original matrix A = [A00 A01; A10 A11]</li><li><code>A11</code>  - (optional) the lower-right block of the original matrix A = [A00 A01; A10 A11]</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_ksp"></a>, <code>Mat</code>, <code>MatCreateNormal()</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MatSchurComplementGetKSP()</code>, <code>MatCreateSchurComplement()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Ksp/MatSchurComplementUpdateSubMatrices.html"><code>Ksp/MatSchurComplementUpdateSubMatrices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22346-L22366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSelectVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSelectVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatSelectVariableBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSelectVariableBlockSizes(petsclib::PetscLibType,subA::PetscMat, A::PetscMat, isrow::IS)</code></pre><p>When creating a submatrix, pass on the variable block sizes</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>subA</code>  - the submatrix</li><li><code>A</code>     - the original matrix</li><li><code>isrow</code> - The <code>IS</code> of selected rows for the submatrix, must be sorted</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetVariableBlockSizes()</code>, <code>MatComputeVariableBlockEnvelope()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSelectVariableBlockSizes.html"><code>Mat/MatSelectVariableBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6061-L6078">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJGetArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJGetArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read/write access to the array where the data for a <code>MATSEQAIJ</code> matrix is stored</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJGetArray.html"><code>Mat/MatSeqAIJGetArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18030-L18048">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJGetArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJGetArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJGetArrayRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJGetArrayRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJGetArrayRead.html"><code>Mat/MatSeqAIJGetArrayRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18100-L18118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJGetArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJGetArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJGetArrayWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJGetArrayWrite(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives write</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJGetArrayWrite.html"><code>Mat/MatSeqAIJGetArrayWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18172-L18190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJGetCSRAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJGetCSRAndMemType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJGetCSRAndMemType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">i::Vector{PetscInt},j::Vector{PetscInt},a::Vector{PetscScalar},mtype::PetscMemType = MatSeqAIJGetCSRAndMemType(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Get the CSR arrays and the memory type of the <code>MATSEQAIJ</code> matrix</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>mat</code> - a matrix of type <code>MATSEQAIJ</code> or its subclasses</li></ul><p>Output Parameters:</p><ul><li><code>i</code>     - row map array of the matrix</li><li><code>j</code>     - column index array of the matrix</li><li><code>a</code>     - data array of the matrix</li><li><code>mtype</code> - memory type of the arrays</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJGetArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJGetCSRAndMemType.html"><code>Mat/MatSeqAIJGetCSRAndMemType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18244-L18265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJGetMaxRowNonzeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJGetMaxRowNonzeros-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJGetMaxRowNonzeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nz::PetscInt = MatSeqAIJGetMaxRowNonzeros(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns the maximum number of nonzeros in any row</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>nz</code> - the maximum number of nonzeros in any row</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJGetMaxRowNonzeros.html"><code>Mat/MatSeqAIJGetMaxRowNonzeros</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18289-L18307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJKron-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJKron-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJKron</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJKron(petsclib::PetscLibType,A::PetscMat, B::PetscMat, reuse::MatReuse, C::PetscMat)</code></pre><p>Computes <code>C</code>, the Kronecker product of <code>A</code> and <code>B</code>.</p><p>Input Parameters:</p><ul><li><code>A</code>     - left-hand side matrix</li><li><code>B</code>     - right-hand side matrix</li><li><code>reuse</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>C</code> - Kronecker product of <code>A</code> and <code>B</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqAIJ()</code>, <code>MATSEQAIJ</code>, <code>MATKAIJ</code>, <code>MatReuse</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJKron.html"><code>Mat/MatSeqAIJKron</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17994-L18012">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJRegister-Tuple{PETSc.LibPETSc.PetscLibType, Vector{Int8}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatSeqAIJRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJRegister(petsclib::PetscLibType,sname::Vector{Cchar}, fnc::external)</code></pre><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of a new user-defined matrix type, for example <code>MATSEQAIJCRL</code></li><li><code>function</code> - routine to convert to subtype</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJRegister.html"><code>Mat/MatSeqAIJRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18448-L18464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJRestoreArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJRestoreArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the data for a <code>MATSEQAIJ</code> matrix is stored obtained by <code>MatSeqAIJGetArray()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a <code>MATSEQAIJ</code> matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJRestoreArray.html"><code>Mat/MatSeqAIJRestoreArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18066-L18082">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJRestoreArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJRestoreArrayRead-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJRestoreArrayRead</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJRestoreArrayRead(petsclib::PetscLibType,A::PetscMat)</code></pre><p>restore the read</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJGetArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJRestoreArrayRead.html"><code>Mat/MatSeqAIJRestoreArrayRead</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18136-L18154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJRestoreArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJRestoreArrayWrite-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJRestoreArrayWrite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqAIJRestoreArrayWrite(petsclib::PetscLibType,A::PetscMat)</code></pre><p>restore the read</p><p>Not Collective; No Fortran Support</p><p>Input Parameter:</p><ul><li><code>A</code> - a MATSEQAIJ matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJGetArrayRead()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJRestoreArrayWrite.html"><code>Mat/MatSeqAIJRestoreArrayWrite</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18208-L18226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqAIJSetColumnIndices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices::PetscInt = MatSeqAIJSetColumnIndices(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Set the column indices for all the rows in the matrix.</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the <code>MATSEQAIJ</code> matrix</li><li><code>indices</code> - the column indices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetColumnIndices.html"><code>Mat/MatSeqAIJSetColumnIndices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17776-L17791">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatSeqAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter nz (or the array nnz).  By setting these parameters accurately, performance during matrix assembly can be increased by more than a factor of 50.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>   - The matrix</li><li><code>nz</code>  - number of nonzeros per row (same for all rows)</li><li><code>nnz</code> - array containing the number of nonzeros in the various rows</li></ul><p>(possibly different for each row) or NULL</p><p>Options Database Keys:</p><ul><li><code>-mat_no_inode</code>            - Do not use inodes</li><li><code>-mat_inode_limit &lt;limit&gt;</code> - Sets inode limit (max limit=5)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateAIJ()</code>, <code>MatSetValues()</code>, <code>MatSeqAIJSetColumnIndices()</code>, <code>MatCreateSeqAIJWithArrays()</code>, <code>MatGetInfo()</code>, <code>MatSeqAIJSetTotalPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetPreallocation.html"><code>Mat/MatSeqAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17920-L17946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatSeqAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Allocates memory for a sparse sequential matrix in <code>MATSEQAIJ</code> format.</p><p>Input Parameters:</p><ul><li><code>B</code> - the matrix</li><li><code>i</code> - the indices into <code>j</code> for the start of each row (indices start with zero)</li><li><code>j</code> - the column indices for each row (indices start with zero) these must be sorted for each row</li><li><code>v</code> - optional values in the matrix, use <code>NULL</code> if not provided</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatSeqAIJSetPreallocation()</code>, <code>MATSEQAIJ</code>, <code>MatResetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetPreallocationCSR.html"><code>Mat/MatSeqAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17962-L17978">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetTotalPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetTotalPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSeqAIJSetTotalPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJSetTotalPreallocation(petsclib::PetscLibType,A::PetscMat, nztotal::PetscInt)</code></pre><p>Sets an upper bound on the total number of expected nonzeros in the matrix.</p><p>Input Parameters:</p><ul><li><code>A</code>       - the <code>MATSEQAIJ</code> matrix</li><li><code>nztotal</code> - bound on the number of nonzeros</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MAT_SORTED_FULL</code>, <code>MatSetValues()</code>, <code>MatSeqAIJSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetTotalPreallocation.html"><code>Mat/MatSeqAIJSetTotalPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17746-L17760">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatSeqAIJSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJSetType(petsclib::PetscLibType,mat::PetscMat, matype::MatType)</code></pre><p>Converts a <code>MATSEQAIJ</code> matrix to a subtype</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix object</li><li><code>matype</code> - matrix type</li></ul><p>Options Database Key:</p><ul><li><code>-mat_seqaij_type  &lt;method&gt;</code> - for example seqaijcrl</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCSetType()</code>, <code>VecSetType()</code>, <code>MatCreate()</code>, <code>MatType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetType.html"><code>Mat/MatSeqAIJSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18413-L18432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqAIJSetValuesLocalFast-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqAIJSetValuesLocalFast-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSeqAIJSetValuesLocalFast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqAIJSetValuesLocalFast(petsclib::PetscLibType,A::PetscMat, m::PetscInt, im::Vector{PetscInt}, n::PetscInt, in::Vector{PetscInt}, v::Vector{PetscScalar}, is::InsertMode)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqAIJSetValuesLocalFast.html"><code>Mat/MatSeqAIJSetValuesLocalFast</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17725-L17730">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqBAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqBAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqBAIJGetArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqBAIJGetArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives read/write access to the array where the data for a <code>MATSEQBAIJ</code> matrix is stored</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQBAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQBAIJ</code>, <code>MatSeqBAIJRestoreArray()</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqBAIJGetArray.html"><code>Mat/MatSeqBAIJGetArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9820-L9838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqBAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqBAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqBAIJRestoreArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqBAIJRestoreArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the data for a <code>MATSEQBAIJ</code> matrix is stored obtained by <code>MatSeqBAIJGetArray()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a <code>MATSEQBAIJ</code> matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqBAIJGetArray()</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqBAIJRestoreArray.html"><code>Mat/MatSeqBAIJRestoreArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9856-L9872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqBAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqBAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqBAIJSetColumnIndices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices::PetscInt = MatSeqBAIJSetColumnIndices(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Set the column indices for all the block rows in the matrix.</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the <code>MATSEQBAIJ</code> matrix</li><li><code>indices</code> - the block column indices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQBAIJ</code>, <code>MatSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqBAIJSetColumnIndices.html"><code>Mat/MatSeqBAIJSetColumnIndices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9788-L9802">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Int64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Union{Ptr, Vector{Int64}}}"><code>PETSc.LibPETSc.MatSeqBAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqBAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Sets the block size and expected nonzeros per row in the matrix. For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>   - the matrix</li><li><code>bs</code>  - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row</li></ul><p>blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></p><ul><li><code>nz</code>  - number of block nonzeros per block row (same for all rows)</li><li><code>nnz</code> - array containing the number of block nonzeros in the various block rows</li></ul><p>(possibly different for each block row) or <code>NULL</code></p><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrices</a>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetInfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqBAIJSetPreallocation.html"><code>Mat/MatSeqBAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9940-L9967">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Float64}}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Union{Ptr, Vector{Float64}}}"><code>PETSc.LibPETSc.MatSeqBAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqBAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Creates a sparse sequential matrix in <code>MATSEQBAIJ</code> format using the given nonzero structure and (optional) numerical values</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>  - the matrix</li><li><code>bs</code> - the blocksize</li><li><code>i</code>  - the indices into <code>j</code> for the start of each local row (indices start with zero)</li><li><code>j</code>  - the column indices for each local row (indices start with zero) these must be sorted for each row</li><li><code>v</code>  - optional values in the matrix, use <code>NULL</code> if not provided</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatSetValues()</code>, <code>MatSeqBAIJSetPreallocation()</code>, <code>MATSEQBAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqBAIJSetPreallocationCSR.html"><code>Mat/MatSeqBAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9983-L10002">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqDenseInvert-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqDenseInvert-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqDenseInvert</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqDenseInvert(petsclib::PetscLibType,A::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqDenseInvert.html"><code>Mat/MatSeqDenseInvert</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12416-L12421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqDenseSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqDenseSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatSeqDenseSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqDenseSetPreallocation(petsclib::PetscLibType,B::PetscMat, data::Vector{PetscScalar})</code></pre><p>Sets the array used for storing the matrix elements of a <code>MATSEQDENSE</code> matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>    - the matrix</li><li><code>data</code> - the array (or <code>NULL</code>)</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQDENSE</code>, <code>MatCreate()</code>, <code>MatCreateDense()</code>, <code>MatSetValues()</code>, <code>MatDenseSetLDA()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqDenseSetPreallocation.html"><code>Mat/MatSeqDenseSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L12023-L12039">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSBAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSBAIJGetArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSBAIJGetArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqSBAIJGetArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>gives access to the array where the numerical data for a <code>MATSEQSBAIJ</code> matrix is stored</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a <code>MATSEQSBAIJ</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQSBAIJ</code>, <code>MatSeqSBAIJRestoreArray()</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSBAIJGetArray.html"><code>Mat/MatSeqSBAIJGetArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13219-L13237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSBAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSBAIJRestoreArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSBAIJRestoreArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array::Vector{PetscScalar} = MatSeqSBAIJRestoreArray(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns access to the array where the numerical data for a <code>MATSEQSBAIJ</code> matrix is stored obtained by <code>MatSeqSBAIJGetArray()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - a <code>MATSEQSBAIJ</code> matrix</li><li><code>array</code> - pointer to the data</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQSBAIJ</code>, <code>MatSeqSBAIJGetArray()</code>, <code>MatSeqAIJGetArray()</code>, <code>MatSeqAIJRestoreArray()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSBAIJRestoreArray.html"><code>Mat/MatSeqSBAIJRestoreArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13255-L13271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSBAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSBAIJSetColumnIndices-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSBAIJSetColumnIndices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices::PetscInt = MatSeqSBAIJSetColumnIndices(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Set the column indices for all the rows in a <code>MATSEQSBAIJ</code> matrix.</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the <code>MATSEQSBAIJ</code> matrix</li><li><code>indices</code> - the column indices</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQSBAIJ</code>, <code>MatCreateSeqSBAIJ</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSBAIJSetColumnIndices.html"><code>Mat/MatSeqSBAIJSetColumnIndices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13186-L13201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSBAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatSeqSBAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqSBAIJSetPreallocation(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, nz::PetscInt, nnz::Vector{PetscInt})</code></pre><p>Creates a sparse symmetric matrix in block AIJ (block compressed row) <code>MATSEQSBAIJ</code> format.  For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>   - the symmetric matrix</li><li><code>bs</code>  - size of block, the blocks are ALWAYS square. One can use <code>MatSetBlockSizes()</code> to set a different row and column blocksize but the row</li></ul><p>blocksize always defines the size of the blocks. The column blocksize sets the blocksize of the vectors obtained with <code>MatCreateVecs()</code></p><ul><li><code>nz</code>  - number of block nonzeros per block row (same for all rows)</li><li><code>nnz</code> - array containing the number of block nonzeros in the upper triangular plus</li></ul><p>diagonal portion of each block (possibly different for each block row) or <code>NULL</code></p><p>Options Database Keys:</p><ul><li><code>-mat_no_unroll</code>  - uses code that does not unroll the loops in the block calculations (much slower)</li><li><code>-mat_block_size</code> - size of the blocks to use (only works if a negative bs is passed in</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matsparse">Sparse Matrices</a>, <code>MATSEQSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatCreateSBAIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSBAIJSetPreallocation.html"><code>Mat/MatSeqSBAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13289-L13316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSBAIJSetPreallocationCSR-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatSeqSBAIJSetPreallocationCSR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqSBAIJSetPreallocationCSR(petsclib::PetscLibType,B::PetscMat, bs::PetscInt, i::Vector{PetscInt}, j::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Creates a sparse parallel matrix in <code>MATSEQSBAIJ</code> format using the given nonzero structure and (optional) numerical values</p><p>Input Parameters:</p><ul><li><code>B</code>  - the matrix</li><li><code>bs</code> - size of block, the blocks are ALWAYS square.</li><li><code>i</code>  - the indices into <code>j</code> for the start of each local row (indices start with zero)</li><li><code>j</code>  - the column indices for each local row (indices start with zero) these must be sorted for each row</li><li><code>v</code>  - optional values in the matrix, use <code>NULL</code> if not provided</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSEQSBAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSeqSBAIJSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSBAIJSetPreallocationCSR.html"><code>Mat/MatSeqSBAIJSetPreallocationCSR</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L13332-L13349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLGetAvgSliceWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLGetAvgSliceWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSELLGetAvgSliceWidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slicewidth::PetscReal = MatSeqSELLGetAvgSliceWidth(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns the average slice width.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a MATSEQSELL matrix</li></ul><p>Output Parameter:</p><ul><li><code>slicewidth</code> - average slice width</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSEQSELL</code>, <code>MatSeqSELLGetMaxSliceWidth()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLGetAvgSliceWidth.html"><code>Mat/MatSeqSELLGetAvgSliceWidth</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9249-L9267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLGetFillRatio-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLGetFillRatio-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSELLGetFillRatio</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ratio::PetscReal = MatSeqSELLGetFillRatio(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns a ratio that indicates the irregularity of the matrix.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a MATSEQSELL matrix</li></ul><p>Output Parameter:</p><ul><li><code>ratio</code> - ratio of number of padded zeros to number of allocated elements</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSEQSELL</code>, <code>MatSeqSELLGetAvgSliceWidth()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLGetFillRatio.html"><code>Mat/MatSeqSELLGetFillRatio</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9177-L9195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLGetMaxSliceWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLGetMaxSliceWidth-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSELLGetMaxSliceWidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slicewidth::PetscInt = MatSeqSELLGetMaxSliceWidth(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns the maximum slice width.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a MATSEQSELL matrix</li></ul><p>Output Parameter:</p><ul><li><code>slicewidth</code> - maximum slice width</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSEQSELL</code>, <code>MatSeqSELLGetAvgSliceWidth()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLGetMaxSliceWidth.html"><code>Mat/MatSeqSELLGetMaxSliceWidth</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9213-L9231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLGetVarSliceSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLGetVarSliceSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSeqSELLGetVarSliceSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variance::PetscReal = MatSeqSELLGetVarSliceSize(petsclib::PetscLibType,A::PetscMat)</code></pre><p>returns the variance of the slice size.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - a MATSEQSELL matrix</li></ul><p>Output Parameter:</p><ul><li><code>variance</code> - variance of the slice size</li></ul><p>Level: intermediate</p><p>-seealso: <code>MATSEQSELL</code>, <code>MatSeqSELLSetSliceHeight()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLGetVarSliceSize.html"><code>Mat/MatSeqSELLGetVarSliceSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9315-L9333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatSeqSELLSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqSELLSetPreallocation(petsclib::PetscLibType,B::PetscMat, rlenmax::PetscInt, rlen::Vector{PetscInt})</code></pre><p>For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter <code>nz</code> (or the array <code>nnz</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>B</code>       - The <code>MATSEQSELL</code> matrix</li><li><code>rlenmax</code> - number of nonzeros per row (same for all rows), ignored if <code>rlen</code> is provided</li><li><code>rlen</code>    - array containing the number of nonzeros in the various rows (possibly different for each row) or <code>NULL</code></li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MATSEQSELL</code>, <code>MATSELL</code>, <code>MatCreate()</code>, <code>MatCreateSELL()</code>, <code>MatSetValues()</code>, <code>MatGetInfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLSetPreallocation.html"><code>Mat/MatSeqSELLSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9142-L9161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSeqSELLSetSliceHeight-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSeqSELLSetSliceHeight-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSeqSELLSetSliceHeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSeqSELLSetSliceHeight(petsclib::PetscLibType,A::PetscMat, sliceheight::PetscInt)</code></pre><p>sets the slice height.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>           - a MATSEQSELL matrix</li><li><code>sliceheight</code> - slice height</li></ul><p>-seealso: <code>MATSEQSELL</code>, <code>MatSeqSELLGetVarSliceSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSeqSELLSetSliceHeight.html"><code>Mat/MatSeqSELLSetSliceHeight</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L9285-L9299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetBindingPropagates-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetBindingPropagates-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSetBindingPropagates</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetBindingPropagates(petsclib::PetscLibType,A::PetscMat, flg::PetscBool)</code></pre><p>Sets whether the state of being bound to the CPU for a GPU matrix type propagates to child and some other associated objects</p><p>Input Parameters:</p><ul><li><code>A</code>   - the matrix</li><li><code>flg</code> - flag indicating whether the boundtocpu flag should be propagated</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>VecSetBindingPropagates()</code>, <code>MatGetBindingPropagates()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetBindingPropagates.html"><code>Mat/MatSetBindingPropagates</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19666-L19680">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSetBlockSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetBlockSize(petsclib::PetscLibType,mat::PetscMat, bs::PetscInt)</code></pre><p>Sets the matrix block size.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>bs</code>  - block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATBAIJ</code>, <code>MATSBAIJ</code>, <code>MATAIJ</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSizes()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetBlockSize.html"><code>Mat/MatSetBlockSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5887-L5903">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatSetBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetBlockSizes(petsclib::PetscLibType,mat::PetscMat, rbs::PetscInt, cbs::PetscInt)</code></pre><p>Sets the matrix block row and column sizes.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>rbs</code> - row block size</li><li><code>cbs</code> - column block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSize()</code>, <code>MatGetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetBlockSizes.html"><code>Mat/MatSetBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6094-L6111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetBlockSizesFromMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetBlockSizesFromMats-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSetBlockSizesFromMats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetBlockSizesFromMats(petsclib::PetscLibType,mat::PetscMat, fromRow::PetscMat, fromCol::PetscMat)</code></pre><p>Sets the matrix block row and column sizes to match a pair of matrices</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>fromRow</code> - matrix from which to copy row block size</li><li><code>fromCol</code> - matrix from which to copy column block size (can be same as fromRow)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetBlockSizesFromMats.html"><code>Mat/MatSetBlockSizesFromMats</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6127-L6144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscDM}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscDM}"><code>PETSc.LibPETSc.MatSetDM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetDM(petsclib::PetscLibType,A::PetscMat, dm::PetscDM)</code></pre><p>Sets the <code>DM</code> defining the data layout of the matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>A</code>  - The <code>Mat</code></li><li><code>dm</code> - The <code>DM</code></li></ul><p>Level: developer</p><p>Note: This is rarely used in practice, rather <code>DMCreateMatrix()</code> is used to create a matrix associated with a particular <code>DM</code></p><p>Developer Note: Since the <code>Mat</code> class doesn&#39;t know about the <code>DM</code> class the <code>DM</code> object is associated with the <code>Mat</code> through a <code>PetscObjectCompose()</code> operation</p><p><strong>See also:</strong></p><p><code>DM</code>, <code>MatGetDM()</code>, <code>DMCreateMatrix()</code>, <code>DMSetMatType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/DM/MatSetDM.html"><code>DM/MatSetDM</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L22942-L22967">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetErrorIfFailure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetErrorIfFailure-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSetErrorIfFailure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetErrorIfFailure(petsclib::PetscLibType,mat::PetscMat, flg::PetscBool)</code></pre><p>Causes <code>Mat</code> to generate an immediate error, for example a zero pivot, is detected.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - matrix obtained from <code>MatCreate()</code></li><li><code>flg</code> - <code>PETSC_TRUE</code> indicates you want the error generated</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCSetErrorIfFailure()</code>, <code>KSPConvergedReason</code>, <code>SNESConvergedReason</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetErrorIfFailure.html"><code>Mat/MatSetErrorIfFailure</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19276-L19292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetFactorType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetFactorType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatFactorType}"><code>PETSc.LibPETSc.MatSetFactorType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetFactorType(petsclib::PetscLibType,mat::PetscMat, t::MatFactorType)</code></pre><p>sets the type of factorization a matrix is</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>t</code>   - the type, one of <code>MAT_FACTOR_NONE</code>, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_ICC,MAT_FACTOR_ILUDT</code>, <code>MAT_FACTOR_QR</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorType</code>, <code>MatGetFactor()</code>, <code>MatGetFactorType()</code>, <code>MAT_FACTOR_NONE</code>, <code>MAT_FACTOR_LU</code>, <code>MAT_FACTOR_CHOLESKY</code>, <code>MAT_FACTOR_ILU</code>, <code>MAT_FACTOR_ICC</code>,<code>MAT_FACTOR_ILUDT</code>, <code>MAT_FACTOR_QR</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetFactorType.html"><code>Mat/MatSetFactorType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2771-L2788">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetFromOptions(petsclib::PetscLibType,B::PetscMat)</code></pre><p>Creates a matrix where the type is determined from the options database.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>B</code> - the matrix</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_type seqaij</code>   - <code>MATSEQAIJ</code> type, uses <code>MatCreateSeqAIJ()</code></li><li><code>-mat_type mpiaij</code>   - <code>MATMPIAIJ</code> type, uses <code>MatCreateAIJ()</code></li><li><code>-mat_type seqdense</code> - <code>MATSEQDENSE</code> type, uses <code>MatCreateSeqDense()</code></li><li><code>-mat_type mpidense</code> - <code>MATMPIDENSE</code>, uses <code>MatCreateDense()</code></li><li><code>-mat_type seqbaij</code>  - <code>MATSEQBAIJ</code>, uses <code>MatCreateSeqBAIJ()</code></li><li><code>-mat_type mpibaij</code>  - <code>MATMPIBAIJ</code>, uses <code>MatCreateBAIJ()</code></li></ul><p>See the manpages for particular formats (e.g., <code>MATSEQAIJ</code>) for additional format-specific options.</p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqAIJ()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateSeqDense()</code>, <code>MatCreateDense()</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatCreateSeqSBAIJ()</code>, <code>MatCreateSBAIJ()</code>, <code>MatConvert()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetFromOptions.html"><code>Mat/MatSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19344-L19375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetHPL-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int32}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetHPL-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int32}"><code>PETSc.LibPETSc.MatSetHPL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetHPL(petsclib::PetscLibType,A::PetscMat, iseed::Cint)</code></pre><p>fills a <code>MATSEQDENSE</code> matrix using the HPL 2.3 random matrix generation routine</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the matrix</li><li><code>iseed</code> - the random number seed</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetHPL.html"><code>Mat/MatSetHPL</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20469-L20485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetInf-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetInf-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSetInf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetInf(petsclib::PetscLibType,A::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetInf.html"><code>Mat/MatSetInf</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8702-L8707">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PetscLayout}, Ptr{PETSc.LibPETSc._n_PetscLayout}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetLayouts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_PetscLayout}, Ptr{PETSc.LibPETSc._n_PetscLayout}}"><code>PETSc.LibPETSc.MatSetLayouts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetLayouts(petsclib::PetscLibType,A::PetscMat, rmap::PetscLayout, cmap::PetscLayout)</code></pre><p>Sets the <code>PetscLayout</code> objects for rows and columns of a matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>rmap</code> - row layout</li><li><code>cmap</code> - column layout</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscLayout</code>, <code>MatCreateVecs()</code>, <code>MatGetLocalToGlobalMapping()</code>, <code>MatGetLayouts()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetLayouts.html"><code>Mat/MatSetLayouts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2338-L2355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetLocalToGlobalMapping-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}, Ptr{PETSc.LibPETSc._p_ISLocalToGlobalMapping}}"><code>PETSc.LibPETSc.MatSetLocalToGlobalMapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetLocalToGlobalMapping(petsclib::PetscLibType,x::PetscMat, rmapping::ISLocalToGlobalMapping, cmapping::ISLocalToGlobalMapping)</code></pre><p>Sets a local the routine <code>MatSetValuesLocal()</code> to allow users to insert matrix entries using a local (per-processor) numbering.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>x</code>        - the matrix</li><li><code>rmapping</code> - row mapping created with <code>ISLocalToGlobalMappingCreate()</code> or <code>ISLocalToGlobalMappingCreateIS()</code></li><li><code>cmapping</code> - column mapping</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>DM</code>, <code>DMCreateMatrix()</code>, <code>MatGetLocalToGlobalMapping()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatSetValuesLocal()</code>, <code>MatGetValuesLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetLocalToGlobalMapping.html"><code>Mat/MatSetLocalToGlobalMapping</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2268-L2287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetNearNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetNearNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatSetNearNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetNearNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>attaches a null space to a matrix, which is often the null space (rigid body modes) of the operator without boundary conditions This null space will be used to provide near null space vectors to a multigrid preconditioner built from this matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>nullsp</code> - the null space object</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNullSpace()</code>, <code>MatNullSpaceCreateRigidBody()</code>, <code>MatGetNearNullSpace()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetNearNullSpace.html"><code>Mat/MatSetNearNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6961-L6978">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatSetNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>attaches a null space to a matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>nullsp</code> - the null space object</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatGetNullSpace()</code>, <code>MatSetTransposeNullSpace()</code>, <code>MatGetTransposeNullSpace()</code>, <code>MatNullSpaceRemove()</code>, <code>KSPSetPCSide()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetNullSpace.html"><code>Mat/MatSetNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6864-L6881">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetOption-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOption, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetOption-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatOption, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatSetOption</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetOption(petsclib::PetscLibType,mat::PetscMat, op::MatOption, flg::PetscBool)</code></pre><p>Sets a parameter option for a matrix. Some options may be specific to certain storage formats.  Some options determine how values will be inserted (or added). Sorted, row-oriented input will generally assemble the fastest. The default is row-oriented.</p><p>Logically Collective for certain operations, such as <code>MAT_SPD</code>, not collective for <code>MAT_ROW_ORIENTED</code>, see <code>MatOption</code></p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>op</code>  - the option, one of those listed below (and possibly others),</li><li><code>flg</code> - turn the option on (<code>PETSC_TRUE</code>) or off (<code>PETSC_FALSE</code>)</li></ul><p>Options Describing Matrix Structure:</p><ul><li><code>MAT_SPD</code>                         - symmetric positive definite</li><li><code>MAT_SYMMETRIC</code>                   - symmetric in terms of both structure and value</li><li><code>MAT_HERMITIAN</code>                   - transpose is the complex conjugation</li><li><code>MAT_STRUCTURALLY_SYMMETRIC</code>      - symmetric nonzero structure</li><li><code>MAT_SYMMETRY_ETERNAL</code>            - indicates the symmetry (or Hermitian structure) or its absence will persist through any changes to the matrix</li><li><code>MAT_STRUCTURAL_SYMMETRY_ETERNAL</code> - indicates the structural symmetry or its absence will persist through any changes to the matrix</li><li><code>MAT_SPD_ETERNAL</code>                 - indicates the value of <code>MAT_SPD</code> (true or false) will persist through any changes to the matrix</li></ul><p>These are not really options of the matrix, they are knowledge about the structure of the matrix that users may provide so that they do not need to be computed (usually at a high cost)</p><p>Options For Use with <code>MatSetValues()</code>: Insert a logically dense subblock, which can be</p><ul><li><code>MAT_ROW_ORIENTED</code>                - row-oriented (default)</li></ul><p>These options reflect the data you pass in with <code>MatSetValues()</code>; it has nothing to do with how the data is stored internally in the matrix data structure.</p><p>When (re)assembling a matrix, we can restrict the input for efficiency/debugging purposes.  These options include</p><ul><li><code>MAT_NEW_NONZERO_LOCATIONS</code>       - additional insertions will be allowed if they generate a new nonzero (slow)</li><li><code>MAT_FORCE_DIAGONAL_ENTRIES</code>      - forces diagonal entries to be allocated</li><li><code>MAT_IGNORE_OFF_PROC_ENTRIES</code>     - drops off-processor entries</li><li><code>MAT_NEW_NONZERO_LOCATION_ERR</code>    - generates an error for new matrix entry</li><li><code>MAT_USE_HASH_TABLE</code>              - uses a hash table to speed up matrix assembly</li><li><code>MAT_NO_OFF_PROC_ENTRIES</code>         - you know each process will only set values for its own rows, will generate an error if</li></ul><p>any process sets values for another process. This avoids all reductions in the MatAssembly routines and thus improves performance for very large process counts.</p><ul><li><code>MAT_SUBSET_OFF_PROC_ENTRIES</code>     - you know that the first assembly after setting this flag will set a superset</li></ul><p>of the off-process entries required for all subsequent assemblies. This avoids a rendezvous step in the MatAssembly functions, instead sending only neighbor messages.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatOption</code>, <code>Mat</code>, <code>MatGetOption()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetOption.html"><code>Mat/MatSetOption</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4657-L4712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatSetOptionsPrefix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetOptionsPrefix(petsclib::PetscLibType,A::PetscMat, prefix::Vector{Cchar})</code></pre><p>Sets the prefix used for searching for all <code>Mat</code> options in the database.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - the matrix</li><li><code>prefix</code> - the prefix to prepend to all option names</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetFromOptions()</code>, <code>MatSetOptionsPrefixFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetOptionsPrefix.html"><code>Mat/MatSetOptionsPrefix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1395-L1412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetOptionsPrefixFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetOptionsPrefixFactor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Int8}}"><code>PETSc.LibPETSc.MatSetOptionsPrefixFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetOptionsPrefixFactor(petsclib::PetscLibType,A::PetscMat, prefix::Vector{Cchar})</code></pre><p>Sets the prefix used for searching for all matrix factor options in the database for for matrices created with <code>MatGetFactor()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>A</code>      - the matrix</li><li><code>prefix</code> - the prefix to prepend to all option names for the factored matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>,   <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatSetFromOptions()</code>, <code>MatSetOptionsPrefix()</code>, <code>MatAppendOptionsPrefixFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetOptionsPrefixFactor.html"><code>Mat/MatSetOptionsPrefixFactor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1428-L1445">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetPreallocationCOO-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetPreallocationCOO-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><code>PETSc.LibPETSc.MatSetPreallocationCOO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetPreallocationCOO(petsclib::PetscLibType,A::PetscMat, ncoo::PetscCount, coo_i::Vector{PetscInt}, coo_j::Vector{PetscInt})</code></pre><p>set preallocation for matrices using a coordinate format of the entries with global indices</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - matrix being preallocated</li><li><code>ncoo</code>  - number of entries</li><li><code>coo_i</code> - row indices</li><li><code>coo_j</code> - column indices</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetValuesCOO()</code>, <code>MatSeqAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatSeqBAIJSetPreallocation()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatSeqSBAIJSetPreallocation()</code>, <code>MatMPISBAIJSetPreallocation()</code>, <code>MatSetPreallocationCOOLocal()</code>, <code>DMSetMatrixPreallocateSkip()</code>, <code>MatCreateSeqAIJFromTriple()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetPreallocationCOO.html"><code>Mat/MatSetPreallocationCOO</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19561-L19581">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetPreallocationCOOLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetPreallocationCOOLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}}"><code>PETSc.LibPETSc.MatSetPreallocationCOOLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetPreallocationCOOLocal(petsclib::PetscLibType,A::PetscMat, ncoo::PetscCount, coo_i::Vector{PetscInt}, coo_j::Vector{PetscInt})</code></pre><p>set preallocation for matrices using a coordinate format of the entries with local indices</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - matrix being preallocated</li><li><code>ncoo</code>  - number of entries</li><li><code>coo_i</code> - row indices (local numbering; may be modified)</li><li><code>coo_j</code> - column indices (local numbering; may be modified)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetValuesCOO()</code>, <code>MatSeqAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatSeqBAIJSetPreallocation()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatSeqSBAIJSetPreallocation()</code>, <code>MatMPISBAIJSetPreallocation()</code>, <code>MatSetPreallocationCOO()</code>, <code>DMSetMatrixPreallocateSkip()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetPreallocationCOOLocal.html"><code>Mat/MatSetPreallocationCOOLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19597-L19617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetRandom-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetRandom-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr}"><code>PETSc.LibPETSc.MatSetRandom</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetRandom(petsclib::PetscLibType,x::PetscMat, rctx::PetscRandom)</code></pre><p>Sets all components of a matrix to random numbers.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>x</code>    - the matrix</li><li><code>rctx</code> - the <code>PetscRandom</code> object, formed by <code>PetscRandomCreate()</code>, or <code>NULL</code> and</li></ul><p>it will create one internally.</p><p>Example: -seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscRandom</code>, <code>PetscRandomCreate()</code>, <code>MatZeroEntries()</code>, <code>MatSetValues()</code>, <code>PetscRandomDestroy()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetRandom.html"><code>Mat/MatSetRandom</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L765-L781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vararg{Int64, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vararg{Int64, 4}}"><code>PETSc.LibPETSc.MatSetSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetSizes(petsclib::PetscLibType,A::PetscMat, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt)</code></pre><p>Sets the local and global sizes, and checks to determine compatibility</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix</li><li><code>m</code> - number of local rows (or <code>PETSC_DECIDE</code>)</li><li><code>n</code> - number of local columns (or <code>PETSC_DECIDE</code>)</li><li><code>M</code> - number of global rows (or <code>PETSC_DETERMINE</code>)</li><li><code>N</code> - number of global columns (or <code>PETSC_DETERMINE</code>)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetSize()</code>, <code>PetscSplitOwnership()</code>, <code>MatGetOwnershipRange()</code>, <code>MatGetOwnershipRanges()</code>, <code>MatGetOwnershipRangeColumn()</code>, <code>MatGetOwnershipRangesColumn()</code>, <code>PetscLayout</code>, <code>VecSetSizes()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetSizes.html"><code>Mat/MatSetSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19308-L19328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Vector{Int64}, Int64}"><code>PETSc.LibPETSc.MatSetStencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetStencil(petsclib::PetscLibType,mat::PetscMat, dim::PetscInt, dims::Vector{PetscInt}, starts::Vector{PetscInt}, dof::PetscInt)</code></pre><p>Sets the grid information for setting values into a matrix via <code>MatSetValuesStencil()</code></p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>dim</code>    - dimension of the grid 1, 2, or 3</li><li><code>dims</code>   - number of grid points in x, y, and z direction, including ghost points on your processor</li><li><code>starts</code> - starting point of ghost nodes on your processor in x, y, and z direction</li><li><code>dof</code>    - number of degrees of freedom per node</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatStencil</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code> <code>MatSetValues()</code>, <code>MatSetValuesBlockedStencil()</code>, <code>MatSetValuesStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetStencil.html"><code>Mat/MatSetStencil</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2079-L2100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetTransposeNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetTransposeNullSpace-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatSetTransposeNullSpace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetTransposeNullSpace(petsclib::PetscLibType,mat::PetscMat, nullsp::MatNullSpace)</code></pre><p>attaches the null space of a transpose of a matrix to the matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>nullsp</code> - the null space object</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatCreate()</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatGetNullSpace()</code>, <code>MatSetNullSpace()</code>, <code>MatGetTransposeNullSpace()</code>, <code>MatNullSpaceRemove()</code>, <code>KSPSetPCSide()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetTransposeNullSpace.html"><code>Mat/MatSetTransposeNullSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6929-L6945">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetType(petsclib::PetscLibType,mat::PetscMat, matype::MatType)</code></pre><p>Builds matrix object for a particular matrix type</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix object</li><li><code>matype</code> - matrix type</li></ul><p>Options Database Key:</p><ul><li><code>-mat_type  &lt;method&gt;</code> - Sets the type; see <code>MatType</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCSetType()</code>, <code>VecSetType()</code>, <code>MatCreate()</code>, <code>MatType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetType.html"><code>Mat/MatSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetUnfactored-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetUnfactored-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSetUnfactored</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetUnfactored(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Resets a factored matrix to be treated as unfactored.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the factored matrix to be reset</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PCFactorSetUseInPlace()</code>, <code>PCFactorGetUseInPlace()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetUnfactored.html"><code>Mat/MatSetUnfactored</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6398-L6413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetUp-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetUp-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSetUp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetUp(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Sets up the internal matrix data structures for later use by the matrix</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatMult()</code>, <code>MatCreate()</code>, <code>MatDestroy()</code>, <code>MatXAIJSetPreallocation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetUp.html"><code>Mat/MatSetUp</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1661-L1676">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValue-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Float64, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValue-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Float64, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValue(petsclib::PetscLibType,mat::PetscMat, i::PetscInt, j::PetscInt, va::PetscScalar, mode::InsertMode)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValue.html"><code>Mat/MatSetValue</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23108-L23113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValueLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Float64, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValueLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Float64, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValueLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValueLocal(petsclib::PetscLibType,mat::PetscMat, i::PetscInt, j::PetscInt, va::PetscScalar, mode::InsertMode)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValueLocal.html"><code>Mat/MatSetValueLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23152-L23157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValues(petsclib::PetscLibType,mat::AbstractPetscMat, m::PetscInt, idxm::Vector{PetscInt}, n::PetscInt, idxn::Vector{PetscInt}, v::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds a block of values into a matrix. These values may be cached, so <code>MatAssemblyBegin()</code> and <code>MatAssemblyEnd()</code> MUST be called after all calls to <code>MatSetValues()</code> have been completed.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>m</code>    - the number of rows</li><li><code>idxm</code> - the global indices of the rows</li><li><code>n</code>    - the number of columns</li><li><code>idxn</code> - the global indices of the columns</li><li><code>v</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add values to any existing entries, or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValues.html"><code>Mat/MatSetValues</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1847-L1872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesBatch-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesBatch-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatSetValuesBatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesBatch(petsclib::PetscLibType,mat::PetscMat, nb::PetscInt, bs::PetscInt, rows::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>Adds (<code>ADD_VALUES</code>) many blocks of values into a matrix at once. The blocks must all be square and the same size. Currently, this can only be called once and creates the given matrix.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>nb</code>   - the number of blocks</li><li><code>bs</code>   - the number of rows (and columns) in each block</li><li><code>rows</code> - a concatenation of the rows for each block</li><li><code>v</code>    - a concatenation of logically two-dimensional arrays of values</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code>, <code>MatSetValues()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesBatch.html"><code>Mat/MatSetValuesBatch</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2231-L2252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesBlocked-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesBlocked-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesBlocked</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesBlocked(petsclib::PetscLibType,mat::PetscMat, m::PetscInt, idxm::Vector{PetscInt}, n::PetscInt, idxn::Vector{PetscInt}, v::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds a block of values into a matrix.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>m</code>    - the number of block rows</li><li><code>idxm</code> - the global block indices</li><li><code>n</code>    - the number of block columns</li><li><code>idxn</code> - the global block indices</li><li><code>v</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add values to any existing entries, or <code>INSERT_VALUES</code> replaces existing entries with new values</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetBlockSize()</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatSetValuesBlockedLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesBlocked.html"><code>Mat/MatSetValuesBlocked</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2116-L2138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesBlockedLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesBlockedLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesBlockedLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesBlockedLocal(petsclib::PetscLibType,mat::PetscMat, nrow::PetscInt, irow::Vector{PetscInt}, ncol::PetscInt, icol::Vector{PetscInt}, y::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds values into certain locations of a matrix, using a local ordering of the nodes a block at a time.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>nrow</code> - number of rows</li><li><code>irow</code> - the row local indices</li><li><code>ncol</code> - number of columns</li><li><code>icol</code> - the column local indices</li><li><code>y</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add values to any existing entries, or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetBlockSize()</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesLocal()</code>, <code>MatSetValuesBlocked()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesBlockedLocal.html"><code>Mat/MatSetValuesBlockedLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2446-L2470">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesBlockedStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Int64, Vector{PETSc.LibPETSc.MatStencil}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesBlockedStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Int64, Vector{PETSc.LibPETSc.MatStencil}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesBlockedStencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesBlockedStencil(petsclib::PetscLibType,mat::PetscMat, m::PetscInt, idxm::Vector{MatStencil}, n::PetscInt, idxn::Vector{MatStencil}, v::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds a block of values into a matrix. Using structured grid indexing</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>m</code>    - number of rows being entered</li><li><code>idxm</code> - grid coordinates for matrix rows being entered</li><li><code>n</code>    - number of columns being entered</li><li><code>idxn</code> - grid coordinates for matrix columns being entered</li><li><code>v</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add to existing entries or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>DMDA</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code> <code>MatSetValues()</code>, <code>MatSetValuesStencil()</code>, <code>MatSetStencil()</code>, <code>DMCreateMatrix()</code>, <code>DMDAVecGetArray()</code>, <code>MatStencil</code>, <code>MatSetBlockSize()</code>, <code>MatSetLocalToGlobalMapping()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesBlockedStencil.html"><code>Mat/MatSetValuesBlockedStencil</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2038-L2063">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesCOO-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesCOO-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesCOO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesCOO(petsclib::PetscLibType,A::PetscMat, coo_v::Vector{PetscScalar}, imode::InsertMode)</code></pre><p>set values at once in a matrix preallocated using <code>MatSetPreallocationCOO()</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - matrix being preallocated</li><li><code>coo_v</code> - the matrix values (can be <code>NULL</code>)</li><li><code>imode</code> - the insert mode</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetPreallocationCOOLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesCOO.html"><code>Mat/MatSetValuesCOO</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19633-L19650">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesIS(petsclib::PetscLibType,mat::PetscMat, ism::IS, isn::IS, v::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds a block of values into a matrix using an <code>IS</code> to indicate the rows and columns These values may be cached, so <code>MatAssemblyBegin()</code> and <code>MatAssemblyEnd()</code> MUST be called after all calls to <code>MatSetValues()</code> have been completed.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>ism</code>  - the rows to provide</li><li><code>isn</code>  - the columns to provide</li><li><code>v</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add values to any existing entries, or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MatSetValues()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesIS.html"><code>Mat/MatSetValuesIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1888-L1911">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Int64, Vector{Int64}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesLocal(petsclib::PetscLibType,mat::PetscMat, nrow::PetscInt, irow::Vector{PetscInt}, ncol::PetscInt, icol::Vector{PetscInt}, y::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds values into certain locations of a matrix, using a local numbering of the rows and columns.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>nrow</code> - number of rows</li><li><code>irow</code> - the row local indices</li><li><code>ncol</code> - number of columns</li><li><code>icol</code> - the column local indices</li><li><code>y</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add values to any existing entries, or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValues()</code>, <code>MatSetLocalToGlobalMapping()</code>, <code>MatGetValuesLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesLocal.html"><code>Mat/MatSetValuesLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L2406-L2430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesRow-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><code>PETSc.LibPETSc.MatSetValuesRow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesRow(petsclib::PetscLibType,mat::PetscMat, row::PetscInt, v::Vector{PetscScalar})</code></pre><p>Inserts a row (block row for <code>MATBAIJ</code> matrices) of nonzero values into a matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>row</code> - the (block) row to set</li><li><code>v</code>   - a logically two-dimensional (column major) array of values for  block matrices with blocksize larger than one, otherwise a one dimensional array of values</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetValues()</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesRow.html"><code>Mat/MatSetValuesRow</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1963-L1982">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesRowLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesRowLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Float64}}"><code>PETSc.LibPETSc.MatSetValuesRowLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesRowLocal(petsclib::PetscLibType,mat::PetscMat, row::PetscInt, v::Vector{PetscScalar})</code></pre><p>Inserts a row (block row for <code>MATBAIJ</code> matrices) of nonzero values into a matrix</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>row</code> - the (block) row to set</li><li><code>v</code>   - a one-dimensional array that contains the values. For <code>MATBAIJ</code> they are implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code>, <code>InsertMode</code>, <code>INSERT_VALUES</code>, <code>ADD_VALUES</code>, <code>MatSetValues()</code>, <code>MatSetValuesRow()</code>, <code>MatSetLocalToGlobalMapping()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesRowLocal.html"><code>Mat/MatSetValuesRowLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1927-L1947">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetValuesStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Int64, Vector{PETSc.LibPETSc.MatStencil}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetValuesStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Int64, Vector{PETSc.LibPETSc.MatStencil}, Vector{Float64}, PETSc.LibPETSc.InsertMode}"><code>PETSc.LibPETSc.MatSetValuesStencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetValuesStencil(petsclib::PetscLibType,mat::PetscMat, m::PetscInt, idxm::Vector{MatStencil}, n::PetscInt, idxn::Vector{MatStencil}, v::Vector{PetscScalar}, addv::InsertMode)</code></pre><p>Inserts or adds a block of values into a matrix. Using structured grid indexing</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>m</code>    - number of rows being entered</li><li><code>idxm</code> - grid coordinates (and component number when dof &gt; 1) for matrix rows being entered</li><li><code>n</code>    - number of columns being entered</li><li><code>idxn</code> - grid coordinates (and component number when dof &gt; 1) for matrix columns being entered</li><li><code>v</code>    - a one-dimensional array that contains the values implicitly stored as a two-dimensional array, by default in row-major order.</li></ul><p>See <code>MAT_ROW_ORIENTED</code> in <code>MatSetOption()</code> for how to use column-major order.</p><ul><li><code>addv</code> - either <code>ADD_VALUES</code> to add to existing entries at that location or <code>INSERT_VALUES</code> to replace existing entries with new values</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>DMDA</code>, <code>MatSetOption()</code>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>MatSetValuesBlocked()</code>, <code>MatSetValuesLocal()</code> <code>MatSetValues()</code>, <code>MatSetValuesBlockedStencil()</code>, <code>MatSetStencil()</code>, <code>DMCreateMatrix()</code>, <code>DMDAVecGetArray()</code>, <code>MatStencil</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetValuesStencil.html"><code>Mat/MatSetValuesStencil</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1998-L2022">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetVariableBlockSizes-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatSetVariableBlockSizes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetVariableBlockSizes(petsclib::PetscLibType,mat::PetscMat, nblocks::PetscInt, bsizes::Vector{PetscInt})</code></pre><p>Sets diagonal point</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>nblocks</code> - the number of blocks on this process, each block can only exist on a single process</li><li><code>bsizes</code>  - the block sizes</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreateSeqBAIJ()</code>, <code>MatCreateBAIJ()</code>, <code>MatGetBlockSize()</code>, <code>MatSetBlockSizes()</code>, <code>MatGetBlockSizes()</code>, <code>MatGetVariableBlockSizes()</code>, <code>MatComputeVariableBlockEnvelope()</code>, <code>PCVPBJACOBI</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetVariableBlockSizes.html"><code>Mat/MatSetVariableBlockSizes</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5988-L6006">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatSetVecType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSetVecType(petsclib::PetscLibType,mat::PetscMat, vtype::VecType)</code></pre><p>Set the vector type the matrix will return with <code>MatCreateVecs()</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix object</li><li><code>vtype</code> - vector type</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>VecType</code>, <code>VecSetType()</code>, <code>MatGetVecType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSetVecType.html"><code>Mat/MatSetVecType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L128-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellGetContext-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, Union{Nothing, Ptr}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellGetContext-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, Union{Nothing, Ptr}}"><code>PETSc.LibPETSc.MatShellGetContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellGetContext(petsclib::PetscLibType,mat::PetscMat, ctx::Cvoid)</code></pre><p>Returns the user</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix, should have been created with <code>MatCreateShell()</code></li></ul><p>Output Parameter:</p><ul><li><code>ctx</code> - the user provided context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellSetOperation()</code>, <code>MatShellSetContext()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellGetContext.html"><code>Mat/MatShellGetContext</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10259-L10277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetContext-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetContext-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Nothing}"><code>PETSc.LibPETSc.MatShellSetContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetContext(petsclib::PetscLibType,mat::PetscMat, ctx::Cvoid)</code></pre><p>sets the context for a <code>MATSHELL</code> shell matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the <code>MATSHELL</code> shell matrix</li><li><code>ctx</code> - the context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetContext.html"><code>Mat/MatShellSetContext</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10373-L10389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetContextDestroy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscCtxDestroyFn}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetContextDestroy-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscCtxDestroyFn}"><code>PETSc.LibPETSc.MatShellSetContextDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetContextDestroy(petsclib::PetscLibType,mat::PetscMat, f::PetscCtxDestroyFn)</code></pre><p>sets the destroy function for a <code>MATSHELL</code> shell matrix context</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the shell matrix</li><li><code>f</code>   - the context destroy function, see <code>PetscCtxDestroyFn</code> for calling sequence</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellSetContext()</code>, <code>PetscCtxDestroyFn</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetContextDestroy.html"><code>Mat/MatShellSetContextDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10405-L10422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetManageScalingShifts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetManageScalingShifts-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatShellSetManageScalingShifts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetManageScalingShifts(petsclib::PetscLibType,A::PetscMat)</code></pre><p>Allows the user to control the scaling and shift operations of the <code>MATSHELL</code>. Must be called immediately after <code>MatCreateShell()</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATSHELL</code> shell matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code>, <code>MatShellSetContext()</code>, <code>MatShellSetOperation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetManageScalingShifts.html"><code>Mat/MatShellSetManageScalingShifts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10470-L10486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetMatProductOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatProductType, Ptr, Ptr, Ptr, Ptr{Int8}, Ptr}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetMatProductOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatProductType, Ptr, Ptr, Ptr, Ptr{Int8}, Ptr}"><code>PETSc.LibPETSc.MatShellSetMatProductOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetMatProductOperation(petsclib::PetscLibType,A::PetscMat, ptype::MatProductType, symbolic::external, numeric::external, destroy::external, Btype::MatType, Ctype::MatType)</code></pre><p>Allows user to set a matrix matrix operation for a <code>MATSHELL</code> shell matrix.</p><p>Logically Collective; No Fortran Support</p><p>Input Parameters:</p><ul><li><code>A</code>        - the <code>MATSHELL</code> shell matrix</li><li><code>ptype</code>    - the product type</li><li><code>symbolic</code> - the function for the symbolic phase (can be <code>NULL</code>)</li><li><code>numeric</code>  - the function for the numerical phase</li><li><code>destroy</code>  - the function for the destruction of the needed data generated during the symbolic phase (can be <code>NULL</code>)</li><li><code>Btype</code>    - the matrix type for the matrix to be multiplied against</li><li><code>Ctype</code>    - the matrix type for the result (can be <code>NULL</code>)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code>, <code>MatShellSetContext()</code>, <code>MatSetOperation()</code>, <code>MatProductType</code>, <code>MatType</code>, <code>MatSetUp()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetMatProductOperation.html"><code>Mat/MatShellSetMatProductOperation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10292-L10313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatOperation, Ptr}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetOperation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.AbstractPetscMat, PETSc.LibPETSc.MatOperation, Ptr}"><code>PETSc.LibPETSc.MatShellSetOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetOperation(petsclib::PetscLibType, mat::PetscMat, op::MatOperation, g::Ptr)</code></pre><p>Allows user to set a matrix operation for a <code>MATSHELL</code> shell matrix.</p><p>Logically Collective</p><p>Input Parameters: <code>mat</code> - the <code>MATSHELL</code> shell matrix <code>op</code>  - the name of the operation <code>g</code>   - a pointer to the function that provides the operation created with <code>@cfunction</code></p><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code>, <code>MatShellSetContext()</code>, <code>MatSetOperation()</code>, <code>MatShellSetManageScalingShifts()</code>, <code>MatShellSetMatProductOperation()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetOperation.html"><code>Mat/MatShellSetOperation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L23179-L23197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellSetVecType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatShellSetVecType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShellSetVecType(petsclib::PetscLibType,mat::PetscMat, vtype::VecType)</code></pre><p>Sets the <code>VecType</code> of <code>Vec</code> returned by <code>MatCreateVecs()</code></p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the <code>MATSHELL</code> shell matrix</li><li><code>vtype</code> - type to use for creating vectors</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateVecs()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellSetVecType.html"><code>Mat/MatShellSetVecType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10438-L10454">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellTestMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, PETSc.LibPETSc.PetscVec, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellTestMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, PETSc.LibPETSc.PetscVec, Nothing}"><code>PETSc.LibPETSc.MatShellTestMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatShellTestMult(petsclib::PetscLibType,mat::PetscMat, f::external, base::PetscVec, ctx::Cvoid)</code></pre><p>Compares the multiply routine provided to the <code>MATSHELL</code> with differencing on a given function.</p><p>Logically Collective; No Fortran Support</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the <code>MATSHELL</code> shell matrix</li><li><code>f</code>    - the function</li><li><code>base</code> - differences are computed around this vector, see <code>MatMFFDSetBase()</code>, for Jacobians this is the point at which the Jacobian is being evaluated</li><li><code>ctx</code>  - an optional context for the function</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the multiply is likely correct</li></ul><p>Options Database Key:</p><ul><li><code>-mat_shell_test_mult_view</code> - print if any differences are detected between the products and print the difference</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code>, <code>MatShellTestMultTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellTestMult.html"><code>Mat/MatShellTestMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10502-L10526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShellTestMultTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, PETSc.LibPETSc.PetscVec, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShellTestMultTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, PETSc.LibPETSc.PetscVec, Nothing}"><code>PETSc.LibPETSc.MatShellTestMultTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatShellTestMultTranspose(petsclib::PetscLibType,mat::PetscMat, f::external, base::PetscVec, ctx::Cvoid)</code></pre><p>Compares the multiply transpose routine provided to the <code>MATSHELL</code> with differencing on a given function.</p><p>Logically Collective; No Fortran Support</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the <code>MATSHELL</code> shell matrix</li><li><code>f</code>    - the function</li><li><code>base</code> - differences are computed around this vector, see <code>MatMFFDSetBase()</code>, for Jacobians this is the point at which the Jacobian is being evaluated</li><li><code>ctx</code>  - an optional context for the function</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the multiply is likely correct</li></ul><p>Options Database Key:</p><ul><li><code>-mat_shell_test_mult_view</code> - print if any differences are detected between the products and print the difference</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSHELL</code>, <code>MatCreateShell()</code>, <code>MatShellGetContext()</code>, <code>MatShellGetOperation()</code>, <code>MatShellTestMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShellTestMultTranspose.html"><code>Mat/MatShellTestMultTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L10544-L10568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatShift-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatShift-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatShift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatShift(petsclib::PetscLibType,Y::PetscMat, a::PetscScalar)</code></pre><p>Computes <code>Y =  Y + a I</code>, where <code>a</code> is a <code>PetscScalar</code></p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>Y</code> - the matrix</li><li><code>a</code> - the <code>PetscScalar</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatDiagonalSet()</code>, <code>MatScale()</code>, <code>MatDiagonalScale()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatShift.html"><code>Mat/MatShift</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19801-L19817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolve-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatSolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolve(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, x::PetscVec)</code></pre><p>Solves A x = b, given a factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatGetFactor()</code>, <code>MatLUFactor()</code>, <code>MatSolveAdd()</code>, <code>MatSolveTranspose()</code>, <code>MatSolveTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolve.html"><code>Mat/MatSolve</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3173-L3192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolveAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolveAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatSolveAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolveAdd(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, y::PetscVec, x::PetscVec)</code></pre><p>Computes x = y + A^{</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li><li><code>y</code>   - the vector to be added to</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatSolve()</code>, <code>MatGetFactor()</code>, <code>MatSolveTranspose()</code>, <code>MatSolveTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolveAdd.html"><code>Mat/MatSolveAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3385-L3405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolveTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolveTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatSolveTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolveTranspose(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, x::PetscVec)</code></pre><p>Solves A^T x = b, given a factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>KSP</code>, <code>MatSolve()</code>, <code>MatSolveAdd()</code>, <code>MatSolveTransposeAdd()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolveTranspose.html"><code>Mat/MatSolveTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3421-L3440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolveTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolveTransposeAdd-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatSolveTransposeAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolveTransposeAdd(petsclib::PetscLibType,mat::PetscMat, b::PetscVec, y::PetscVec, x::PetscVec)</code></pre><p>Computes x = y + A^{ factored matrix.</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix</li><li><code>b</code>   - the right-hand-side vector</li><li><code>y</code>   - the vector to be added to</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vector</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MatSolve()</code>, <code>MatSolveAdd()</code>, <code>MatSolveTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolveTransposeAdd.html"><code>Mat/MatSolveTransposeAdd</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3456-L3477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolverTypeRegister-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{Int8}, Ptr{Int8}, PETSc.LibPETSc.MatFactorType, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolverTypeRegister-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{Int8}, Ptr{Int8}, PETSc.LibPETSc.MatFactorType, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatSolverTypeRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolverTypeRegister(petsclib::PetscLibType,package::MatSolverType, mtype::MatType, ftype::MatFactorType, createfactor::external)</code></pre><p>Registers a <code>MatSolverType</code> that works for a particular matrix type</p><p>Logically Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>package</code>      - name of the package, for example <code>petsc</code> or <code>superlu</code></li><li><code>mtype</code>        - the matrix type that works with this package</li><li><code>ftype</code>        - the type of factorization supported by the package</li><li><code>createfactor</code> - routine that will create the factored matrix ready to be used</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <a href="sec_matfactor">Matrix Factorization</a>, <code>MatFactorGetSolverType()</code>, <code>MatCopy()</code>, <code>MatDuplicate()</code>, <code>MatGetFactorAvailable()</code>, <code>MatGetFactor()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolverTypeRegister.html"><code>Mat/MatSolverTypeRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L3659-L3678">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSolves-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_Vecs}, Ptr{PETSc.LibPETSc._n_Vecs}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSolves-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_Vecs}, Ptr{PETSc.LibPETSc._n_Vecs}}"><code>PETSc.LibPETSc.MatSolves</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSolves(petsclib::PetscLibType,mat::PetscMat, b::Vecs, x::Vecs)</code></pre><p>Solves A x = b, given a factored matrix, for a collection of vectors</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the factored matrix obtained with <code>MatGetFactor()</code></li><li><code>b</code>   - the right-hand-side vectors</li></ul><p>Output Parameter:</p><ul><li><code>x</code> - the result vectors</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>Vecs</code>, <code>MatSolveAdd()</code>, <code>MatSolveTranspose()</code>, <code>MatSolveTransposeAdd()</code>, <code>MatSolve()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSolves.html"><code>Mat/MatSolves</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7136-L7155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatStashGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatStashGetInfo-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatStashGetInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nstash::PetscInt,reallocs::PetscInt,bnstash::PetscInt,breallocs::PetscInt = MatStashGetInfo(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets how many values are currently in the matrix stash, i.e. need to be communicated to other processors during the <code>MatAssemblyBegin()</code>/<code>MatAssemblyEnd()</code> process</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Output Parameters:</p><ul><li><code>nstash</code>    - the size of the stash</li><li><code>reallocs</code>  - the number of additional mallocs incurred.</li><li><code>bnstash</code>   - the size of the block stash</li><li><code>breallocs</code> - the number of additional mallocs incurred.in the block stash</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>Mat</code>, <code>MatStashSetInitialSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatStashGetInfo.html"><code>Mat/MatStashGetInfo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7439-L7461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatStashSetInitialSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatStashSetInitialSize-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64}"><code>PETSc.LibPETSc.MatStashSetInitialSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatStashSetInitialSize(petsclib::PetscLibType,mat::PetscMat, size::PetscInt, bsize::PetscInt)</code></pre><p>sets the sizes of the matrix stash, that is used during the assembly process to store values that belong to other processors.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix</li><li><code>size</code>  - the initial size of the stash.</li><li><code>bsize</code> - the initial size of the block-stash(if used).</li></ul><p>Options Database Keys:</p><ul><li><code>-matstash_initial_size &lt;size&gt; or &lt;size0,size1,...sizep-1&gt;</code>            - set initial size</li><li><code>-matstash_block_initial_size &lt;bsize&gt;  or &lt;bsize0,bsize1,...bsizep-1&gt;</code> - set initial block size</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>MatAssemblyBegin()</code>, <code>MatAssemblyEnd()</code>, <code>Mat</code>, <code>MatStashGetInfo()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatStashSetInitialSize.html"><code>Mat/MatStashSetInitialSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L6501-L6524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatStoreValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatStoreValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatStoreValues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatStoreValues(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Stashes a copy of the matrix values; this allows reusing of the linear part of a Jacobian, while recomputing only the nonlinear portion.</p><p>Logically Collect</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix (currently only <code>MATAIJ</code> matrices support this option)</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatRetrieveValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatStoreValues.html"><code>Mat/MatStoreValues</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17809-L17825">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSubMatrixVirtualUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSubMatrixVirtualUpdate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatSubMatrixVirtualUpdate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSubMatrixVirtualUpdate(petsclib::PetscLibType,N::PetscMat, A::PetscMat, isrow::IS, iscol::IS)</code></pre><p>Updates a <code>MATSUBMATRIX</code> virtual submatrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>N</code>     - submatrix to update</li><li><code>A</code>     - full matrix in the submatrix</li><li><code>isrow</code> - rows in the update (same as the first time the submatrix was created)</li><li><code>iscol</code> - columns in the update (same as the first time the submatrix was created)</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATSUBMATRIX</code>, <code>MatCreateSubMatrixVirtual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSubMatrixVirtualUpdate.html"><code>Mat/MatSubMatrixVirtualUpdate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15054-L15072">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSubdomainsCreateCoalesce-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSubdomainsCreateCoalesce-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatSubdomainsCreateCoalesce</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,iss::Vector{IS} = MatSubdomainsCreateCoalesce(petsclib::PetscLibType,A::PetscMat, N::PetscInt)</code></pre><p>Creates index subdomains by coalescing adjacent MPI processes&#39; ownership ranges.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the matrix to create subdomains from</li><li><code>N</code> - requested number of subdomains</li></ul><p>Output Parameters:</p><ul><li><code>n</code>   - number of subdomains resulting on this MPI process</li><li><code>iss</code> - <code>IS</code> list with indices of subdomains on this MPI process</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>IS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSubdomainsCreateCoalesce.html"><code>Mat/MatSubdomainsCreateCoalesce</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8541-L8561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSuperluDistGetDiagU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSuperluDistGetDiagU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatSuperluDistGetDiagU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diagU::PetscScalar = MatSuperluDistGetDiagU(petsclib::PetscLibType,F::PetscMat)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSuperluDistGetDiagU.html"><code>Mat/MatSuperluDistGetDiagU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L17202-L17207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatSuperluSetILUDropTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatSuperluSetILUDropTol-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatSuperluSetILUDropTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatSuperluSetILUDropTol(petsclib::PetscLibType,F::PetscMat, dtol::PetscReal)</code></pre><p>Set SuperLU <a href="https://portal.nersc.gov/project/sparse/superlu/superlu_ug.pdf">https://portal.nersc.gov/project/sparse/superlu/superlu_ug.pdf</a> ILU drop tolerance</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>F</code>    - the factored matrix obtained by calling <code>MatGetFactor()</code></li><li><code>dtol</code> - drop tolerance</li></ul><p>Options Database Key:</p><ul><li><code>-mat_superlu_ilu_droptol &lt;dtol&gt;</code> - the drop tolerance</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetFactor()</code>, <code>MATSOLVERSUPERLU</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatSuperluSetILUDropTol.html"><code>Mat/MatSuperluSetILUDropTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L18609-L18628">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransColoringApplyDenToSp-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransColoringApplyDenToSp-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransColoringApplyDenToSp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransColoringApplyDenToSp(petsclib::PetscLibType,matcoloring::MatTransposeColoring, Cden::PetscMat, Csp::PetscMat)</code></pre><p>Given a symbolic matrix product C<em>{sp} = A*B^T for which a <code>MatTransposeColoring</code> context has been created and a dense matrix C</em>{den} = A*B^T<em>{dense} in which `B^T</em>{dens}<code>is obtained from</code>MatTransColoringApplySpToDen()`, recover sparse matrix C<em>{sp} from C</em>{den}.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>matcoloring</code> - coloring context created with <code>MatTransposeColoringCreate()</code></li><li><code>Cden</code>        - matrix product of a sparse matrix and a dense matrix Btdense</li></ul><p>Output Parameter:</p><ul><li><code>Csp</code> - sparse matrix</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeColoringCreate()</code>, <code>MatTransposeColoringDestroy()</code>, <code>MatTransColoringApplySpToDen()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransColoringApplyDenToSp.html"><code>Mat/MatTransColoringApplyDenToSp</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8428-L8450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransColoringApplySpToDen-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransColoringApplySpToDen-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransColoringApplySpToDen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransColoringApplySpToDen(petsclib::PetscLibType,coloring::MatTransposeColoring, B::PetscMat, Btdense::PetscMat)</code></pre><p>Given a symbolic matrix product C = A*B^T for which a <code>MatTransposeColoring</code> context has been created, computes a dense B^T by applying <code>MatTransposeColoring</code> to sparse <code>B</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>coloring</code> - coloring context created with <code>MatTransposeColoringCreate()</code></li><li><code>B</code>        - sparse matrix</li></ul><p>Output Parameter:</p><ul><li><code>Btdense</code> - dense matrix B^T</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeColoringCreate()</code>, <code>MatTransposeColoringDestroy()</code>, <code>MatTransColoringApplyDenToSp()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransColoringApplySpToDen.html"><code>Mat/MatTransColoringApplySpToDen</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L8391-L8412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTranspose-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTranspose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTranspose(petsclib::PetscLibType,mat::PetscMat, reuse::MatReuse, B::PetscMat)</code></pre><p>Computes the transpose of a matrix, either in</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix to transpose</li><li><code>reuse</code> - either <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, or <code>MAT_INPLACE_MATRIX</code></li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the transpose of the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeSetPrecursor()</code>, <code>MatMultTranspose()</code>, <code>MatMultTransposeAdd()</code>, <code>MatIsTranspose()</code>, <code>MatReuse</code>, <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, <code>MAT_INPLACE_MATRIX</code>, <code>MatTransposeSymbolic()</code>, <code>MatCreateTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTranspose.html"><code>Mat/MatTranspose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4172-L4192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeGetMat-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransposeGetMat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransposeGetMat(petsclib::PetscLibType,A::PetscMat, M::PetscMat)</code></pre><p>Gets the <code>Mat</code> object stored inside a <code>MATTRANSPOSEVIRTUAL</code></p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the <code>MATTRANSPOSEVIRTUAL</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>M</code> - the matrix object stored inside <code>A</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATTRANSPOSEVIRTUAL</code>, <code>MatCreateTranspose()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeGetMat.html"><code>Mat/MatTransposeGetMat</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L11198-L11216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeMatMult-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatReuse, Float64, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransposeMatMult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransposeMatMult(petsclib::PetscLibType,A::PetscMat, B::PetscMat, scall::MatReuse, fill::PetscReal, C::PetscMat)</code></pre><p>Performs matrix</p><p>Neighbor-wise Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - the left matrix</li><li><code>B</code>     - the right matrix</li><li><code>scall</code> - either <code>MAT_INITIAL_MATRIX</code> or <code>MAT_REUSE_MATRIX</code></li><li><code>fill</code>  - expected fill as ratio of nnz(C)/(nnz(A) + nnz(B)), use <code>PETSC_DETERMINE</code> or <code>PETSC_CURRENT</code> if not known</li></ul><p>Output Parameter:</p><ul><li><code>C</code> - the product matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatProductCreate()</code>, <code>MATPRODUCT_AtB</code>, <code>MatMatMult()</code>, <code>MatMatTransposeMult()</code>, <code>MatPtAP()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeMatMult.html"><code>Mat/MatTransposeMatMult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L7987-L8008">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeMatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeMatMultEqual-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatTransposeMatMultEqual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flg::PetscBool = MatTransposeMatMultEqual(petsclib::PetscLibType,A::PetscMat, B::PetscMat, C::PetscMat, n::PetscInt)</code></pre><p>Test A^T<em>B</em>x = C*x for n random vector x</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code> - the first matrix</li><li><code>B</code> - the second matrix</li><li><code>C</code> - the third matrix</li><li><code>n</code> - number of random vectors to be tested</li></ul><p>Output Parameter:</p><ul><li><code>flg</code> - <code>PETSC_TRUE</code> if the products are equal; <code>PETSC_FALSE</code> otherwise.</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatMatMultEqual()</code>, <code>MatMultEqual()</code>, <code>MatMultAddEqual()</code>, <code>MatMultTransposeEqual()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeMatMultEqual.html"><code>Mat/MatTransposeMatMultEqual</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L20276-L20297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeSetPrecursor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeSetPrecursor-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransposeSetPrecursor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransposeSetPrecursor(petsclib::PetscLibType,mat::PetscMat, B::PetscMat)</code></pre><p>Set the matrix from which the second matrix will receive numerical transpose data with a call to <code>MatTranspose</code>(A,<code>MAT_REUSE_MATRIX</code>,&amp;B) when B was not obtained with <code>MatTranspose</code>(A,<code>MAT_INITIAL_MATRIX</code>,&amp;B)</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix to provide the transpose</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the matrix to contain the transpose; it MUST have the nonzero structure of the transpose of A or the code will crash or generate incorrect results</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeSymbolic()</code>, <code>MatTranspose()</code>, <code>MatMultTranspose()</code>, <code>MatMultTransposeAdd()</code>, <code>MatIsTranspose()</code>, <code>MatReuse</code>, <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, <code>MAT_INPLACE_MATRIX</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeSetPrecursor.html"><code>Mat/MatTransposeSetPrecursor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4137-L4156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeSymbolic-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatTransposeSymbolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransposeSymbolic(petsclib::PetscLibType,A::PetscMat, B::PetscMat)</code></pre><p>Computes the symbolic part of the transpose of a matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>A</code> - the matrix to transpose</li></ul><p>Output Parameter:</p><ul><li><code>B</code> - the transpose. This is a complete matrix but the numerical portion is invalid. One can call <code>MatTranspose</code>(A,<code>MAT_REUSE_MATRIX</code>,&amp;B) to compute the</li></ul><p>numerical portion.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeSetPrecursor()</code>, <code>MatTranspose()</code>, <code>MatMultTranspose()</code>, <code>MatMultTransposeAdd()</code>, <code>MatIsTranspose()</code>, <code>MatReuse</code>, <code>MAT_INITIAL_MATRIX</code>, <code>MAT_REUSE_MATRIX</code>, <code>MAT_INPLACE_MATRIX</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeSymbolic.html"><code>Mat/MatTransposeSymbolic</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4210-L4229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatUpdateMPIAIJWithArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatUpdateMPIAIJWithArray-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}}"><code>PETSc.LibPETSc.MatUpdateMPIAIJWithArray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatUpdateMPIAIJWithArray(petsclib::PetscLibType,mat::PetscMat, v::Vector{PetscScalar})</code></pre><p>updates an <code>MATMPIAIJ</code> matrix using an array that contains the nonzero values</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>v</code>   - matrix values, stored by row</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MATMPIAIJ</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code>, <code>MatUpdateMPIAIJWithArrays()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatUpdateMPIAIJWithArray.html"><code>Mat/MatUpdateMPIAIJWithArray</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15712-L15729">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatUpdateMPIAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatUpdateMPIAIJWithArrays-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>PETSc.LibPETSc.MatUpdateMPIAIJWithArrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatUpdateMPIAIJWithArrays(petsclib::PetscLibType,mat::PetscMat, m::PetscInt, n::PetscInt, M::PetscInt, N::PetscInt, Ii::Vector{PetscInt}, J::Vector{PetscInt}, v::Vector{PetscScalar})</code></pre><p>updates a <code>MATMPIAIJ</code> matrix using arrays that contain in standard CSR format for the local rows. Only the numerical values are updated the other arrays must be identical to what was passed from <code>MatCreateMPIAIJWithArrays()</code></p><p>Deprecated: Use <code>MatUpdateMPIAIJWithArray()</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the matrix</li><li><code>m</code>   - number of local rows (Cannot be <code>PETSC_DECIDE</code>)</li><li><code>n</code>   - This value should be the same as the local size used in creating the</li></ul><p>x vector for the matrix-vector product y = Ax. (or <code>PETSC_DECIDE</code> to have calculated if N is given) For square matrices n is almost always m.</p><ul><li><code>M</code>   - number of global rows (or <code>PETSC_DETERMINE</code> to have calculated if m is given)</li><li><code>N</code>   - number of global columns (or <code>PETSC_DETERMINE</code> to have calculated if n is given)</li><li><code>Ii</code>  - row indices; that is Ii[0] = 0, Ii[row] = Ii[row-1] + number of elements in that row of the matrix</li><li><code>J</code>   - column indices</li><li><code>v</code>   - matrix values</li></ul><p>Level: deprecated</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMPIAIJ</code>, <code>MatCreate()</code>, <code>MatCreateSeqAIJ()</code>, <code>MatSetValues()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocationCSR()</code>, <code>MatCreateAIJ()</code>, <code>MatCreateMPIAIJWithSplitArrays()</code>, <code>MatUpdateMPIAIJWithArray()</code>, <code>MatSetPreallocationCOO()</code>, <code>MatSetValuesCOO()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatUpdateMPIAIJWithArrays.html"><code>Mat/MatUpdateMPIAIJWithArrays</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L15667-L15696">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatView-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatView-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatView(petsclib::PetscLibType,mat::PetscMat, viewer::PetscViewer)</code></pre><p>display information about a matrix in a variety ways</p><p>Collective on viewer</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the matrix</li><li><code>viewer</code> - visualization context</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_view ::ascii_info</code>           - Prints info on matrix at conclusion of <code>MatAssemblyEnd()</code></li><li><code>-mat_view ::ascii_info_detail</code>    - Prints more detailed info</li><li><code>-mat_view</code>                        - Prints matrix in ASCII format</li><li><code>-mat_view ::ascii_matlab</code>         - Prints matrix in MATLAB format</li><li><code>-mat_view draw</code>                   - PetscDraws nonzero structure of matrix, using <code>MatView()</code> and <code>PetscDrawOpenX()</code>.</li><li><code>-display &lt;name&gt;</code>                  - Sets display name (default is host)</li><li><code>-draw_pause &lt;sec&gt;</code>                - Sets number of seconds to pause after display</li><li><code>-mat_view socket</code>                 - Sends matrix to socket, can be accessed from MATLAB (see Users-Manual: ch_matlab for details)</li><li><code>-viewer_socket_machine &lt;machine&gt;</code> - -</li><li><code>-viewer_socket_port &lt;port&gt;</code>       - -</li><li><code>-mat_view binary</code>                 - save matrix to file in binary format</li><li><code>-viewer_binary_filename &lt;name&gt;</code>   - -</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>PetscViewerPushFormat()</code>, <code>PetscViewerASCIIOpen()</code>, <code>PetscViewerDrawOpen()</code>, <code>PetscViewer</code>, <code>PetscViewerSocketOpen()</code>, <code>PetscViewerBinaryOpen()</code>, <code>MatLoad()</code>, <code>MatViewFromOptions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatView.html"><code>Mat/MatView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1728-L1759">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, Vector{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Nothing}, Vector{Int8}}"><code>PETSc.LibPETSc.MatViewFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatViewFromOptions(petsclib::PetscLibType,A::PetscMat, obj::PetscObject, name::Vector{Cchar})</code></pre><p>View properties of the matrix based on options set in the options database</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the matrix</li><li><code>obj</code>  - optional additional object that provides the options prefix to use</li><li><code>name</code> - command line option</li></ul><p>Options Database Key:</p><ul><li><code>-mat_view [viewertype]:...</code> - the viewer and its options</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatView()</code>, <code>PetscObjectViewFromOptions()</code>, <code>MatCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatViewFromOptions.html"><code>Mat/MatViewFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L1692-L1712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatXAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vararg{Vector{Int64}, 4}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatXAIJSetPreallocation-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vararg{Vector{Int64}, 4}}"><code>PETSc.LibPETSc.MatXAIJSetPreallocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatXAIJSetPreallocation(petsclib::PetscLibType,A::PetscMat, bs::PetscInt, dnnz::Vector{PetscInt}, onnz::Vector{PetscInt}, dnnzu::Vector{PetscInt}, onnzu::Vector{PetscInt})</code></pre><p>set preallocation for serial and parallel <code>MATAIJ</code>, <code>MATBAIJ</code>, and <code>MATSBAIJ</code> matrices and their unassembled versions.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>     - matrix being preallocated</li><li><code>bs</code>    - block size</li><li><code>dnnz</code>  - number of nonzero column blocks per block row of diagonal part of parallel matrix</li><li><code>onnz</code>  - number of nonzero column blocks per block row of off-diagonal part of parallel matrix</li><li><code>dnnzu</code> - number of nonzero column blocks per block row of upper-triangular part of diagonal part of parallel matrix</li><li><code>onnzu</code> - number of nonzero column blocks per block row of upper-triangular part of off-diagonal part of parallel matrix</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatSeqAIJSetPreallocation()</code>, <code>MatMPIAIJSetPreallocation()</code>, <code>MatSeqBAIJSetPreallocation()</code>, <code>MatMPIBAIJSetPreallocation()</code>, <code>MatSeqSBAIJSetPreallocation()</code>, <code>MatMPISBAIJSetPreallocation()</code>, <code>PetscSplitOwnership()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatXAIJSetPreallocation.html"><code>Mat/MatXAIJSetPreallocation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L19391-L19413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroEntries-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroEntries-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatZeroEntries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroEntries(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Zeros all entries of a matrix.  For sparse matrices this routine retains the old nonzero structure.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mat</code> - the matrix</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsColumns()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroEntries.html"><code>Mat/MatZeroEntries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4766-L4782">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRows-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRows(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{PetscInt}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows of a matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows to zero</li><li><code>rows</code>    - the global row indices</li><li><code>diag</code>    - value put in the diagonal of the zeroed rows</li><li><code>x</code>       - optional vector of solutions for zeroed rows (other entries in vector are not used), these must be set before this call</li><li><code>b</code>       - optional vector of right-hand side, that will be adjusted by provided solution entries</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code>, <code>PCREDISTRIBUTE</code>, <code>MAT_KEEP_NONZERO_PATTERN</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRows.html"><code>Mat/MatZeroRows</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4873-L4895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsColumns-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsColumns-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsColumns</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsColumns(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{PetscInt}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows and columns of a matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows/columns to zero</li><li><code>rows</code>    - the global row indices</li><li><code>diag</code>    - value put in the diagonal of the eliminated rows</li><li><code>x</code>       - optional vector of the solution for zeroed rows (other entries in vector are not used), these must be set before this call</li><li><code>b</code>       - optional vector of the right-hand side, that will be adjusted by provided solution entries</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsColumns.html"><code>Mat/MatZeroRowsColumns</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4798-L4820">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsColumnsIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsColumnsIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsColumnsIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsColumnsIS(petsclib::PetscLibType,mat::PetscMat, is::IS, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows and columns of a matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>is</code>   - the rows to zero</li><li><code>diag</code> - value put in all diagonals of eliminated rows (0.0 will even eliminate diagonal entry)</li><li><code>x</code>    - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>    - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsColumnsIS.html"><code>Mat/MatZeroRowsColumnsIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4836-L4857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsColumnsLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsColumnsLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsColumnsLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsColumnsLocal(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{PetscInt}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows and columns of a matrix; using local numbering of rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows to remove</li><li><code>rows</code>    - the global row indices</li><li><code>diag</code>    - value put in all diagonals of eliminated rows</li><li><code>x</code>       - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>       - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsColumnsLocal.html"><code>Mat/MatZeroRowsColumnsLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5099-L5121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsColumnsLocalIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsColumnsLocalIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsColumnsLocalIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsColumnsLocalIS(petsclib::PetscLibType,mat::PetscMat, is::IS, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows and columns of a matrix; using local numbering of rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>is</code>   - index set of rows to remove</li><li><code>diag</code> - value put in all diagonals of eliminated rows</li><li><code>x</code>    - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>    - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsColumnsLocalIS.html"><code>Mat/MatZeroRowsColumnsLocalIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5137-L5158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsColumnsStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsColumnsStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsColumnsStencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsColumnsStencil(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{MatStencil}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all row and column entries (except possibly the main diagonal) of a set of rows and columns of a matrix.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows/columns to remove</li><li><code>rows</code>    - the grid coordinates (and component number when dof &gt; 1) for matrix rows</li><li><code>diag</code>    - value put in all diagonals of eliminated rows (0.0 will even eliminate diagonal entry)</li><li><code>x</code>       - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>       - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRows()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsColumnsStencil.html"><code>Mat/MatZeroRowsColumnsStencil</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4986-L5008">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.IS}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Union{Ptr, PETSc.LibPETSc.IS}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsIS(petsclib::PetscLibType,mat::PetscMat, is::IS, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows of a matrix indicated by an <code>IS</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>is</code>   - index set, <code>IS</code>, of rows to remove (if <code>NULL</code> then no row is removed)</li><li><code>diag</code> - value put in all diagonals of eliminated rows</li><li><code>x</code>    - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>    - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code>, <code>IS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsIS.html"><code>Mat/MatZeroRowsIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4911-L4932">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsLocal-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{Int64}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsLocal(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{PetscInt}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows of a matrix; using local numbering of rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows to remove</li><li><code>rows</code>    - the local row indices</li><li><code>diag</code>    - value put in all diagonals of eliminated rows</li><li><code>x</code>       - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>       - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRows()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsLocal.html"><code>Mat/MatZeroRowsLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5024-L5046">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsLocalIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsLocalIS-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.IS, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsLocalIS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsLocalIS(petsclib::PetscLibType,mat::PetscMat, is::IS, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows of a matrix; using local numbering of rows.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the matrix</li><li><code>is</code>   - index set of rows to remove</li><li><code>diag</code> - value put in all diagonals of eliminated rows</li><li><code>x</code>    - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>    - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRows()</code>, <code>MatZeroRowsStencil()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsLocalIS.html"><code>Mat/MatZeroRowsLocalIS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L5062-L5083">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatZeroRowsStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatZeroRowsStencil-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Vector{PETSc.LibPETSc.MatStencil}, Float64, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatZeroRowsStencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatZeroRowsStencil(petsclib::PetscLibType,mat::PetscMat, numRows::PetscInt, rows::Vector{MatStencil}, diag::PetscScalar, x::PetscVec, b::PetscVec)</code></pre><p>Zeros all entries (except possibly the main diagonal) of a set of rows of a matrix indicated by a <code>MatStencil</code>. These rows must be local to the process.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix</li><li><code>numRows</code> - the number of rows to remove</li><li><code>rows</code>    - the grid coordinates (and component number when dof &gt; 1) for matrix rows indicated by an array of <code>MatStencil</code></li><li><code>diag</code>    - value put in all diagonals of eliminated rows (0.0 will even eliminate diagonal entry)</li><li><code>x</code>       - optional vector of solutions for zeroed rows (other entries in vector are not used)</li><li><code>b</code>       - optional vector of right-hand side, that will be adjusted by provided solution</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatStencil</code>, <code>MatZeroRowsIS()</code>, <code>MatZeroRowsColumns()</code>, <code>MatZeroRowsLocalIS()</code>, <code>MatZeroRows()</code>, <code>MatZeroEntries()</code>, <code>MatZeroRowsLocal()</code>, <code>MatSetOption()</code>, <code>MatZeroRowsColumnsLocal()</code>, <code>MatZeroRowsColumnsLocalIS()</code>, <code>MatZeroRowsColumnsIS()</code>, <code>MatZeroRowsColumnsStencil()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatZeroRowsStencil.html"><code>Mat/MatZeroRowsStencil</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mat_wrappers.jl#L4948-L4970">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><code>PETSc.LibPETSc.MatCoarsenApply</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenApply(petsclib::PetscLibType,coarser::MatCoarsen)</code></pre><p>Gets a coarsen for a matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>coarser</code> - the coarsen</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_coarsen_type mis|hem|misk</code> - mis: maximal independent set based; misk: distance k MIS; hem: heavy edge matching</li><li><code>-mat_coarsen_view</code>              - view the coarsening object</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenSetFromOptions()</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenRegister()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenDestroy()</code>, <code>MatCoarsenSetAdjacency()</code> <code>MatCoarsenGetData()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenApply.html"><code>Mat/MatCoarsenApply</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3688-L3709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><code>PETSc.LibPETSc.MatCoarsenCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newcrs::MatCoarsen = MatCoarsenCreate(petsclib::PetscLibType,comm::MPI_Comm)</code></pre><p>Creates a coarsen context.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>comm</code> - MPI communicator</li></ul><p>Output Parameter:</p><ul><li><code>newcrs</code> - location to put the context</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenDestroy()</code>, <code>MatCoarsenSetAdjacency()</code>, <code>MatCoarsenGetData()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenCreate.html"><code>Mat/MatCoarsenCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4131-L4150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><code>PETSc.LibPETSc.MatCoarsenDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenDestroy(petsclib::PetscLibType,agg::MatCoarsen)</code></pre><p>Destroys the coarsen context.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>agg</code> - the coarsen context</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenDestroy.html"><code>Mat/MatCoarsenDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3789-L3804">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenGetData-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{PETSc.LibPETSc._n_PetscCoarsenData}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenGetData-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{PETSc.LibPETSc._n_PetscCoarsenData}}"><code>PETSc.LibPETSc.MatCoarsenGetData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenGetData(petsclib::PetscLibType,coarser::MatCoarsen, llist::PetscCoarsenData)</code></pre><p>Gets the weights for vertices for a coarsener.</p><p>Logically Collective, No Fortran Support</p><p>Input Parameter:</p><ul><li><code>coarser</code> - the coarsen context</li></ul><p>Output Parameter:</p><ul><li><code>llist</code> - linked list of aggregates</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code>, <code>PetscCoarsenData</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenGetData.html"><code>Mat/MatCoarsenGetData</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3955-L3973">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenGetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenGetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><code>PETSc.LibPETSc.MatCoarsenGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type::MatCoarsenType = MatCoarsenGetType(petsclib::PetscLibType,coarsen::MatCoarsen)</code></pre><p>Gets the Coarsen method type and name (as a string) from the coarsen context.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>coarsen</code> - the coarsen context</li></ul><p>Output Parameter:</p><ul><li><code>type</code> - coarsener type</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenType</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenRegister()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenGetType.html"><code>Mat/MatCoarsenGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3651-L3670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenMISKGetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenMISKGetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><code>PETSc.LibPETSc.MatCoarsenMISKGetDistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">k::PetscInt = MatCoarsenMISKGetDistance(petsclib::PetscLibType,crs::MatCoarsen)</code></pre><p>gets the distance to be used by MISK</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>crs</code> - the coarsen</li></ul><p>Output Parameter:</p><ul><li><code>k</code> - the distance</li></ul><p>Level: advanced</p><p>-seealso: <code>MATCOARSENMISK</code>, <code>MatCoarsen</code>, <code>MatCoarsenSetFromOptions()</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenRegister()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenDestroy()</code>, <code>MatCoarsenSetAdjacency()</code>, <code>MatCoarsenGetData()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenMISKGetDistance.html"><code>Mat/MatCoarsenMISKGetDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4205-L4225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenMISKSetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenMISKSetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64}"><code>PETSc.LibPETSc.MatCoarsenMISKSetDistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenMISKSetDistance(petsclib::PetscLibType,crs::MatCoarsen, k::PetscInt)</code></pre><p>the distance to be used by MISK</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>crs</code> - the coarsen</li><li><code>k</code>   - the distance</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_misk_distance &lt;k&gt;</code> - distance for MIS</li></ul><p>Level: advanced</p><p>-seealso: <code>MATCOARSENMISK</code>, <code>MatCoarsen</code>, <code>MatCoarsenSetFromOptions()</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenRegister()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenDestroy()</code>, <code>MatCoarsenSetAdjacency()</code>, <code>MatCoarsenMISKGetDistance()</code> <code>MatCoarsenGetData()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenMISKSetDistance.html"><code>Mat/MatCoarsenMISKSetDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4168-L4189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatCoarsenRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenRegister(petsclib::PetscLibType,sname::String, fnc::external)</code></pre><p>Adds a new sparse matrix coarsening algorithm to the matrix package.</p><p>Logically Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of coarsen (for example <code>MATCOARSENMIS</code>)</li><li><code>function</code> - function pointer that creates the coarsen type</li></ul><p>Level: developer</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenRegisterDestroy()</code>, <code>MatCoarsenRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenRegister.html"><code>Mat/MatCoarsenRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3619-L3635">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetAdjacency-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetAdjacency-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatCoarsenSetAdjacency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetAdjacency(petsclib::PetscLibType,agg::MatCoarsen, adj::PetscMat)</code></pre><p>Sets the adjacency graph (matrix) of the thing to be coarsened.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>agg</code> - the coarsen context</li><li><code>adj</code> - the adjacency matrix</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenSetFromOptions()</code>, <code>Mat</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetAdjacency.html"><code>Mat/MatCoarsenSetAdjacency</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3725-L3741">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}}"><code>PETSc.LibPETSc.MatCoarsenSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetFromOptions(petsclib::PetscLibType,coarser::MatCoarsen)</code></pre><p>Sets various coarsen options from the options database.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>coarser</code> - the coarsen context.</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_type  &lt;type&gt;</code>                                                       - mis: maximal independent set based; misk: distance k MIS; hem: heavy edge matching</li><li><code>-mat_coarsen_max_it &lt;its&gt; number of iterations to use in the coarsening process</code> - see <code>MatCoarsenSetMaximumIterations()</code></li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code>, <code>MatCoarsenSetMaximumIterations()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetFromOptions.html"><code>Mat/MatCoarsenSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3989-L4009">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetGreedyOrdering-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetGreedyOrdering-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatCoarsenSetGreedyOrdering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetGreedyOrdering(petsclib::PetscLibType,coarser::MatCoarsen, perm::IS)</code></pre><p>Sets the ordering of the vertices to use with a greedy coarsening method</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>coarser</code> - the coarsen context</li><li><code>perm</code>    - vertex ordering of (greedy) algorithm</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetGreedyOrdering.html"><code>Mat/MatCoarsenSetGreedyOrdering</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3923-L3939">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetMaximumIterations-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetMaximumIterations-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64}"><code>PETSc.LibPETSc.MatCoarsenSetMaximumIterations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetMaximumIterations(petsclib::PetscLibType,coarse::MatCoarsen, n::PetscInt)</code></pre><p>Maximum <code>MATCOARSENHEM</code> iterations to use</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>coarse</code> - the coarsen context</li><li><code>n</code>      - number of HEM iterations</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_max_it &lt;default=4&gt;</code> - Maximum <code>MATCOARSENHEM</code> iterations to use</li></ul><p>Level: intermediate</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetMaximumIterations.html"><code>Mat/MatCoarsenSetMaximumIterations</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4025-L4044">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetStrengthIndex-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetStrengthIndex-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Int64, Vector{Int64}}"><code>PETSc.LibPETSc.MatCoarsenSetStrengthIndex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetStrengthIndex(petsclib::PetscLibType,coarse::MatCoarsen, n::PetscInt, idx::Vector{PetscInt})</code></pre><p>Index array to use for index to use for strength of connection</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>coarse</code> - the coarsen context</li><li><code>n</code>      - number of indices</li><li><code>idx</code>    - array of indices</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_strength_index</code> - array of subset of variables per vertex to use for strength norm, -1 for using all (default)</li></ul><p>Level: intermediate</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetStrengthIndex.html"><code>Mat/MatCoarsenSetStrengthIndex</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4060-L4080">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetStrictAggs-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetStrictAggs-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatCoarsenSetStrictAggs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetStrictAggs(petsclib::PetscLibType,agg::MatCoarsen, str::PetscBool)</code></pre><p>Set whether to keep strict (non overlapping) aggregates in the linked list of aggregates for a coarsen context</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>agg</code> - the coarsen context</li><li><code>str</code> - <code>PETSC_TRUE</code> keep strict aggregates, <code>PETSC_FALSE</code> allow overlap</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetFromOptions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetStrictAggs.html"><code>Mat/MatCoarsenSetStrictAggs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3757-L3773">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetThreshold-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetThreshold-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Float64}"><code>PETSc.LibPETSc.MatCoarsenSetThreshold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetThreshold(petsclib::PetscLibType,coarse::MatCoarsen, b::PetscReal)</code></pre><p>Set the threshold for HEM</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>coarse</code> - the coarsen context</li><li><code>b</code>      - threshold value</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_threshold &lt;-1&gt;</code> - threshold</li></ul><p>Level: intermediate</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenType</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetThreshold.html"><code>Mat/MatCoarsenSetThreshold</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L4096-L4115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Int8}}"><code>PETSc.LibPETSc.MatCoarsenSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenSetType(petsclib::PetscLibType,coarser::MatCoarsen, type::MatCoarsenType)</code></pre><p>Sets the type of aggregator to use</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>coarser</code> - the coarsen context.</li><li><code>type</code>    - a known coarsening method</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_type  &lt;type&gt;</code> - maximal independent set based; distance k MIS; heavy edge matching</li></ul><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenCreate()</code>, <code>MatCoarsenApply()</code>, <code>MatCoarsenType</code>, <code>MatCoarsenGetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenSetType.html"><code>Mat/MatCoarsenSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3888-L3907">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatCoarsenView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenView(petsclib::PetscLibType,agg::MatCoarsen, viewer::PetscViewer)</code></pre><p>Prints the coarsen data structure.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>agg</code>    - the coarsen context</li><li><code>viewer</code> - optional visualization context</li></ul><p>For viewing the options database see <code>MatCoarsenViewFromOptions()</code></p><p>Level: advanced</p><p>-seealso: <code>MatCoarsen</code>, <code>PetscViewer</code>, <code>PetscViewerASCIIOpen()</code>, <code>MatCoarsenViewFromOptions</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenView.html"><code>Mat/MatCoarsenView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3854-L3872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatCoarsenViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Nothing}, String}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatCoarsenViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatCoarsen}, Ptr{Nothing}, String}"><code>PETSc.LibPETSc.MatCoarsenViewFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatCoarsenViewFromOptions(petsclib::PetscLibType,A::MatCoarsen, obj::PetscObject, name::String)</code></pre><p>View the coarsener from the options database</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the coarsen context</li><li><code>obj</code>  - Optional object that provides the prefix for the option name</li><li><code>name</code> - command line option (usually <code>-mat_coarsen_view</code>)</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coarsen_view [viewertype]:...</code> - the viewer and its options</li></ul><p>-seealso: <code>MatCoarsen</code>, <code>MatCoarsenView</code>, <code>PetscObjectViewFromOptions()</code>, <code>MatCoarsenCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatCoarsenViewFromOptions.html"><code>Mat/MatCoarsenViewFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3820-L3838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{PETSc.LibPETSc._n_ISColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{PETSc.LibPETSc._n_ISColoring}}"><code>PETSc.LibPETSc.MatColoringApply</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringApply(petsclib::PetscLibType,mc::MatColoring, coloring::ISColoring)</code></pre><p>Apply the coloring to the matrix, producing index sets corresponding to a number of independent sets in the induced graph.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mc</code> - the <code>MatColoring</code> context</li></ul><p>Output Parameter:</p><ul><li><code>coloring</code> - the <code>ISColoring</code> instance containing the coloring</li></ul><p>Level: beginner</p><p>-seealso: <code>ISColoring</code>, <code>MatColoring</code>, <code>MatColoringCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringApply.html"><code>Mat/MatColoringApply</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L388-L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatColoringCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mcptr::MatColoring = MatColoringCreate(petsclib::PetscLibType,m::PetscMat)</code></pre><p>Creates a matrix coloring context.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>m</code> - a <code>Mat</code> from which a coloring is derived</li></ul><p>Output Parameter:</p><ul><li><code>mcptr</code> - the new <code>MatColoring</code> context</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_coloring_type</code>      - the type of coloring algorithm used. See <code>MatColoringType</code>.</li><li><code>-mat_coloring_maxcolors</code> - the maximum number of relevant colors, all nodes not in a color are in maxcolors+1</li><li><code>-mat_coloring_distance</code>  - compute a distance 1,2,... coloring.</li><li><code>-mat_coloring_view</code>      - print information about the coloring and the produced index sets</li><li><code>-mat_coloring_test</code>      - debugging option that prints all coloring incompatibilities</li><li><code>-mat_is_coloring_test</code>   - debugging option that throws an error if MatColoringApply() generates an incorrect iscoloring</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoringSetFromOptions()</code>, <code>MatColoring</code>, <code>MatColoringApply()</code>, <code>MatFDColoringCreate()</code>, <code>DMCreateColoring()</code>, <code>MatColoringType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringCreate.html"><code>Mat/MatColoringCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L100-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringCreateWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Float64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringCreateWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Float64, Int64}"><code>PETSc.LibPETSc.MatColoringCreateWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringCreateWeights(petsclib::PetscLibType,mc::MatColoring, weights::PetscReal, lperm::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringCreateWeights.html"><code>Mat/MatColoringCreateWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L511-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><code>PETSc.LibPETSc.MatColoringDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringDestroy(petsclib::PetscLibType,mc::MatColoring)</code></pre><p>Destroys the matrix coloring context</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mc</code> - the <code>MatColoring</code> context</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringCreate()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringDestroy.html"><code>Mat/MatColoringDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L144-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringGetDegrees-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringGetDegrees-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatColoringGetDegrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degrees::PetscInt = MatColoringGetDegrees(petsclib::PetscLibType,G::PetscMat, distance::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringGetDegrees.html"><code>Mat/MatColoringGetDegrees</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L488-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringGetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringGetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><code>PETSc.LibPETSc.MatColoringGetDistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dist::PetscInt = MatColoringGetDistance(petsclib::PetscLibType,mc::MatColoring)</code></pre><p>Gets the distance of the coloring</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mc</code> - the <code>MatColoring</code> context</li></ul><p>Output Parameter:</p><ul><li><code>dist</code> - the current distance being used for the coloring.</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringSetDistance()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringGetDistance.html"><code>Mat/MatColoringGetDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L284-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringGetMaxColors-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringGetMaxColors-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><code>PETSc.LibPETSc.MatColoringGetMaxColors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxcolors::PetscInt = MatColoringGetMaxColors(petsclib::PetscLibType,mc::MatColoring)</code></pre><p>Gets the maximum number of colors</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>mc</code> - the <code>MatColoring</code> context</li></ul><p>Output Parameter:</p><ul><li><code>maxcolors</code> - the current maximum number of colors to produce</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringSetMaxColors()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringGetMaxColors.html"><code>Mat/MatColoringGetMaxColors</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L352-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringPatch-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Ptr{PETSc.LibPETSc._n_ISColoringValue}}, Ptr{PETSc.LibPETSc._n_ISColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringPatch-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64, Int64, Vector{Ptr{PETSc.LibPETSc._n_ISColoringValue}}, Ptr{PETSc.LibPETSc._n_ISColoring}}"><code>PETSc.LibPETSc.MatColoringPatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringPatch(petsclib::PetscLibType,mat::PetscMat, ncolors::PetscInt, n::PetscInt, colorarray::Vector{ISColoringValue}, iscoloring::ISColoring)</code></pre><p>Used inside matrix coloring routines that use <code>MatGetRowIJ()</code> and/or <code>MatGetColumnIJ()</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>        - the matrix</li><li><code>ncolors</code>    - maximum color value</li><li><code>n</code>          - number of entries in colorarray</li><li><code>colorarray</code> - array indicating color for each column</li></ul><p>Output Parameter:</p><ul><li><code>iscoloring</code> - coloring generated using colorarray information</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatGetRowIJ()</code>, <code>MatGetColumnIJ()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringPatch.html"><code>Mat/MatColoringPatch</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L30-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatColoringRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringRegister(petsclib::PetscLibType,sname::String, fnc::external)</code></pre><p>Adds a new sparse matrix coloring to the  matrix package.</p><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of Coloring (for example <code>MATCOLORINGSL</code>)</li><li><code>function</code> - function pointer that creates the coloring</li></ul><p>Level: developer</p><p>-seealso: <code>MatColoringType</code>, <code>MatColoringRegisterDestroy()</code>, <code>MatColoringRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringRegister.html"><code>Mat/MatColoringRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L68-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetDistance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Int64}"><code>PETSc.LibPETSc.MatColoringSetDistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringSetDistance(petsclib::PetscLibType,mc::MatColoring, dist::PetscInt)</code></pre><p>Sets the distance of the coloring</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mc</code>   - the <code>MatColoring</code> context</li><li><code>dist</code> - the distance the coloring should compute</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coloring_type</code> - the type of coloring algorithm used. See <code>MatColoringType</code>.</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringSetFromOptions()</code>, <code>MatColoringGetDistance()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetDistance.html"><code>Mat/MatColoringSetDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L249-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><code>PETSc.LibPETSc.MatColoringSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringSetFromOptions(petsclib::PetscLibType,mc::MatColoring)</code></pre><p>Sets <code>MatColoring</code> options from options database</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>mc</code> - <code>MatColoring</code> context</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_coloring_type</code>      - the type of coloring algorithm used. See <code>MatColoringType</code>.</li><li><code>-mat_coloring_maxcolors</code> - the maximum number of relevant colors, all nodes not in a color are in maxcolors+1</li><li><code>-mat_coloring_distance</code>  - compute a distance 1,2,... coloring.</li><li><code>-mat_coloring_view</code>      - print information about the coloring and the produced index sets</li><li><code>-snes_fd_color</code>          - instruct SNES to using coloring and then <code>MatFDColoring</code> to compute the Jacobians</li><li><code>-snes_fd_color_use_mat</code>  - instruct <code>SNES</code> to color the matrix directly instead of the <code>DM</code> from which the matrix comes (the default)</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringApply()</code>, <code>MatColoringSetDistance()</code>, <code>MatColoringSetType()</code>, <code>SNESComputeJacobianDefaultColor()</code>, <code>MatColoringType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetFromOptions.html"><code>Mat/MatColoringSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L210-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetMaxColors-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetMaxColors-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Int64}"><code>PETSc.LibPETSc.MatColoringSetMaxColors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringSetMaxColors(petsclib::PetscLibType,mc::MatColoring, maxcolors::PetscInt)</code></pre><p>Sets the maximum number of colors to produce</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mc</code>        - the <code>MatColoring</code> context</li><li><code>maxcolors</code> - the maximum number of colors to produce</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringGetMaxColors()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetMaxColors.html"><code>Mat/MatColoringSetMaxColors</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L320-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{Int8}}"><code>PETSc.LibPETSc.MatColoringSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringSetType(petsclib::PetscLibType,mc::MatColoring, type::MatColoringType)</code></pre><p>Sets the type of coloring algorithm used</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mc</code>   - the <code>MatColoring</code> context</li><li><code>type</code> - the type of coloring</li></ul><p>Options Database Key:</p><ul><li><code>-mat_coloring_type type</code> - the name of the type</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringSetFromOptions()</code>, <code>MatColoringType</code>, <code>MatColoringCreate()</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetType.html"><code>Mat/MatColoringSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L175-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetWeightType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, PETSc.LibPETSc.MatColoringWeightType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetWeightType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, PETSc.LibPETSc.MatColoringWeightType}"><code>PETSc.LibPETSc.MatColoringSetWeightType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringSetWeightType(petsclib::PetscLibType,mc::MatColoring, wt::MatColoringWeightType)</code></pre><p>Set the type of weight computation used while computing the coloring</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mc</code> - the <code>MatColoring</code> context</li><li><code>wt</code> - the weight type</li></ul><p>Level: beginner</p><p>-seealso: <code>MatColoring</code>, <code>MatColoringWeightType</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetWeightType.html"><code>Mat/MatColoringSetWeightType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L456-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringSetWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringSetWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}}"><code>PETSc.LibPETSc.MatColoringSetWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weights::PetscReal,lperm::PetscInt = MatColoringSetWeights(petsclib::PetscLibType,mc::MatColoring)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringSetWeights.html"><code>Mat/MatColoringSetWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L532-L537">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatColoringView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatColoringView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatColoring}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatColoringView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatColoringView(petsclib::PetscLibType,mc::MatColoring, viewer::PetscViewer)</code></pre><p>Output details about the <code>MatColoring</code>.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mc</code>     - the <code>MatColoring</code> context</li><li><code>viewer</code> - the Viewer context</li></ul><p>Level: beginner</p><p>-seealso: <code>PetscViewer</code>, <code>MatColoring</code>, <code>MatColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatColoringView.html"><code>Mat/MatColoringView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L424-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringApply-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.PetscVec, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringApply-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.PetscVec, Nothing}"><code>PETSc.LibPETSc.MatFDColoringApply</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringApply(petsclib::PetscLibType,J::PetscMat, coloring::MatFDColoring, x1::PetscVec, sctx::Cvoid)</code></pre><p>Given a matrix for which a <code>MatFDColoring</code> context has been created, computes the Jacobian for a function via finite differences.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>J</code>        - matrix to store Jacobian entries into</li><li><code>coloring</code> - coloring context created with <code>MatFDColoringCreate()</code></li><li><code>x1</code>       - location at which Jacobian is to be computed</li><li><code>sctx</code>     - context required by function, if this is being used with the <code>SNES</code> solver then it is <code>SNES</code> object, otherwise it is <code>NULL</code></li></ul><p>Options Database Keys:</p><ul><li><code>-mat_fd_type</code>                       - &quot;wp&quot; or &quot;ds&quot;  (see <code>MATMFFD_WP</code> or <code>MATMFFD_DS</code>)</li><li><code>-mat_fd_coloring_view</code>              - Activates basic viewing or coloring</li><li><code>-mat_fd_coloring_view draw</code>         - Activates drawing of coloring</li><li><code>-mat_fd_coloring_view ::ascii_info</code> - Activates viewing of coloring info</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringDestroy()</code>, <code>MatFDColoringView()</code>, <code>MatFDColoringSetFunction()</code>, <code>MatFDColoringSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringApply.html"><code>Mat/MatFDColoringApply</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L953-L978">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}}"><code>PETSc.LibPETSc.MatFDColoringCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">color::MatFDColoring = MatFDColoringCreate(petsclib::PetscLibType,mat::PetscMat, iscoloring::ISColoring)</code></pre><p>Creates a matrix coloring context for finite difference computation of Jacobians.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>        - the matrix containing the nonzero structure of the Jacobian</li><li><code>iscoloring</code> - the coloring of the matrix; usually obtained with <code>MatColoringCreate()</code> or <code>DMCreateColoring()</code></li></ul><p>Output Parameter:</p><ul><li><code>color</code> - the new coloring context</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringDestroy()</code>, <code>SNESComputeJacobianDefaultColor()</code>, <code>ISColoringCreate()</code>, <code>MatFDColoringSetFunction()</code>, <code>MatFDColoringSetFromOptions()</code>, <code>MatFDColoringApply()</code>, <code>MatFDColoringView()</code>, <code>MatFDColoringSetParameters()</code>, <code>MatColoringCreate()</code>, <code>DMCreateColoring()</code>, <code>MatFDColoringSetValues()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringCreate.html"><code>Mat/MatFDColoringCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L841-L863">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><code>PETSc.LibPETSc.MatFDColoringDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringDestroy(petsclib::PetscLibType,c::MatFDColoring)</code></pre><p>Destroys a matrix coloring context that was created via <code>MatFDColoringCreate()</code>.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>c</code> - coloring context</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringDestroy.html"><code>Mat/MatFDColoringDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L881-L897">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringGetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.MatFDColoringFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringGetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.MatFDColoringFn, Nothing}"><code>PETSc.LibPETSc.MatFDColoringGetFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringGetFunction(petsclib::PetscLibType,matfd::MatFDColoring, f::MatFDColoringFn, fctx::Cvoid)</code></pre><p>Gets the function to use for computing the Jacobian.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>matfd</code> - the coloring context</li></ul><p>Output Parameters:</p><ul><li><code>f</code>    - the function, see <code>MatFDColoringFn</code> for the calling sequence</li><li><code>fctx</code> - the optional user-defined function context</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringSetFunction()</code>, <code>MatFDColoringSetFromOptions()</code>, <code>MatFDColoringFn</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringGetFunction.html"><code>Mat/MatFDColoringGetFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L710-L729">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringGetPerturbedColumns-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringGetPerturbedColumns-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><code>PETSc.LibPETSc.MatFDColoringGetPerturbedColumns</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n::PetscInt,cols::Vector{PetscInt} = MatFDColoringGetPerturbedColumns(petsclib::PetscLibType,coloring::MatFDColoring)</code></pre><p>Returns the indices of the columns that that are currently being perturbed.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>coloring</code> - coloring context created with <code>MatFDColoringCreate()</code></li></ul><p>Output Parameters:</p><ul><li><code>n</code>    - the number of local columns being perturbed</li><li><code>cols</code> - the column indices, in global numbering</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringDestroy()</code>, <code>MatFDColoringView()</code>, <code>MatFDColoringApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringGetPerturbedColumns.html"><code>Mat/MatFDColoringGetPerturbedColumns</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L913-L933">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Int64, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetBlockSize-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Int64, Int64}"><code>PETSc.LibPETSc.MatFDColoringSetBlockSize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetBlockSize(petsclib::PetscLibType,matfd::MatFDColoring, brows::PetscInt, bcols::PetscInt)</code></pre><p>Sets block size for efficient inserting entries of Jacobian matrix.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>matfd</code> - the coloring context</li><li><code>brows</code> - number of rows in the block</li><li><code>bcols</code> - number of columns in the block</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringSetFromOptions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetBlockSize.html"><code>Mat/MatFDColoringSetBlockSize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L644-L661">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetF-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetF-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatFDColoringSetF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetF(petsclib::PetscLibType,fd::MatFDColoring, F::PetscVec)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetF.html"><code>Mat/MatFDColoringSetF</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L557-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><code>PETSc.LibPETSc.MatFDColoringSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetFromOptions(petsclib::PetscLibType,matfd::MatFDColoring)</code></pre><p>Sets coloring finite difference parameters from the options database.</p><p>Collective</p><p>The Jacobian, F&#39;(u), is estimated with the differencing approximation -seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringView()</code>, <code>MatFDColoringSetParameters()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetFromOptions.html"><code>Mat/MatFDColoringSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L778-L790">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.MatFDColoringFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, PETSc.LibPETSc.MatFDColoringFn, Nothing}"><code>PETSc.LibPETSc.MatFDColoringSetFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetFunction(petsclib::PetscLibType,matfd::MatFDColoring, f::MatFDColoringFn, fctx::Cvoid)</code></pre><p>Sets the function to use for computing the Jacobian.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>matfd</code> - the coloring context</li><li><code>f</code>     - the function, see <code>MatFDColoringFn</code> for the calling sequence</li><li><code>fctx</code>  - the optional user-defined function context</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringGetFunction()</code>, <code>MatFDColoringSetFromOptions()</code>, <code>MatFDColoringFn</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetFunction.html"><code>Mat/MatFDColoringSetFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L745-L762">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetParameters-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Float64, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetParameters-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Float64, Float64}"><code>PETSc.LibPETSc.MatFDColoringSetParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetParameters(petsclib::PetscLibType,matfd::MatFDColoring, error::PetscReal, umin::PetscReal)</code></pre><p>Sets the parameters for the approximation of a sparse Jacobian matrix using finite differences and matrix coloring</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>matfd</code> - the coloring context</li><li><code>error</code> - relative error</li><li><code>umin</code>  - minimum allowable u-value magnitude</li></ul><p>Level: advanced</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringSetFromOptions()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetParameters.html"><code>Mat/MatFDColoringSetParameters</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L610-L628">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Ptr{Int8}}"><code>PETSc.LibPETSc.MatFDColoringSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetType(petsclib::PetscLibType,matfd::MatFDColoring, type::MatMFFDType)</code></pre><p>Sets the approach for computing the finite difference parameter</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>matfd</code> - the coloring context</li><li><code>type</code>  - either <code>MATMFFD_WP</code> or <code>MATMFFD_DS</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_fd_type</code> - &quot;wp&quot; or &quot;ds&quot;</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringView()</code>, <code>MatFDColoringSetParameters()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetType.html"><code>Mat/MatFDColoringSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L806-L825">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetUp-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetUp-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><code>PETSc.LibPETSc.MatFDColoringSetUp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetUp(petsclib::PetscLibType,mat::PetscMat, iscoloring::ISColoring, color::MatFDColoring)</code></pre><p>Sets up the internal data structures of matrix coloring context for the later use.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>        - the matrix containing the nonzero structure of the Jacobian</li><li><code>iscoloring</code> - the coloring of the matrix; usually obtained with <code>MatGetColoring()</code> or <code>DMCreateColoring()</code></li><li><code>color</code>      - the matrix coloring context</li></ul><p>Level: beginner</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>MatFDColoringDestroy()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetUp.html"><code>Mat/MatFDColoringSetUp</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L677-L694">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringSetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringSetValues-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Vector{Float64}}"><code>PETSc.LibPETSc.MatFDColoringSetValues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringSetValues(petsclib::PetscLibType,J::PetscMat, coloring::MatFDColoring, y::Vector{PetscScalar})</code></pre><p>takes a matrix in compressed color format and enters the matrix into a PETSc <code>Mat</code></p><p>Collective</p><p>Input Parameters:</p><ul><li><code>J</code>        - the sparse matrix</li><li><code>coloring</code> - created with <code>MatFDColoringCreate()</code> and a local coloring</li><li><code>y</code>        - column major storage of matrix values with one color of values per column, the number of rows of <code>y</code> should match</li></ul><p>the number of local rows of <code>J</code> and the number of columns is the number of colors.</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatFDColoringCreate()</code>, <code>ISColoring</code>, <code>ISColoringCreate()</code>, <code>ISColoringSetType()</code>, <code>IS_COLORING_LOCAL</code>, <code>MatFDColoringSetBlockSize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringSetValues.html"><code>Mat/MatFDColoringSetValues</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L994-L1012">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringUseDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringUseDM-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_MatFDColoring}}"><code>PETSc.LibPETSc.MatFDColoringUseDM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringUseDM(petsclib::PetscLibType,coloring::PetscMat, fdcoloring::MatFDColoring)</code></pre><p>allows a <code>MatFDColoring</code> object to use the <code>DM</code> associated with the matrix to compute a <code>IS_COLORING_LOCAL</code> coloring</p><p>Input Parameters:</p><ul><li><code>coloring</code>   - The matrix to get the <code>DM</code> from</li><li><code>fdcoloring</code> - the <code>MatFDColoring</code> object</li></ul><p>Level: advanced</p><p>Developer Note: This routine exists because the PETSc <code>Mat</code> library does not know about the <code>DM</code> objects</p><p><strong>See also:</strong></p><p><code>DM</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code>, <code>ISColoringType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Dm/MatFDColoringUseDM.html"><code>Dm/MatFDColoringUseDM</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1028-L1047">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatFDColoringView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatFDColoringView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatFDColoring}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatFDColoringView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatFDColoringView(petsclib::PetscLibType,c::MatFDColoring, viewer::PetscViewer)</code></pre><p>Views a finite difference coloring context.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>c</code>      - the coloring context</li><li><code>viewer</code> - visualization context</li></ul><p>Level: intermediate</p><p>-seealso: <code>Mat</code>, <code>MatFDColoring</code>, <code>MatFDColoringCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatFDColoringView.html"><code>Mat/MatFDColoringView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L578-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDCheckPositivity-Tuple{PETSc.LibPETSc.PetscLibType, Nothing, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDCheckPositivity-Tuple{PETSc.LibPETSc.PetscLibType, Nothing, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec, Float64}"><code>PETSc.LibPETSc.MatMFFDCheckPositivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDCheckPositivity(petsclib::PetscLibType,dummy::Cvoid, U::PetscVec, a::PetscVec, h::PetscScalar)</code></pre><p>Checks that all entries in U + h*a  are positive or zero, decreases <code>h</code> until this is satisfied for a <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>dummy</code> - context variable (unused)</li><li><code>U</code>     - base vector that is added to</li><li><code>a</code>     - vector that is added</li><li><code>h</code>     - scaling factor on <code>a</code>, may be changed on output</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_mffd_check_positivity &lt;bool&gt;</code> - Ensure that U + h*a is nonnegative</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDSetCheckh()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDCheckPositivity.html"><code>Mat/MatMFFDCheckPositivity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3508-L3530">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDComputeJacobian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDComputeJacobian-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscSNES, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscMat, Nothing}"><code>PETSc.LibPETSc.MatMFFDComputeJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDComputeJacobian(petsclib::PetscLibType,snes::PetscSNES, x::PetscVec, jac::PetscMat, B::PetscMat, dummy::Cvoid)</code></pre><p>Tells the matrix Jacobian matrix-vector products will be computed at, i.e. J(x) * a. The x is obtained from the <code>SNES</code> object (using <code>SNESGetSolution()</code>).</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>snes</code>  - the nonlinear solver context</li><li><code>x</code>     - the point at which the Jacobian-vector products will be performed</li><li><code>jac</code>   - the matrix-free Jacobian object of <code>MatType</code> <code>MATMFFD</code>, likely obtained with <code>MatCreateSNESMF()</code></li><li><code>B</code>     - either the same as <code>jac</code> or another matrix type (ignored)</li><li><code>dummy</code> - the user context (ignored)</li></ul><p>Options Database Key:</p><ul><li><code>-snes_mf</code> - use the matrix created with <code>MatSNESMFCreate()</code> to setup the Jacobian for each new solution in the Newton process</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_snes"></a>, <code>MatMFFDGetH()</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDSetBase()</code>, <code>MatCreateMFFD()</code>, <code>MATMFFD</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDSetFunctionError()</code>, <code>SNESSetJacobian()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Snes/MatMFFDComputeJacobian.html"><code>Snes/MatMFFDComputeJacobian</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3578-L3603">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDDSSetUmin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDDSSetUmin-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatMFFDDSSetUmin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDDSSetUmin(petsclib::PetscLibType,A::PetscMat, umin::PetscReal)</code></pre><p>Sets the &quot;umin&quot; parameter used by the PETSc routine for computing the differencing parameter, h, which is used for matrix-free Jacobian-vector products for a <code>MATMFFD</code> matrix.</p><p>Input Parameters:</p><ul><li><code>A</code>    - the <code>MATMFFD</code> matrix</li><li><code>umin</code> - the parameter</li></ul><p>Level: advanced</p><p>-seealso: <code>MATMFFD</code>, <code>MatMFFDSetFunctionError()</code>, <code>MatCreateSNESMF()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDDSSetUmin.html"><code>Mat/MatMFFDDSSetUmin</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3546-L3562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDFinalizePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDFinalizePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><code>PETSc.LibPETSc.MatMFFDFinalizePackage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDFinalizePackage(petsclib::PetscLibType)</code></pre><p>This function destroys everything in the MATMFFD<code>package. It is called from</code>PetscFinalize()`.</p><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>PetscFinalize()</code>, <code>MatCreateMFFD()</code>, <code>MatCreateSNESMF()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDFinalizePackage.html"><code>Mat/MatMFFDFinalizePackage</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3012-L3023">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDGetH-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDGetH-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMFFDGetH</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">h::PetscScalar = MatMFFDGetH(petsclib::PetscLibType,mat::PetscMat)</code></pre><p>Gets the last value that was used as the differencing for a <code>MATMFFD</code> matrix parameter.</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>mat</code> - the <code>MATMFFD</code> matrix</li></ul><p>Output Parameter:</p><ul><li><code>h</code> - the differencing step size</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatCreateMFFD()</code>, <code>MatMFFDResetHHistory()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDGetH.html"><code>Mat/MatMFFDGetH</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3159-L3178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDInitializePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDInitializePackage-Tuple{PETSc.LibPETSc.PetscLibType}"><code>PETSc.LibPETSc.MatMFFDInitializePackage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDInitializePackage(petsclib::PetscLibType)</code></pre><p>This function initializes everything in the MATMFFD<code>package. It is called from</code>MatInitializePackage()`.</p><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>PetscInitialize()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDInitializePackage.html"><code>Mat/MatMFFDInitializePackage</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3038-L3049">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatMFFDRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDRegister(petsclib::PetscLibType,sname::String, fnc::external)</code></pre><p>Adds a method to the <code>MATMFFD</code> registry.</p><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of a new user-defined compute-h module</li><li><code>function</code> - routine to create method context</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDRegisterAll()</code>, <code>MatMFFDRegisterDestroy()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDRegister.html"><code>Mat/MatMFFDRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3096-L3112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDResetHHistory-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDResetHHistory-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatMFFDResetHHistory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDResetHHistory(petsclib::PetscLibType,J::PetscMat)</code></pre><p>Resets the counter to zero to begin collecting a new set of differencing histories for the <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>J</code> - the matrix-free matrix context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDGetH()</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDSetFunctionError()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDResetHHistory.html"><code>Mat/MatMFFDResetHHistory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3404-L3421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscVec, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatMFFDSetBase</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetBase(petsclib::PetscLibType,J::PetscMat, U::PetscVec, F::PetscVec)</code></pre><p>Sets the vector <code>U</code> at which matrix vector products of the Jacobian are computed for the <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>J</code> - the <code>MATMFFD</code> matrix</li><li><code>U</code> - the vector</li><li><code>F</code> - (optional) vector that contains F(u) if it has been already computed</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMult()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetBase.html"><code>Mat/MatMFFDSetBase</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3437-L3455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetCheckh-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDCheckhFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetCheckh-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDCheckhFn, Nothing}"><code>PETSc.LibPETSc.MatMFFDSetCheckh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetCheckh(petsclib::PetscLibType,J::PetscMat, fun::MatMFFDCheckhFn, ctx::Cvoid)</code></pre><p>Sets a function that checks the computed <code>h</code> and adjusts it to satisfy some criteria for the <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>J</code>   - the <code>MATMFFD</code> matrix</li><li><code>fun</code> - the function that checks <code>h</code>, see <code>MatMFFDCheckhFn</code></li><li><code>ctx</code> - any context needed by the function</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_mffd_check_positivity &lt;bool&gt;</code> - Ensure that U + h*a  is non-negative</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDCheckhFn</code>, <code>MatMFFDCheckPositivity()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetCheckh.html"><code>Mat/MatMFFDSetCheckh</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3471-L3492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDFn, Nothing}"><code>PETSc.LibPETSc.MatMFFDSetFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetFunction(petsclib::PetscLibType,mat::PetscMat, func::MatMFFDFn, funcctx::Cvoid)</code></pre><p>Sets the function used in applying the matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>     - the matrix-free matrix <code>MATMFFD</code> created via <code>MatCreateSNESMF()</code> or <code>MatCreateMFFD()</code></li><li><code>func</code>    - the function to use</li><li><code>funcctx</code> - optional function context passed to function</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDFn</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDGetH()</code>, <code>MatCreateMFFD()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code>, <code>SNESSetFunction()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetFunction.html"><code>Mat/MatMFFDSetFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3196-L3214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetFunctionError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetFunctionError-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Float64}"><code>PETSc.LibPETSc.MatMFFDSetFunctionError</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetFunctionError(petsclib::PetscLibType,mat::PetscMat, error::PetscReal)</code></pre><p>Sets the error_rel for the approximation of matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the <code>MATMFFD</code> matrix-free matrix</li><li><code>error</code> - relative error (should be set to the square root of the relative error in the function evaluations)</li></ul><p>Options Database Key:</p><ul><li><code>-mat_mffd_err &lt;error_rel&gt;</code> - Sets error_rel</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDGetH()</code>, <code>MatCreateMFFD()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetFunctionError.html"><code>Mat/MatMFFDSetFunctionError</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3332-L3352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetFunctioni-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDiFn}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetFunctioni-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDiFn}"><code>PETSc.LibPETSc.MatMFFDSetFunctioni</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetFunctioni(petsclib::PetscLibType,mat::PetscMat, funci::MatMFFDiFn)</code></pre><p>Sets the function for computing a single component for a <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the matrix-free matrix <code>MATMFFD</code></li><li><code>funci</code> - the function to use</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDiFn</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDGetH()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code>, <code>SNESSetFunction()</code>, <code>MatGetDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetFunctioni.html"><code>Mat/MatMFFDSetFunctioni</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3230-L3247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetFunctioniBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDiBaseFn}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetFunctioniBase-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.MatMFFDiBaseFn}"><code>PETSc.LibPETSc.MatMFFDSetFunctioniBase</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetFunctioniBase(petsclib::PetscLibType,mat::PetscMat, func::MatMFFDiBaseFn)</code></pre><p>Sets the function to compute the base vector for a single component function evaluation for a <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>  - the <code>MATMFFD</code> matrix-free matrix</li><li><code>func</code> - the function to use</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDGetH()</code>, <code>MatCreateMFFD()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code>, <code>SNESSetFunction()</code>, <code>MatGetDiagonal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetFunctioniBase.html"><code>Mat/MatMFFDSetFunctioniBase</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3263-L3280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetHHistory-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetHHistory-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Vector{Float64}, Int64}"><code>PETSc.LibPETSc.MatMFFDSetHHistory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetHHistory(petsclib::PetscLibType,J::PetscMat, history::Vector{PetscScalar}, nhistory::PetscInt)</code></pre><p>Sets an array to collect a history of the differencing values (h) computed for the matrix-free product <code>MATMFFD</code> matrix</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>J</code>        - the <code>MATMFFD</code> matrix-free matrix</li><li><code>history</code>  - space to hold the history</li><li><code>nhistory</code> - number of entries in history, if more entries are generated than</li></ul><p>nhistory, then the later ones are discarded</p><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatMFFDGetH()</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDResetHHistory()</code>, <code>MatMFFDSetFunctionError()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetHHistory.html"><code>Mat/MatMFFDSetHHistory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3368-L3388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, String}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetOptionsPrefix-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, String}"><code>PETSc.LibPETSc.MatMFFDSetOptionsPrefix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetOptionsPrefix(petsclib::PetscLibType,mat::PetscMat, prefix::String)</code></pre><p>Sets the prefix used for searching for all MATMFFD` options in the database.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the <code>MATMFFD</code> context</li><li><code>prefix</code> - the prefix to prepend to all option names</li></ul><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatSetFromOptions()</code>, <code>MatCreateSNESMF()</code>, <code>MatCreateMFFD()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetOptionsPrefix.html"><code>Mat/MatMFFDSetOptionsPrefix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3128-L3143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetPeriod-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetPeriod-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Int64}"><code>PETSc.LibPETSc.MatMFFDSetPeriod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetPeriod(petsclib::PetscLibType,mat::PetscMat, period::PetscInt)</code></pre><p>Sets how often the step</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>    - the <code>MATMFFD</code> matrix-free matrix</li><li><code>period</code> - 1 for every time, 2 for every second etc</li></ul><p>Options Database Key:</p><ul><li><code>-mat_mffd_period &lt;period&gt;</code> - Sets how often <code>h</code> is recomputed</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDGetH()</code>, <code>MatMFFDSetHHistory()</code>, <code>MatMFFDResetHHistory()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetPeriod.html"><code>Mat/MatMFFDSetPeriod</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3296-L3316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDSetType-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{Int8}}"><code>PETSc.LibPETSc.MatMFFDSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDSetType(petsclib::PetscLibType,mat::PetscMat, ftype::MatMFFDType)</code></pre><p>Sets the method that is used to compute the differencing parameter for finite difference matrix-free formulations.</p><p>Input Parameters:</p><ul><li><code>mat</code>   - the &quot;matrix-free&quot; matrix created via <code>MatCreateSNESMF()</code>, or <code>MatCreateMFFD()</code></li></ul><p>or <code>MatSetType</code>(mat,<code>MATMFFD</code>);</p><ul><li><code>ftype</code> - the type requested, either <code>MATMFFD_WP</code> or <code>MATMFFD_DS</code></li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MATMFFD</code>, <code>MATMFFD_WP</code>, <code>MATMFFD_DS</code>, <code>MatCreateSNESMF()</code>, <code>MatMFFDRegister()</code>, <code>MatMFFDSetFunction()</code>, <code>MatCreateMFFD()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDSetType.html"><code>Mat/MatMFFDSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L3064-L3080">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatMFFDWPSetComputeNormU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatMFFDWPSetComputeNormU-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatMFFDWPSetComputeNormU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatMFFDWPSetComputeNormU(petsclib::PetscLibType,A::PetscMat, flag::PetscBool)</code></pre><p>Sets whether it computes the ||U|| used by the Walker PETSc routine for computing h. With any Krylov solver this need only be computed during the first iteration and kept for later.</p><p>Input Parameters:</p><ul><li><code>A</code>    - the <code>MATMFFD</code> matrix</li><li><code>flag</code> - <code>PETSC_TRUE</code> causes it to compute ||U||, <code>PETSC_FALSE</code> uses the previous value</li></ul><p>Options Database Key:</p><ul><li><code>-mat_mffd_compute_normu &lt;true,false&gt;</code> - true by default, false can save calculations but you</li></ul><p>must be sure that ||U|| has not changed in the mean time.</p><p>Level: advanced</p><p>-seealso: <code>MATMFFD_WP</code>, <code>MATMFFD</code>, <code>MatMFFDSetFunctionError()</code>, <code>MatCreateSNESMF()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatMFFDWPSetComputeNormU.html"><code>Mat/MatMFFDWPSetComputeNormU</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2976-L2996">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscBool, Int64, Vector{PETSc.LibPETSc.PetscVec}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm, PETSc.LibPETSc.PetscBool, Int64, Vector{PETSc.LibPETSc.PetscVec}}"><code>PETSc.LibPETSc.MatNullSpaceCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SP::MatNullSpace = MatNullSpaceCreate(petsclib::PetscLibType,comm::MPI_Comm, has_cnst::PetscBool, n::PetscInt, vecs::Vector{PetscVec})</code></pre><p>Creates a <code>MatNullSpace</code> data structure used to project vectors out of null spaces.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>comm</code>     - the MPI communicator associated with the object</li><li><code>has_cnst</code> - <code>PETSC_TRUE</code> if the null space contains the constant vector; otherwise <code>PETSC_FALSE</code></li><li><code>n</code>        - number of vectors (excluding constant vector) in null space</li><li><code>vecs</code>     - the vectors that span the null space (excluding the constant vector);</li></ul><p>these vectors must be orthonormal. These vectors are NOT copied, so do not change them after this call. You should free the array that you pass in and destroy the vectors (this will reduce the reference count for them by one).</p><p>Output Parameter:</p><ul><li><code>SP</code> - the null space context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceDestroy()</code>, <code>MatNullSpaceRemove()</code>, <code>MatSetNullSpace()</code>, <code>MatNullSpaceSetFunction()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceCreate.html"><code>Mat/MatNullSpaceCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2834-L2858">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceCreateRigidBody-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceCreateRigidBody-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatNullSpaceCreateRigidBody</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sp::MatNullSpace = MatNullSpaceCreateRigidBody(petsclib::PetscLibType,coords::PetscVec)</code></pre><p>create rigid body modes from coordinates</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>coords</code> - block of coordinates of each node, must have block size set</li></ul><p>Output Parameter:</p><ul><li><code>sp</code> - the null space</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceCreate()</code>, <code>MatSetNearNullSpace()</code>, <code>MatSetNullSpace()</code>, <code>PCGAMG</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceCreateRigidBody.html"><code>Mat/MatNullSpaceCreateRigidBody</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2766-L2784">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}}"><code>PETSc.LibPETSc.MatNullSpaceDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNullSpaceDestroy(petsclib::PetscLibType,sp::MatNullSpace)</code></pre><p>Destroys a data structure used to project vectors out of null spaces.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>sp</code> - the null space context to be destroyed</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceCreate()</code>, <code>MatNullSpaceRemove()</code>, <code>MatNullSpaceSetFunction()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceDestroy.html"><code>Mat/MatNullSpaceDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2876-L2891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceGetVecs-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, Vector{PETSc.LibPETSc.PetscVec}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceGetVecs-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, Vector{PETSc.LibPETSc.PetscVec}}"><code>PETSc.LibPETSc.MatNullSpaceGetVecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_const::PetscBool,n::PetscInt = MatNullSpaceGetVecs(petsclib::PetscLibType,sp::MatNullSpace, vecs::Vector{PetscVec})</code></pre><p>get the vectors defining the null space</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>sp</code> - null space object</li></ul><p>Output Parameters:</p><ul><li><code>has_const</code> - <code>PETSC_TRUE</code> if the null space contains the constant vector, otherwise <code>PETSC_FALSE</code></li><li><code>n</code>         - number of vectors (excluding constant vector) in the null space</li><li><code>vecs</code>      - returns array of length <code>n</code> containing the orthonormal vectors that span the null space (excluding the constant vector), <code>NULL</code> if <code>n</code> is 0</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceCreate()</code>, <code>MatGetNullSpace()</code>, <code>MatGetNearNullSpace()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceGetVecs.html"><code>Mat/MatNullSpaceGetVecs</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2725-L2745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceRemove-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.PetscVec}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceRemove-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.PetscVec}"><code>PETSc.LibPETSc.MatNullSpaceRemove</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNullSpaceRemove(petsclib::PetscLibType,sp::MatNullSpace, vec::PetscVec)</code></pre><p>Removes all the components of a null space from a vector.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>sp</code>  - the null space context (if this is <code>NULL</code> then no null space is removed)</li><li><code>vec</code> - the vector from which the null space is to be removed</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceCreate()</code>, <code>MatNullSpaceDestroy()</code>, <code>MatNullSpaceSetFunction()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceRemove.html"><code>Mat/MatNullSpaceRemove</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2907-L2923">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.MatNullSpaceRemoveFn, Nothing}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceSetFunction-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.MatNullSpaceRemoveFn, Nothing}"><code>PETSc.LibPETSc.MatNullSpaceSetFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNullSpaceSetFunction(petsclib::PetscLibType,sp::MatNullSpace, rem::MatNullSpaceRemoveFn, ctx::Cvoid)</code></pre><p>set a function that removes a null space from a vector out of null spaces.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>sp</code>  - the <code>MatNullSpace</code> null space object</li><li><code>rem</code> - the function that removes the null space</li><li><code>ctx</code> - context for the remove function</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceDestroy()</code>, <code>MatNullSpaceRemove()</code>, <code>MatSetNullSpace()</code>, <code>MatNullSpaceCreate()</code>, <code>MatNullSpaceRemoveFn</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceSetFunction.html"><code>Mat/MatNullSpaceSetFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2691-L2709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceTest-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceTest-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatNullSpaceTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isNull::PetscBool = MatNullSpaceTest(petsclib::PetscLibType,sp::MatNullSpace, mat::PetscMat)</code></pre><p>Tests if the claimed null space is really a null space of a matrix</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>sp</code>  - the null space context</li><li><code>mat</code> - the matrix</li></ul><p>Output Parameter:</p><ul><li><code>isNull</code> - <code>PETSC_TRUE</code> if the nullspace is valid for this matrix</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>MatNullSpaceCreate()</code>, <code>MatNullSpaceDestroy()</code>, <code>MatNullSpaceSetFunction()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceTest.html"><code>Mat/MatNullSpaceTest</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2939-L2958">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatNullSpaceView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatNullSpaceView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatNullSpace}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatNullSpaceView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatNullSpaceView(petsclib::PetscLibType,sp::MatNullSpace, viewer::PetscViewer)</code></pre><p>Visualizes a null space object.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>sp</code>     - the null space</li><li><code>viewer</code> - visualization context</li></ul><p>Level: advanced</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatNullSpace</code>, <code>PetscViewer</code>, <code>MatNullSpaceCreate()</code>, <code>PetscViewerASCIIOpen()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatNullSpaceView.html"><code>Mat/MatNullSpaceView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2802-L2818">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningApply-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningApply</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningApply(petsclib::PetscLibType,matp::MatPartitioning, partitioning::IS)</code></pre><p>Gets a partitioning for the graph represented by a sparse matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>matp</code> - the matrix partitioning object</li></ul><p>Output Parameter:</p><ul><li><code>partitioning</code> - the partitioning. For each local node this tells the MPI rank that that node is assigned to.</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_partitioning_type &lt;type&gt;</code> - set the partitioning package or algorithm to use</li><li><code>-mat_partitioning_view</code>        - display information about the partitioning object</li></ul><p>Level: beginner</p><p>The user can define additional partitionings; see <code>MatPartitioningRegister()</code>.</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningRegister()</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningDestroy()</code>, <code>MatPartitioningSetAdjacency()</code>, <code>ISPartitioningToNumbering()</code>, <code>ISPartitioningCount()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningApply.html"><code>Mat/MatPartitioningApply</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1275-L1301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningApplyND-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningApplyND-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningApplyND</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningApplyND(petsclib::PetscLibType,matp::MatPartitioning, partitioning::IS)</code></pre><p>Gets a nested dissection partitioning for a matrix.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>matp</code> - the matrix partitioning object</li></ul><p>Output Parameter:</p><ul><li><code>partitioning</code> - the partitioning. For each local node, a positive value indicates the processor</li></ul><p>number the node has been assigned to. Negative x values indicate the separator level -(x+1).</p><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioningRegister()</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningDestroy()</code>, <code>MatPartitioningSetAdjacency()</code>, <code>ISPartitioningToNumbering()</code>, <code>ISPartitioningCount()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningApplyND.html"><code>Mat/MatPartitioningApplyND</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1236-L1257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoGetEigenNumber-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoGetEigenNumber-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningChacoGetEigenNumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num::PetscInt = MatPartitioningChacoGetEigenNumber(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Gets the number of eigenvectors used by Chaco.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>num</code> - number of eigenvectors</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenNumber()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoGetEigenNumber.html"><code>Mat/MatPartitioningChacoGetEigenNumber</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2655-L2673">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoGetEigenSolver-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoEigenType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoGetEigenSolver-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoEigenType}"><code>PETSc.LibPETSc.MatPartitioningChacoGetEigenSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoGetEigenSolver(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoEigenType)</code></pre><p>Get the eigensolver used by the Chaco partitioner.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>method</code> - the method</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenSolver()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoGetEigenSolver.html"><code>Mat/MatPartitioningChacoGetEigenSolver</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2518-L2536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoGetEigenTol-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoGetEigenTol-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningChacoGetEigenTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tol::PetscReal = MatPartitioningChacoGetEigenTol(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Gets the eigensolver tolerance used by Chaco</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>tol</code> - the tolerance</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenTol()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoGetEigenTol.html"><code>Mat/MatPartitioningChacoGetEigenTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2585-L2603">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoGetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoGlobalType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoGetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoGlobalType}"><code>PETSc.LibPETSc.MatPartitioningChacoGetGlobal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoGetGlobal(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoGlobalType)</code></pre><p>Get the global method used by the Chaco partitioner.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>method</code> - the method</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetGlobal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoGetGlobal.html"><code>Mat/MatPartitioningChacoGetGlobal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2343-L2361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoGetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoLocalType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoGetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoLocalType}"><code>PETSc.LibPETSc.MatPartitioningChacoGetLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoGetLocal(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoLocalType)</code></pre><p>Get local method used by the Chaco partitioner.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>method</code> - the method</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoGetLocal.html"><code>Mat/MatPartitioningChacoGetLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2412-L2430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetCoarseLevel-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetCoarseLevel-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><code>PETSc.LibPETSc.MatPartitioningChacoSetCoarseLevel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetCoarseLevel(petsclib::PetscLibType,part::MatPartitioning, level::PetscReal)</code></pre><p>Set the coarse level parameter for the Chaco partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>  - the partitioning context</li><li><code>level</code> - the coarse level in range [0.0,1.0]</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_coarse &lt;l&gt;</code> - Coarse level</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetCoarseLevel.html"><code>Mat/MatPartitioningChacoSetCoarseLevel</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2446-L2466">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetEigenNumber-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetEigenNumber-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><code>PETSc.LibPETSc.MatPartitioningChacoSetEigenNumber</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetEigenNumber(petsclib::PetscLibType,part::MatPartitioning, num::PetscInt)</code></pre><p>Sets the number of eigenvectors to compute by Chaco during partitioning during partitioning.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>num</code>  - the number of eigenvectors</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_eigen_number &lt;n&gt;</code> - Number of eigenvectors</li></ul><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenSolver()</code>, <code>MatPartitioningChacoGetEigenTol()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetEigenNumber.html"><code>Mat/MatPartitioningChacoSetEigenNumber</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2621-L2639">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetEigenSolver-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoEigenType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetEigenSolver-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoEigenType}"><code>PETSc.LibPETSc.MatPartitioningChacoSetEigenSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetEigenSolver(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoEigenType)</code></pre><p>Set the eigensolver method for Chaco partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>   - the partitioning context</li><li><code>method</code> - one of <code>MP_CHACO_LANCZOS</code> or <code>MP_CHACO_RQI</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_eigen_solver &lt;method&gt;</code> - the eigensolver</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenTol()</code>, <code>MatPartitioningChacoSetEigenNumber()</code>, <code>MatPartitioningChacoGetEigenSolver()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetEigenSolver.html"><code>Mat/MatPartitioningChacoSetEigenSolver</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2482-L2502">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetEigenTol-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetEigenTol-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><code>PETSc.LibPETSc.MatPartitioningChacoSetEigenTol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetEigenTol(petsclib::PetscLibType,part::MatPartitioning, tol::PetscReal)</code></pre><p>Sets the tolerance for the eigensolver used by Chaco</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>tol</code>  - the tolerance</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_eigen_tol &lt;tol&gt;</code> - Tolerance for eigensolver</li></ul><p>-seealso: <code>MatPartitioningType</code>, <code>MatPartitioning</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetEigenSolver()</code>, <code>MatPartitioningChacoGetEigenTol()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetEigenTol.html"><code>Mat/MatPartitioningChacoSetEigenTol</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2552-L2569">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoGlobalType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoGlobalType}"><code>PETSc.LibPETSc.MatPartitioningChacoSetGlobal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetGlobal(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoGlobalType)</code></pre><p>Set the global method for Chaco partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>   - the partitioning context</li><li><code>method</code> - one of <code>MP_CHACO_MULTILEVEL</code>, <code>MP_CHACO_SPECTRAL</code>, <code>MP_CHACO_LINEAR</code>,</li></ul><p><code>MP_CHACO_RANDOM</code> or <code>MP_CHACO_SCATTERED</code></p><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_global &lt;method&gt;</code> - the global method</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioning</code>, <code>MatPartioningSetType()</code>, <code>MatPartitioningType</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetLocal()</code>, <code>MatPartitioningChacoGetGlobal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetGlobal.html"><code>Mat/MatPartitioningChacoSetGlobal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2307-L2327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningChacoSetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoLocalType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningChacoSetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPChacoLocalType}"><code>PETSc.LibPETSc.MatPartitioningChacoSetLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningChacoSetLocal(petsclib::PetscLibType,part::MatPartitioning, method::MPChacoLocalType)</code></pre><p>Set the local method for the Chaco partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>   - the partitioning context</li><li><code>method</code> - one of <code>MP_CHACO_KERNIGHAN</code> or <code>MP_CHACO_NONE</code></li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_chaco_local &lt;method&gt;</code> - the local method</li></ul><p>Level: advanced</p><p>-seealso: <code>MatPartitioningType</code>, <code>MATPARTITIONINGCHACO</code>, <code>MatPartitioningChacoSetGlobal()</code>, <code>MatPartitioningChacoGetLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningChacoSetLocal.html"><code>Mat/MatPartitioningChacoSetLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2377-L2396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningCreate-Tuple{PETSc.LibPETSc.PetscLibType, MPI.Comm}"><code>PETSc.LibPETSc.MatPartitioningCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newp::MatPartitioning = MatPartitioningCreate(petsclib::PetscLibType,comm::MPI_Comm)</code></pre><p>Creates a partitioning context.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>comm</code> - MPI communicator</li></ul><p>Output Parameter:</p><ul><li><code>newp</code> - location to put the context</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningSetType()</code>, <code>MatPartitioningApply()</code>, <code>MatPartitioningDestroy()</code>, <code>MatPartitioningSetAdjacency()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningCreate.html"><code>Mat/MatPartitioningCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1602-L1621">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningDestroy(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Destroys the partitioning context.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningDestroy.html"><code>Mat/MatPartitioningDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1427-L1442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningGetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningGetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningGetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type::MatPartitioningType = MatPartitioningGetType(petsclib::PetscLibType,partitioning::MatPartitioning)</code></pre><p>Gets the Partitioning method type and name (as a string) from the partitioning context.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>partitioning</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>type</code> - partitioner type</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningRegisterDestroy()</code>, <code>MatPartitioningRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningGetType.html"><code>Mat/MatPartitioningGetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1165-L1184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningGetUseEdgeWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningGetUseEdgeWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningGetUseEdgeWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">use_edge_weights::PetscBool = MatPartitioningGetUseEdgeWeights(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Get a flag that indicates whether or not to edge weights are used.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>use_edge_weights</code> - the flag indicateing whether or not to edge weights are used.</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningSetType()</code>, <code>MatPartitioningSetVertexWeights()</code>, <code>MatPartitioningSetPartitionWeights()</code>, <code>MatPartitioningSetUseEdgeWeights</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningGetUseEdgeWeights.html"><code>Mat/MatPartitioningGetUseEdgeWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1565-L1584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningHierarchicalGetCoarseparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningHierarchicalGetCoarseparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningHierarchicalGetCoarseparts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningHierarchicalGetCoarseparts(petsclib::PetscLibType,part::MatPartitioning, coarseparts::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningHierarchicalGetCoarseparts.html"><code>Mat/MatPartitioningHierarchicalGetCoarseparts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1833-L1838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningHierarchicalGetFineparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningHierarchicalGetFineparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningHierarchicalGetFineparts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningHierarchicalGetFineparts(petsclib::PetscLibType,part::MatPartitioning, fineparts::IS)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningHierarchicalGetFineparts.html"><code>Mat/MatPartitioningHierarchicalGetFineparts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1810-L1815">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningHierarchicalSetNcoarseparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningHierarchicalSetNcoarseparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><code>PETSc.LibPETSc.MatPartitioningHierarchicalSetNcoarseparts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningHierarchicalSetNcoarseparts(petsclib::PetscLibType,part::MatPartitioning, ncoarseparts::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningHierarchicalSetNcoarseparts.html"><code>Mat/MatPartitioningHierarchicalSetNcoarseparts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1856-L1861">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningHierarchicalSetNfineparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningHierarchicalSetNfineparts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><code>PETSc.LibPETSc.MatPartitioningHierarchicalSetNfineparts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningHierarchicalSetNfineparts(petsclib::PetscLibType,part::MatPartitioning, nfineparts::PetscInt)</code></pre><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningHierarchicalSetNfineparts.html"><code>Mat/MatPartitioningHierarchicalSetNfineparts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1877-L1882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningImprove-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningImprove-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningImprove</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningImprove(petsclib::PetscLibType,matp::MatPartitioning, partitioning::IS)</code></pre><p>Improves the quality of a given partition.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>matp</code>         - the matrix partitioning object</li><li><code>partitioning</code> - the original partitioning. For each local node this tells the processor</li></ul><p>number that that node is assigned to.</p><p>Options Database Key:</p><ul><li><code>-mat_partitioning_improve</code> - improve the quality of the given partition</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningApply()</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningDestroy()</code>, <code>MatPartitioningSetAdjacency()</code>, <code>ISPartitioningToNumbering()</code>, <code>ISPartitioningCount()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningImprove.html"><code>Mat/MatPartitioningImprove</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1319-L1341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPTScotchGetImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPTScotchGetImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningPTScotchGetImbalance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">imb::PetscReal = MatPartitioningPTScotchGetImbalance(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Gets the value of the load imbalance ratio used during strategy selection.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>imb</code> - the load imbalance ratio</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGSCOTCH</code>, <code>MatPartitioningPTScotchSetImbalance()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPTScotchGetImbalance.html"><code>Mat/MatPartitioningPTScotchGetImbalance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2207-L2226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPTScotchGetStrategy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPPTScotchStrategyType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPTScotchGetStrategy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPPTScotchStrategyType}"><code>PETSc.LibPETSc.MatPartitioningPTScotchGetStrategy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPTScotchGetStrategy(petsclib::PetscLibType,part::MatPartitioning, strategy::MPPTScotchStrategyType)</code></pre><p>Gets the strategy used in PTScotch.</p><p>Not Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>strategy</code> - the strategy</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGSCOTCH</code>, <code>MatPartitioningPTScotchSetStrategy()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPTScotchGetStrategy.html"><code>Mat/MatPartitioningPTScotchGetStrategy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2273-L2291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPTScotchSetImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPTScotchSetImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><code>PETSc.LibPETSc.MatPartitioningPTScotchSetImbalance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPTScotchSetImbalance(petsclib::PetscLibType,part::MatPartitioning, imb::PetscReal)</code></pre><p>Sets the value of the load imbalance ratio to be used during strategy selection.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>imb</code>  - the load imbalance ratio</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_ptscotch_imbalance &lt;imb&gt;</code> - set load imbalance ratio</li></ul><p>-seealso: <code>MATPARTITIONINGSCOTCH</code>, <code>MatPartitioningPTScotchSetStrategy()</code>, <code>MatPartitioningPTScotchGetImbalance()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPTScotchSetImbalance.html"><code>Mat/MatPartitioningPTScotchSetImbalance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2173-L2191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPTScotchSetStrategy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPPTScotchStrategyType}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPTScotchSetStrategy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.MPPTScotchStrategyType}"><code>PETSc.LibPETSc.MatPartitioningPTScotchSetStrategy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPTScotchSetStrategy(petsclib::PetscLibType,part::MatPartitioning, strategy::MPPTScotchStrategyType)</code></pre><p>Sets the strategy to be used in PTScotch.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>     - the partitioning context</li><li><code>strategy</code> - the strategy, one of</li></ul><p>-seealso: <code>MATPARTITIONINGSCOTCH</code>, <code>MatPartitioningPTScotchSetImbalance()</code>, <code>MatPartitioningPTScotchGetStrategy()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPTScotchSetStrategy.html"><code>Mat/MatPartitioningPTScotchSetStrategy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2244-L2257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningParmetisGetEdgeCut-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningParmetisGetEdgeCut-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningParmetisGetEdgeCut</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cut::PetscInt = MatPartitioningParmetisGetEdgeCut(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Returns the number of edge cuts in the vertex partition.</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Output Parameter:</p><ul><li><code>cut</code> - the edge cut</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARMETIS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningParmetisGetEdgeCut.html"><code>Mat/MatPartitioningParmetisGetEdgeCut</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2139-L2155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningParmetisSetCoarseSequential-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningParmetisSetCoarseSequential-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningParmetisSetCoarseSequential</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningParmetisSetCoarseSequential(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Use the sequential code to do the partitioning of the coarse grid.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARMETIS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningParmetisSetCoarseSequential.html"><code>Mat/MatPartitioningParmetisSetCoarseSequential</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2075-L2091">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningParmetisSetRepartition-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningParmetisSetRepartition-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningParmetisSetRepartition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningParmetisSetRepartition(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Repartition current mesh to rebalance computation.</p><p>Logically Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARMETIS</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningParmetisSetRepartition.html"><code>Mat/MatPartitioningParmetisSetRepartition</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2107-L2123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPartySetBipart-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPartySetBipart-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatPartitioningPartySetBipart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPartySetBipart(petsclib::PetscLibType,part::MatPartitioning, bp::PetscBool)</code></pre><p>Activate or deactivate recursive bisection in the Party partitioner</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>bp</code>   - boolean flag</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_party_bipart</code> - Bipartitioning option on/off</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARTY</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPartySetBipart.html"><code>Mat/MatPartitioningPartySetBipart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2040-L2059">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPartySetCoarseLevel-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPartySetCoarseLevel-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Float64}"><code>PETSc.LibPETSc.MatPartitioningPartySetCoarseLevel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPartySetCoarseLevel(petsclib::PetscLibType,part::MatPartitioning, level::PetscReal)</code></pre><p>Set the coarse level parameter for the Party partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>  - the partitioning context</li><li><code>level</code> - the coarse level in range [0.0,1.0]</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_party_coarse &lt;l&gt;</code> - Coarse level</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARTY</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPartySetCoarseLevel.html"><code>Mat/MatPartitioningPartySetCoarseLevel</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1968-L1988">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPartySetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, String}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPartySetGlobal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, String}"><code>PETSc.LibPETSc.MatPartitioningPartySetGlobal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPartySetGlobal(petsclib::PetscLibType,part::MatPartitioning, glob::String)</code></pre><p>Set global method for Party partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>   - the partitioning context</li><li><code>global</code> - a string representing the method</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_party_global &lt;method&gt;</code> - the global method</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARTY</code>, <code>MatPartitioningPartySetLocal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPartySetGlobal.html"><code>Mat/MatPartitioningPartySetGlobal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1898-L1917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPartySetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, String}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPartySetLocal-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, String}"><code>PETSc.LibPETSc.MatPartitioningPartySetLocal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPartySetLocal(petsclib::PetscLibType,part::MatPartitioning, loc::String)</code></pre><p>Set local method used by the Party partitioner.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>  - the partitioning context</li><li><code>local</code> - a string representing the method</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_party_local &lt;method&gt;</code> - the local method</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARTY</code>, <code>MatPartitioningPartySetGlobal()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPartySetLocal.html"><code>Mat/MatPartitioningPartySetLocal</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1933-L1952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningPartySetMatchOptimization-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningPartySetMatchOptimization-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatPartitioningPartySetMatchOptimization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningPartySetMatchOptimization(petsclib::PetscLibType,part::MatPartitioning, opt::PetscBool)</code></pre><p>Activate matching optimization for graph reduction.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>opt</code>  - boolean flag</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_party_match_optimization</code> - Matching optimization on/off</li></ul><p>Level: advanced</p><p>-seealso: <code>MATPARTITIONINGPARTY</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningPartySetMatchOptimization.html"><code>Mat/MatPartitioningPartySetMatchOptimization</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L2004-L2024">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningRegister-Tuple{PETSc.LibPETSc.PetscLibType, String, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatPartitioningRegister</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningRegister(petsclib::PetscLibType,sname::String, fnc::external)</code></pre><p>Adds a new sparse matrix partitioning to the  matrix package.</p><p>Not Collective, No Fortran Support</p><p>Input Parameters:</p><ul><li><code>sname</code>    - name of partitioning (for example <code>MATPARTITIONINGCURRENT</code>) or <code>MATPARTITIONINGPARMETIS</code></li><li><code>function</code> - function pointer that creates the partitioning type</li></ul><p>Level: developer</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningRegisterDestroy()</code>, <code>MatPartitioningRegisterAll()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningRegister.html"><code>Mat/MatPartitioningRegister</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1133-L1149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetAdjacency-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscMat}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetAdjacency-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscMat}"><code>PETSc.LibPETSc.MatPartitioningSetAdjacency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetAdjacency(petsclib::PetscLibType,part::MatPartitioning, adj::PetscMat)</code></pre><p>Sets the adjacency graph (matrix) of the thing to be partitioned.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>adj</code>  - the adjacency matrix, this can be any <code>MatType</code> but the natural representation is <code>MATMPIADJ</code></li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetAdjacency.html"><code>Mat/MatPartitioningSetAdjacency</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1394-L1411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}}"><code>PETSc.LibPETSc.MatPartitioningSetFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetFromOptions(petsclib::PetscLibType,part::MatPartitioning)</code></pre><p>Sets various partitioning options from the options database for the partitioning object</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>part</code> - the partitioning context.</li></ul><p>Options Database Keys:</p><ul><li><code>-mat_partitioning_type  &lt;type&gt;</code> - (for instance, parmetis), use -help for a list of available methods</li><li><code>-mat_partitioning_nparts</code>       - number of subgraphs</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetFromOptions.html"><code>Mat/MatPartitioningSetFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1742-L1762">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetNParts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetNParts-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><code>PETSc.LibPETSc.MatPartitioningSetNParts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetNParts(petsclib::PetscLibType,part::MatPartitioning, n::PetscInt)</code></pre><p>Set how many partitions need to be created; by default this is one per processor. Certain partitioning schemes may in fact only support that option.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context</li><li><code>n</code>    - the number of partitions</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningApply()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetNParts.html"><code>Mat/MatPartitioningSetNParts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1202-L1220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetNumberVertexWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetNumberVertexWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Int64}"><code>PETSc.LibPETSc.MatPartitioningSetNumberVertexWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetNumberVertexWeights(petsclib::PetscLibType,partitioning::MatPartitioning, ncon::PetscInt)</code></pre><p>Sets the number of weights per vertex</p><p>Not Collective</p><p>Input Parameters:</p><ul><li><code>partitioning</code> - the partitioning context</li><li><code>ncon</code>         - the number of weights</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningSetVertexWeights()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetNumberVertexWeights.html"><code>Mat/MatPartitioningSetNumberVertexWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1778-L1794">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetPartitionWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Vector{Float64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetPartitionWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Vector{Float64}}"><code>PETSc.LibPETSc.MatPartitioningSetPartitionWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetPartitionWeights(petsclib::PetscLibType,part::MatPartitioning, weights::Vector{PetscReal})</code></pre><p>Sets the weights for each partition.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>part</code>    - the partitioning context</li><li><code>weights</code> - An array of size nparts that is used to specify the fraction of</li></ul><p>vertex weight that should be distributed to each sub-domain for the balance constraint. If all of the sub-domains are to be of the same size, then each of the nparts elements should be set to a value of 1/nparts. Note that the sum of all of the weights should be one.</p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningSetVertexWeights()</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningSetType()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetPartitionWeights.html"><code>Mat/MatPartitioningSetPartitionWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1491-L1512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Int8}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetType-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Int8}}"><code>PETSc.LibPETSc.MatPartitioningSetType</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetType(petsclib::PetscLibType,part::MatPartitioning, type::MatPartitioningType)</code></pre><p>Sets the type of partitioner to use</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code> - the partitioning context.</li><li><code>type</code> - a known method</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_type  &lt;type&gt;</code> - (for instance, parmetis), use -help for a list of available methods or see  <code>MatPartitioningType</code></li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningApply()</code>, <code>MatPartitioningType</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetType.html"><code>Mat/MatPartitioningSetType</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1707-L1726">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetUseEdgeWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetUseEdgeWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.PetscBool}"><code>PETSc.LibPETSc.MatPartitioningSetUseEdgeWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetUseEdgeWeights(petsclib::PetscLibType,part::MatPartitioning, use_edge_weights::PetscBool)</code></pre><p>Set a flag to indicate whether or not to use edge weights.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>part</code>             - the partitioning context</li><li><code>use_edge_weights</code> - the flag indicateing whether or not to use edge weights. By default no edge weights will be used,</li></ul><p>that is, use<em>edge</em>weights is set to FALSE. If set use<em>edge</em>weights to TRUE, users need to make sure legal edge weights are stored in an ADJ matrix.</p><p>Options Database Key:</p><ul><li><code>-mat_partitioning_use_edge_weights</code> - (true or false)</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningSetType()</code>, <code>MatPartitioningSetVertexWeights()</code>, <code>MatPartitioningSetPartitionWeights()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetUseEdgeWeights.html"><code>Mat/MatPartitioningSetUseEdgeWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1528-L1549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningSetVertexWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Vector{Int64}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningSetVertexWeights-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Vector{Int64}}"><code>PETSc.LibPETSc.MatPartitioningSetVertexWeights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningSetVertexWeights(petsclib::PetscLibType,part::MatPartitioning, weights::Vector{PetscInt})</code></pre><p>Sets the weights for vertices for a partitioning.</p><p>Logically Collective</p><p>Input Parameters:</p><ul><li><code>part</code>    - the partitioning context</li><li><code>weights</code> - the weights, on each process this array must have the same size as the number of local rows times the value passed with <code>MatPartitioningSetNumberVertexWeights()</code> or</li></ul><p>1 if that is not provided</p><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningCreate()</code>, <code>MatPartitioningSetType()</code>, <code>MatPartitioningSetPartitionWeights()</code>, <code>MatPartitioningSetNumberVertexWeights()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningSetVertexWeights.html"><code>Mat/MatPartitioningSetVertexWeights</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1458-L1475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Nothing}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningView-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Nothing}}"><code>PETSc.LibPETSc.MatPartitioningView</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningView(petsclib::PetscLibType,part::MatPartitioning, viewer::PetscViewer)</code></pre><p>Prints the partitioning data structure.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>part</code>   - the partitioning context</li><li><code>viewer</code> - optional visualization context</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>PetscViewer</code>, <code>PetscViewerASCIIOpen()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningView.html"><code>Mat/MatPartitioningView</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1675-L1691">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Nothing}, String}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningViewFromOptions-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, Ptr{Nothing}, String}"><code>PETSc.LibPETSc.MatPartitioningViewFromOptions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningViewFromOptions(petsclib::PetscLibType,A::MatPartitioning, obj::PetscObject, name::String)</code></pre><p>View a partitioning context from the options database</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>A</code>    - the partitioning context</li><li><code>obj</code>  - Optional object that provides the prefix used in the options database check</li><li><code>name</code> - command line option</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_view [viewertype]:...</code> - the viewer and its options</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningView()</code>, <code>PetscObjectViewFromOptions()</code>, <code>MatPartitioningCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningViewFromOptions.html"><code>Mat/MatPartitioningViewFromOptions</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1639-L1659">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatPartitioningViewImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatPartitioningViewImbalance-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatPartitioning}, PETSc.LibPETSc.IS}"><code>PETSc.LibPETSc.MatPartitioningViewImbalance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatPartitioningViewImbalance(petsclib::PetscLibType,matp::MatPartitioning, partitioning::IS)</code></pre><p>Display partitioning imbalance information.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>matp</code>         - the matrix partitioning object</li><li><code>partitioning</code> - the partitioning. For each local node this tells the MPI rank that that node is assigned to.</li></ul><p>Options Database Key:</p><ul><li><code>-mat_partitioning_view_balance</code> - view the balance information from the last partitioning</li></ul><p>Level: beginner</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatPartitioning</code>, <code>MatPartitioningType</code>, <code>MatPartitioningApply()</code>, <code>MatPartitioningView()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatPartitioningViewImbalance.html"><code>Mat/MatPartitioningViewImbalance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1359-L1378">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeColoringCreate-Tuple{PETSc.LibPETSc.PetscLibType, PETSc.LibPETSc.PetscMat, Ptr{PETSc.LibPETSc._n_ISColoring}}"><code>PETSc.LibPETSc.MatTransposeColoringCreate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">color::MatTransposeColoring = MatTransposeColoringCreate(petsclib::PetscLibType,mat::PetscMat, iscoloring::ISColoring)</code></pre><p>Creates a matrix coloring context for the matrix product C = A*B^T.</p><p>Collective</p><p>Input Parameters:</p><ul><li><code>mat</code>        - the matrix product C</li><li><code>iscoloring</code> - the coloring of the matrix; usually obtained with <code>MatColoringCreate()</code> or <code>DMCreateColoring()</code></li></ul><p>Output Parameter:</p><ul><li><code>color</code> - the new coloring context</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeColoringDestroy()</code>, <code>MatTransColoringApplySpToDen()</code>, <code>MatTransColoringApplyDenToSp()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeColoringCreate.html"><code>Mat/MatTransposeColoringCreate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1095-L1115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PETSc.LibPETSc.MatTransposeColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}}"><a class="docstring-binding" href="#PETSc.LibPETSc.MatTransposeColoringDestroy-Tuple{PETSc.LibPETSc.PetscLibType, Ptr{PETSc.LibPETSc._n_MatTransposeColoring}}"><code>PETSc.LibPETSc.MatTransposeColoringDestroy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MatTransposeColoringDestroy(petsclib::PetscLibType,c::MatTransposeColoring)</code></pre><p>Destroys a coloring context for matrix product C = A*B^T that was created via <code>MatTransposeColoringCreate()</code>.</p><p>Collective</p><p>Input Parameter:</p><ul><li><code>c</code> - coloring context</li></ul><p>Level: intermediate</p><p>-seealso: <a href="ch_matrices"></a>, <code>Mat</code>, <code>MatTransposeColoringCreate()</code></p><p><strong>External Links</strong></p><ul><li>PETSc Manual: <a href="https://petsc.org/release/docs/manualpages/Mat/MatTransposeColoringDestroy.html"><code>Mat/MatTransposeColoringDestroy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/PETSc.jl/blob/8a76b3caf4d755202b32dea3ca5af71ee5b62c4e/src/autowrapped/Mataddons_wrappers.jl#L1063-L1079">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vec_lowlevel/">« Vec</a><a class="docs-footer-nextpage" href="../dm_lowlevel/">DM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 16 January 2026 08:10">Friday 16 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
